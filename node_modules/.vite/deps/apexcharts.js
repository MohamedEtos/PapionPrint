import "./chunk-PZ5AY32C.js";

// node_modules/apexcharts/dist/apexcharts.esm.js
function _typeof(t) {
  return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t2) {
    return typeof t2;
  } : function(t2) {
    return t2 && "function" == typeof Symbol && t2.constructor === Symbol && t2 !== Symbol.prototype ? "symbol" : typeof t2;
  })(t);
}
function _classCallCheck(t, e) {
  if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(t, e) {
  for (var i = 0; i < e.length; i++) {
    var s = e[i];
    s.enumerable = s.enumerable || false, s.configurable = true, "value" in s && (s.writable = true), Object.defineProperty(t, s.key, s);
  }
}
function _createClass(t, e, i) {
  return e && _defineProperties(t.prototype, e), i && _defineProperties(t, i), t;
}
function _defineProperty(t, e, i) {
  return e in t ? Object.defineProperty(t, e, { value: i, enumerable: true, configurable: true, writable: true }) : t[e] = i, t;
}
function _objectSpread(t) {
  for (var e = 1; e < arguments.length; e++) {
    var i = null != arguments[e] ? arguments[e] : {}, s = Object.keys(i);
    "function" == typeof Object.getOwnPropertySymbols && (s = s.concat(Object.getOwnPropertySymbols(i).filter(function(t2) {
      return Object.getOwnPropertyDescriptor(i, t2).enumerable;
    }))), s.forEach(function(e2) {
      _defineProperty(t, e2, i[e2]);
    });
  }
  return t;
}
function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), e && _setPrototypeOf(t, e);
}
function _getPrototypeOf(t) {
  return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(t2) {
    return t2.__proto__ || Object.getPrototypeOf(t2);
  })(t);
}
function _setPrototypeOf(t, e) {
  return (_setPrototypeOf = Object.setPrototypeOf || function(t2, e2) {
    return t2.__proto__ = e2, t2;
  })(t, e);
}
function _assertThisInitialized(t) {
  if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}
function _possibleConstructorReturn(t, e) {
  return !e || "object" != typeof e && "function" != typeof e ? _assertThisInitialized(t) : e;
}
function _toConsumableArray(t) {
  return _arrayWithoutHoles(t) || _iterableToArray(t) || _nonIterableSpread();
}
function _arrayWithoutHoles(t) {
  if (Array.isArray(t)) {
    for (var e = 0, i = new Array(t.length); e < t.length; e++) i[e] = t[e];
    return i;
  }
}
function _iterableToArray(t) {
  if (Symbol.iterator in Object(t) || "[object Arguments]" === Object.prototype.toString.call(t)) return Array.from(t);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
var Utils = (function() {
  function t() {
    _classCallCheck(this, t);
  }
  return _createClass(t, [{ key: "shadeRGBColor", value: function(t2, e) {
    var i = e.split(","), s = t2 < 0 ? 0 : 255, a = t2 < 0 ? -1 * t2 : t2, r = parseInt(i[0].slice(4)), n = parseInt(i[1]), o = parseInt(i[2]);
    return "rgb(" + (Math.round((s - r) * a) + r) + "," + (Math.round((s - n) * a) + n) + "," + (Math.round((s - o) * a) + o) + ")";
  } }, { key: "shadeHexColor", value: function(t2, e) {
    var i = parseInt(e.slice(1), 16), s = t2 < 0 ? 0 : 255, a = t2 < 0 ? -1 * t2 : t2, r = i >> 16, n = i >> 8 & 255, o = 255 & i;
    return "#" + (16777216 + 65536 * (Math.round((s - r) * a) + r) + 256 * (Math.round((s - n) * a) + n) + (Math.round((s - o) * a) + o)).toString(16).slice(1);
  } }, { key: "shadeColor", value: function(t2, e) {
    return e.length > 7 ? this.shadeRGBColor(t2, e) : this.shadeHexColor(t2, e);
  } }], [{ key: "bind", value: function(t2, e) {
    return function() {
      return t2.apply(e, arguments);
    };
  } }, { key: "isObject", value: function(t2) {
    return t2 && "object" === _typeof(t2) && !Array.isArray(t2) && null != t2;
  } }, { key: "listToArray", value: function(t2) {
    var e, i = [];
    for (e = 0; e < t2.length; e++) i[e] = t2[e];
    return i;
  } }, { key: "extend", value: function(t2, e) {
    var i = this;
    "function" != typeof Object.assign && (Object.assign = function(t3) {
      if (null == t3) throw new TypeError("Cannot convert undefined or null to object");
      for (var e2 = Object(t3), i2 = 1; i2 < arguments.length; i2++) {
        var s2 = arguments[i2];
        if (null != s2) for (var a in s2) s2.hasOwnProperty(a) && (e2[a] = s2[a]);
      }
      return e2;
    });
    var s = Object.assign({}, t2);
    return this.isObject(t2) && this.isObject(e) && Object.keys(e).forEach(function(a) {
      i.isObject(e[a]) && a in t2 ? s[a] = i.extend(t2[a], e[a]) : Object.assign(s, _defineProperty({}, a, e[a]));
    }), s;
  } }, { key: "extendArray", value: function(e, i) {
    var s = [];
    return e.map(function(e2) {
      s.push(t.extend(i, e2));
    }), e = s;
  } }, { key: "monthMod", value: function(t2) {
    return t2 % 12;
  } }, { key: "addProps", value: function(t2, e, i) {
    "string" == typeof e && (e = e.split(".")), t2[e[0]] = t2[e[0]] || {};
    var s = t2[e[0]];
    return e.length > 1 ? (e.shift(), this.addProps(s, e, i)) : t2[e[0]] = i, t2;
  } }, { key: "clone", value: function(t2) {
    if ("[object Array]" === Object.prototype.toString.call(t2)) {
      for (var e = [], i = 0; i < t2.length; i++) e[i] = this.clone(t2[i]);
      return e;
    }
    if ("object" === _typeof(t2)) {
      var s = {};
      for (var a in t2) t2.hasOwnProperty(a) && (s[a] = this.clone(t2[a]));
      return s;
    }
    return t2;
  } }, { key: "log10", value: function(t2) {
    return Math.log(t2) / Math.LN10;
  } }, { key: "roundToBase10", value: function(t2) {
    return Math.pow(10, Math.floor(Math.log10(t2)));
  } }, { key: "roundToBase", value: function(t2, e) {
    return Math.pow(e, Math.floor(Math.log(t2) / Math.log(e)));
  } }, { key: "parseNumber", value: function(t2) {
    return null === t2 ? t2 : parseFloat(t2);
  } }, { key: "noExponents", value: function(t2) {
    var e = String(t2).split(/[eE]/);
    if (1 == e.length) return e[0];
    var i = "", s = t2 < 0 ? "-" : "", a = e[0].replace(".", ""), r = Number(e[1]) + 1;
    if (r < 0) {
      for (i = s + "0."; r++; ) i += "0";
      return i + a.replace(/^\-/, "");
    }
    for (r -= a.length; r--; ) i += "0";
    return a + i;
  } }, { key: "getDimensions", value: function(t2) {
    var e = getComputedStyle(t2), i = [], s = t2.clientHeight, a = t2.clientWidth;
    return s -= parseFloat(e.paddingTop) + parseFloat(e.paddingBottom), a -= parseFloat(e.paddingLeft) + parseFloat(e.paddingRight), i.push(a), i.push(s), i;
  } }, { key: "getBoundingClientRect", value: function(t2) {
    var e = t2.getBoundingClientRect();
    return { top: e.top, right: e.right, bottom: e.bottom, left: e.left, width: e.width, height: e.height, x: e.x, y: e.y };
  } }, { key: "hexToRgba", value: function() {
    var t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "#999999", e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0.6;
    "#" !== t2.substring(0, 1) && (t2 = "#999999");
    var i = t2.replace("#", "");
    i = i.match(new RegExp("(.{" + i.length / 3 + "})", "g"));
    for (var s = 0; s < i.length; s++) i[s] = parseInt(1 === i[s].length ? i[s] + i[s] : i[s], 16);
    return void 0 !== e && i.push(e), "rgba(" + i.join(",") + ")";
  } }, { key: "getOpacityFromRGBA", value: function(t2) {
    return (t2 = t2.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i))[3];
  } }, { key: "rgb2hex", value: function(t2) {
    return (t2 = t2.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && 4 === t2.length ? "#" + ("0" + parseInt(t2[1], 10).toString(16)).slice(-2) + ("0" + parseInt(t2[2], 10).toString(16)).slice(-2) + ("0" + parseInt(t2[3], 10).toString(16)).slice(-2) : "";
  } }, { key: "isColorHex", value: function(t2) {
    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(t2);
  } }, { key: "polarToCartesian", value: function(t2, e, i, s) {
    var a = (s - 90) * Math.PI / 180;
    return { x: t2 + i * Math.cos(a), y: e + i * Math.sin(a) };
  } }, { key: "escapeString", value: function(t2) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "x", i = t2.toString().slice();
    return i = i.replace(/[` ~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, e);
  } }, { key: "negToZero", value: function(t2) {
    return t2 < 0 ? 0 : t2;
  } }, { key: "moveIndexInArray", value: function(t2, e, i) {
    if (i >= t2.length) for (var s = i - t2.length + 1; s--; ) t2.push(void 0);
    return t2.splice(i, 0, t2.splice(e, 1)[0]), t2;
  } }, { key: "extractNumber", value: function(t2) {
    return parseFloat(t2.replace(/[^\d\.]*/g, ""));
  } }, { key: "randomString", value: function(t2) {
    for (var e = "", i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", s = 0; s < t2; s++) e += i.charAt(Math.floor(Math.random() * i.length));
    return e;
  } }, { key: "findAncestor", value: function(t2, e) {
    for (; (t2 = t2.parentElement) && !t2.classList.contains(e); ) ;
    return t2;
  } }, { key: "setELstyles", value: function(t2, e) {
    for (var i in e) e.hasOwnProperty(i) && (t2.style.key = e[i]);
  } }, { key: "isNumber", value: function(t2) {
    return !isNaN(t2) && parseFloat(Number(t2)) === t2 && !isNaN(parseInt(t2, 10));
  } }, { key: "isFloat", value: function(t2) {
    return Number(t2) === t2 && t2 % 1 != 0;
  } }, { key: "isSafari", value: function() {
    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  } }, { key: "isFirefox", value: function() {
    return navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
  } }, { key: "isIE11", value: function() {
    if (-1 !== window.navigator.userAgent.indexOf("MSIE") || window.navigator.appVersion.indexOf("Trident/") > -1) return true;
  } }, { key: "isIE", value: function() {
    var t2 = window.navigator.userAgent, e = t2.indexOf("MSIE ");
    if (e > 0) return parseInt(t2.substring(e + 5, t2.indexOf(".", e)), 10);
    if (t2.indexOf("Trident/") > 0) {
      var i = t2.indexOf("rv:");
      return parseInt(t2.substring(i + 3, t2.indexOf(".", i)), 10);
    }
    var s = t2.indexOf("Edge/");
    return s > 0 && parseInt(t2.substring(s + 5, t2.indexOf(".", s)), 10);
  } }]), t;
})();
var Filters = (function() {
  function t(e) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w;
  }
  return _createClass(t, [{ key: "getDefaultFilter", value: function(t2, e) {
    var i = this.w;
    t2.unfilter(true), new window.SVG.Filter().size("120%", "180%", "-5%", "-40%"), "none" !== i.config.states.normal.filter ? this.applyFilter(t2, e, i.config.states.normal.filter.type, i.config.states.normal.filter.value) : i.config.chart.dropShadow.enabled && this.dropShadow(t2, i.config.chart.dropShadow, e);
  } }, { key: "addNormalFilter", value: function(t2, e) {
    var i = this.w;
    i.config.chart.dropShadow.enabled && this.dropShadow(t2, i.config.chart.dropShadow, e);
  } }, { key: "addLightenFilter", value: function(t2, e, i) {
    var s = this, a = this.w, r = i.intensity;
    if (!Utils.isFirefox()) {
      t2.unfilter(true);
      var n = new window.SVG.Filter();
      n.size("120%", "180%", "-5%", "-40%"), t2.filter(function(t3) {
        var i2 = a.config.chart.dropShadow;
        (n = i2.enabled ? s.addShadow(t3, e, i2) : t3).componentTransfer({ rgb: { type: "linear", slope: 1.5, intercept: r } });
      }), t2.filterer.node.setAttribute("filterUnits", "userSpaceOnUse");
    }
  } }, { key: "addDarkenFilter", value: function(t2, e, i) {
    var s = this, a = this.w, r = i.intensity;
    if (!Utils.isFirefox()) {
      t2.unfilter(true);
      var n = new window.SVG.Filter();
      n.size("120%", "180%", "-5%", "-40%"), t2.filter(function(t3) {
        var i2 = a.config.chart.dropShadow;
        (n = i2.enabled ? s.addShadow(t3, e, i2) : t3).componentTransfer({ rgb: { type: "linear", slope: r } });
      }), t2.filterer.node.setAttribute("filterUnits", "userSpaceOnUse");
    }
  } }, { key: "applyFilter", value: function(t2, e, i) {
    var s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0.5;
    switch (i) {
      case "none":
        this.addNormalFilter(t2, e);
        break;
      case "lighten":
        this.addLightenFilter(t2, e, { intensity: s });
        break;
      case "darken":
        this.addDarkenFilter(t2, e, { intensity: s });
    }
  } }, { key: "addShadow", value: function(t2, e, i) {
    var s = i.blur, a = i.top, r = i.left, n = i.color, o = i.opacity, l = t2.flood(Array.isArray(n) ? n[e] : n, o).composite(t2.sourceAlpha, "in").offset(r, a).gaussianBlur(s).merge(t2.source);
    return t2.blend(t2.source, l);
  } }, { key: "dropShadow", value: function(t2, e) {
    var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, s = e.top, a = e.left, r = e.blur, n = e.color, o = e.opacity, l = e.noUserSpaceOnUse, h = this.w;
    return t2.unfilter(true), Utils.isIE() && "radialBar" === h.config.chart.type ? t2 : (n = Array.isArray(n) ? n[i] : n, new window.SVG.Filter().size("120%", "180%", "-5%", "-40%"), t2.filter(function(t3) {
      var e2 = null;
      e2 = Utils.isSafari() || Utils.isFirefox() || Utils.isIE() ? t3.flood(n, o).composite(t3.sourceAlpha, "in").offset(a, s).gaussianBlur(r) : t3.flood(n, o).composite(t3.sourceAlpha, "in").offset(a, s).gaussianBlur(r).merge(t3.source), t3.blend(t3.source, e2);
    }), l || t2.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), t2);
  } }, { key: "setSelectionFilter", value: function(t2, e, i) {
    var s = this.w;
    if (void 0 !== s.globals.selectedDataPoints[e] && s.globals.selectedDataPoints[e].indexOf(i) > -1) {
      t2.node.setAttribute("selected", true);
      var a = s.config.states.active.filter;
      "none" !== a && this.applyFilter(t2, e, a.type, a.value);
    }
  } }]), t;
})();
var Animations = (function() {
  function t(e) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.setEasingFunctions();
  }
  return _createClass(t, [{ key: "setEasingFunctions", value: function() {
    var t2;
    if (!this.w.globals.easing) {
      switch (this.w.config.chart.animations.easing) {
        case "linear":
          t2 = "-";
          break;
        case "easein":
          t2 = "<";
          break;
        case "easeout":
          t2 = ">";
          break;
        case "easeinout":
          t2 = "<>";
          break;
        case "swing":
          t2 = function(t3) {
            var e = 1.70158;
            return (t3 -= 1) * t3 * ((e + 1) * t3 + e) + 1;
          };
          break;
        case "bounce":
          t2 = function(t3) {
            return t3 < 1 / 2.75 ? 7.5625 * t3 * t3 : t3 < 2 / 2.75 ? 7.5625 * (t3 -= 1.5 / 2.75) * t3 + 0.75 : t3 < 2.5 / 2.75 ? 7.5625 * (t3 -= 2.25 / 2.75) * t3 + 0.9375 : 7.5625 * (t3 -= 2.625 / 2.75) * t3 + 0.984375;
          };
          break;
        case "elastic":
          t2 = function(t3) {
            return t3 === !!t3 ? t3 : Math.pow(2, -10 * t3) * Math.sin((t3 - 0.075) * (2 * Math.PI) / 0.3) + 1;
          };
          break;
        default:
          t2 = "<>";
      }
      this.w.globals.easing = t2;
    }
  } }, { key: "animateLine", value: function(t2, e, i, s) {
    t2.attr(e).animate(s).attr(i);
  } }, { key: "animateCircleRadius", value: function(t2, e, i, s, a) {
    e || (e = 0), t2.attr({ r: e }).animate(s, a).attr({ r: i });
  } }, { key: "animateCircle", value: function(t2, e, i, s, a) {
    t2.attr({ r: e.r, cx: e.cx, cy: e.cy }).animate(s, a).attr({ r: i.r, cx: i.cx, cy: i.cy });
  } }, { key: "animateRect", value: function(t2, e, i, s, a) {
    t2.attr(e).animate(s).attr(i).afterAll(function() {
      a();
    });
  } }, { key: "animatePathsGradually", value: function(t2) {
    var e = t2.el, i = t2.j, s = t2.pathFrom, a = t2.pathTo, r = t2.speed, n = t2.delay, o = t2.strokeWidth, l = this.w, h = 0;
    l.config.chart.animations.animateGradually.enabled && (h = l.config.chart.animations.animateGradually.delay), l.config.chart.animations.dynamicAnimation.enabled && l.globals.dataChanged && (h = 0), this.morphSVG(e, i, s, a, r, o, n * h);
  } }, { key: "showDelayedElements", value: function() {
    this.w.globals.delayedElements.forEach(function(t2) {
      t2.el.classList.remove("hidden");
    });
  } }, { key: "animationCompleted", value: function() {
    var t2 = this.w;
    t2.globals.animationEnded = true, "function" == typeof t2.config.chart.events.animationEnd && t2.config.chart.events.animationEnd(this.ctx, t2);
  } }, { key: "morphSVG", value: function(t2, e, i, s, a, r, n) {
    var o = this, l = this.w;
    i || (i = t2.attr("pathFrom")), s || (s = t2.attr("pathTo")), (!i || i.indexOf("undefined") > -1 || i.indexOf("NaN") > -1) && (i = "M 0 ".concat(l.globals.gridHeight), a = 1), (s.indexOf("undefined") > -1 || s.indexOf("NaN") > -1) && (s = "M 0 ".concat(l.globals.gridHeight), a = 1), l.globals.shouldAnimate || (a = 1), t2.plot(i).animate(1, l.globals.easing, n).plot(i).animate(a, l.globals.easing, n).plot(s).afterAll(function() {
      Utils.isNumber(e) ? e === l.globals.series[l.globals.maxValsInArrayIndex].length - 2 && l.globals.shouldAnimate && o.animationCompleted() : l.globals.shouldAnimate && o.animationCompleted(), o.showDelayedElements();
    });
  } }]), t;
})();
var Graphics = (function() {
  function t(e) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w;
  }
  return _createClass(t, [{ key: "drawLine", value: function(t2, e, i, s) {
    var a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "#a8a8a8", r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, n = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null;
    return this.w.globals.dom.Paper.line().attr({ x1: t2, y1: e, x2: i, y2: s, stroke: a, "stroke-dasharray": r, "stroke-width": n });
  } }, { key: "drawRect", value: function() {
    var t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "#fefefe", n = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1, o = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null, l = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : null, h = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0, c = this.w.globals.dom.Paper.rect();
    return c.attr({ x: t2, y: e, width: i > 0 ? i : 0, height: s > 0 ? s : 0, rx: a, ry: a, fill: r, opacity: n, "stroke-width": null !== o ? o : 0, stroke: null !== l ? l : "none", "stroke-dasharray": h }), c;
  } }, { key: "drawPolygon", value: function(t2) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "#e1e1e1", i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "none";
    return this.w.globals.dom.Paper.polygon(t2).attr({ fill: i, stroke: e });
  } }, { key: "drawCircle", value: function(t2) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i = this.w.globals.dom.Paper.circle(2 * t2);
    return null !== e && i.attr(e), i;
  } }, { key: "drawPath", value: function(t2) {
    var e = t2.d, i = void 0 === e ? "" : e, s = t2.stroke, a = void 0 === s ? "#a8a8a8" : s, r = t2.strokeWidth, n = void 0 === r ? 1 : r, o = t2.fill, l = t2.fillOpacity, h = void 0 === l ? 1 : l, c = t2.strokeOpacity, d = void 0 === c ? 1 : c, u = t2.classes, g = t2.strokeLinecap, f = void 0 === g ? null : g, p = t2.strokeDashArray, x = void 0 === p ? 0 : p, m = this.w;
    return null === f && (f = m.config.stroke.lineCap), (i.indexOf("undefined") > -1 || i.indexOf("NaN") > -1) && (i = "M 0 ".concat(m.globals.gridHeight)), m.globals.dom.Paper.path(i).attr({ fill: o, "fill-opacity": h, stroke: a, "stroke-opacity": d, "stroke-linecap": f, "stroke-width": n, "stroke-dasharray": x, class: u });
  } }, { key: "group", value: function() {
    var t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, e = this.w.globals.dom.Paper.group();
    return null !== t2 && e.attr(t2), e;
  } }, { key: "move", value: function(t2, e) {
    var i = ["M", t2, e].join(" ");
    return i;
  } }, { key: "line", value: function(t2, e) {
    var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s = null;
    return null === i ? s = ["L", t2, e].join(" ") : "H" === i ? s = ["H", t2].join(" ") : "V" === i && (s = ["V", e].join(" ")), s;
  } }, { key: "curve", value: function(t2, e, i, s, a, r) {
    var n = ["C", t2, e, i, s, a, r].join(" ");
    return n;
  } }, { key: "quadraticCurve", value: function(t2, e, i, s) {
    return ["Q", t2, e, i, s].join(" ");
  } }, { key: "arc", value: function(t2, e, i, s, a, r, n) {
    var o = "A";
    arguments.length > 7 && void 0 !== arguments[7] && arguments[7] && (o = "a");
    var l = [o, t2, e, i, s, a, r, n].join(" ");
    return l;
  } }, { key: "renderPaths", value: function(t2) {
    var e, i = t2.j, s = t2.realIndex, a = t2.pathFrom, r = t2.pathTo, n = t2.stroke, o = t2.strokeWidth, l = t2.strokeLinecap, h = t2.fill, c = t2.animationDelay, d = t2.initialSpeed, u = t2.dataChangeSpeed, g = t2.className, f = t2.shouldClipToGrid, p = void 0 === f || f, x = t2.bindEventsOnPaths, m = void 0 === x || x, b = t2.drawShadow, v = void 0 === b || b, y = this.w, w = new Filters(this.ctx), k = new Animations(this.ctx), A = this.w.config.chart.animations.enabled, S = A && this.w.config.chart.animations.dynamicAnimation.enabled, C = !!(A && !y.globals.resized || S && y.globals.dataChanged && y.globals.shouldAnimate);
    C ? e = a : (e = r, k.animationCompleted());
    var L = y.config.stroke.dashArray, P = 0;
    P = Array.isArray(L) ? L[s] : y.config.stroke.dashArray;
    var z = this.drawPath({ d: e, stroke: n, strokeWidth: o, fill: h, fillOpacity: 1, classes: g, strokeLinecap: l, strokeDashArray: P });
    if (z.attr("index", s), p && z.attr({ "clip-path": "url(#gridRectMask".concat(y.globals.cuid, ")") }), "none" !== y.config.states.normal.filter.type) w.getDefaultFilter(z, s);
    else if (y.config.chart.dropShadow.enabled && v && (!y.config.chart.dropShadow.enabledSeries || y.config.chart.dropShadow.enabledSeries && -1 !== y.config.chart.dropShadow.enabledSeries.indexOf(s))) {
      var T = y.config.chart.dropShadow;
      w.dropShadow(z, T, s);
    }
    m && (z.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, z)), z.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, z)), z.node.addEventListener("mousedown", this.pathMouseDown.bind(this, z))), z.attr({ pathTo: r, pathFrom: a });
    var M = { el: z, j: i, pathFrom: a, pathTo: r, strokeWidth: o };
    return !A || y.globals.resized || y.globals.dataChanged ? !y.globals.resized && y.globals.dataChanged || k.showDelayedElements() : k.animatePathsGradually(_objectSpread({}, M, { speed: d, delay: c })), y.globals.dataChanged && S && C && k.animatePathsGradually(_objectSpread({}, M, { speed: u })), z;
  } }, { key: "drawPattern", value: function(t2, e, i) {
    var s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "#a8a8a8", a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
    return this.w.globals.dom.Paper.pattern(e, i, function(r) {
      "horizontalLines" === t2 ? r.line(0, 0, i, 0).stroke({ color: s, width: a + 1 }) : "verticalLines" === t2 ? r.line(0, 0, 0, e).stroke({ color: s, width: a + 1 }) : "slantedLines" === t2 ? r.line(0, 0, e, i).stroke({ color: s, width: a }) : "squares" === t2 ? r.rect(e, i).fill("none").stroke({ color: s, width: a }) : "circles" === t2 && r.circle(e).fill("none").stroke({ color: s, width: a });
    });
  } }, { key: "drawGradient", value: function(t2, e, i, s, a) {
    var r, n = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, l = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null, h = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0, c = this.w;
    e = Utils.hexToRgba(e, s), i = Utils.hexToRgba(i, a);
    var d = 0, u = 1, g = 1, f = null;
    null !== o && (d = void 0 !== o[0] ? o[0] / 100 : 0, u = void 0 !== o[1] ? o[1] / 100 : 1, g = void 0 !== o[2] ? o[2] / 100 : 1, f = void 0 !== o[3] ? o[3] / 100 : null);
    var p = !("donut" !== c.config.chart.type && "pie" !== c.config.chart.type && "bubble" !== c.config.chart.type);
    if (r = null === l || 0 === l.length ? c.globals.dom.Paper.gradient(p ? "radial" : "linear", function(t3) {
      t3.at(d, e, s), t3.at(u, i, a), t3.at(g, i, a), null !== f && t3.at(f, e, s);
    }) : c.globals.dom.Paper.gradient(p ? "radial" : "linear", function(t3) {
      (Array.isArray(l[h]) ? l[h] : l).forEach(function(e2) {
        t3.at(e2.offset / 100, e2.color, e2.opacity);
      });
    }), p) {
      var x = c.globals.gridWidth / 2, m = c.globals.gridHeight / 2;
      "bubble" !== c.config.chart.type ? r.attr({ gradientUnits: "userSpaceOnUse", cx: x, cy: m, r: n }) : r.attr({ cx: 0.5, cy: 0.5, r: 0.8, fx: 0.2, fy: 0.2 });
    } else "vertical" === t2 ? r.from(0, 0).to(0, 1) : "diagonal" === t2 ? r.from(0, 0).to(1, 1) : "horizontal" === t2 ? r.from(0, 1).to(1, 1) : "diagonal2" === t2 && r.from(0, 1).to(2, 2);
    return r;
  } }, { key: "drawText", value: function(t2) {
    var e, i = this.w, s = t2.x, a = t2.y, r = t2.text, n = t2.textAnchor, o = t2.fontSize, l = t2.fontFamily, h = t2.fontWeight, c = t2.foreColor, d = t2.opacity;
    return void 0 === r && (r = ""), n || (n = "start"), c || (c = i.config.chart.foreColor), l = l || i.config.chart.fontFamily, h = h || "regular", (e = Array.isArray(r) ? i.globals.dom.Paper.text(function(t3) {
      for (var e2 = 0; e2 < r.length; e2++) t3.tspan(r[e2]);
    }) : i.globals.dom.Paper.plain(r)).attr({ x: s, y: a, "text-anchor": n, "dominant-baseline": "auto", "font-size": o, "font-family": l, "font-weight": h, fill: c, class: (t2.cssClass, t2.cssClass) }), e.node.style.fontFamily = l, e.node.style.opacity = d, e;
  } }, { key: "addTspan", value: function(t2, e, i) {
    var s = t2.tspan(e);
    i || (i = this.w.config.chart.fontFamily), s.node.style.fontFamily = i;
  } }, { key: "drawMarker", value: function(t2, e, i) {
    t2 = t2 || 0;
    var s = i.pSize || 0, a = null;
    if ("square" === i.shape) {
      var r = void 0 === i.pRadius ? s / 2 : i.pRadius;
      null === e && (s = 0, r = 0);
      var n = 1.2 * s + r, o = this.drawRect(n, n, n, n, r);
      o.attr({ x: t2 - n / 2, y: e - n / 2, cx: t2, cy: e, class: i.class ? i.class : "", fill: i.pointFillColor, "fill-opacity": i.pointFillOpacity ? i.pointFillOpacity : 1, stroke: i.pointStrokeColor, "stroke-width": i.pWidth ? i.pWidth : 0, "stroke-opacity": i.pointStrokeOpacity ? i.pointStrokeOpacity : 1 }), a = o;
    } else "circle" === i.shape && (Utils.isNumber(e) || (s = 0, e = 0), a = this.drawCircle(s, { cx: t2, cy: e, class: i.class ? i.class : "", stroke: i.pointStrokeColor, fill: i.pointFillColor, "fill-opacity": i.pointFillOpacity ? i.pointFillOpacity : 1, "stroke-width": i.pWidth ? i.pWidth : 0, "stroke-opacity": i.pointStrokeOpacity ? i.pointStrokeOpacity : 1 }));
    return a;
  } }, { key: "pathMouseEnter", value: function(t2, e) {
    var i = this.w, s = new Filters(this.ctx), a = parseInt(t2.node.getAttribute("index")), r = parseInt(t2.node.getAttribute("j"));
    if ("function" == typeof i.config.chart.events.dataPointMouseEnter && i.config.chart.events.dataPointMouseEnter(e, this.ctx, { seriesIndex: a, dataPointIndex: r, w: i }), this.ctx.fireEvent("dataPointMouseEnter", [e, this.ctx, { seriesIndex: a, dataPointIndex: r, w: i }]), ("none" === i.config.states.active.filter.type || "true" !== t2.node.getAttribute("selected")) && "none" !== i.config.states.hover.filter.type && "none" !== i.config.states.active.filter.type && !i.globals.isTouchDevice) {
      var n = i.config.states.hover.filter;
      s.applyFilter(t2, a, n.type, n.value);
    }
  } }, { key: "pathMouseLeave", value: function(t2, e) {
    var i = this.w, s = new Filters(this.ctx), a = parseInt(t2.node.getAttribute("index")), r = parseInt(t2.node.getAttribute("j"));
    "function" == typeof i.config.chart.events.dataPointMouseLeave && i.config.chart.events.dataPointMouseLeave(e, this.ctx, { seriesIndex: a, dataPointIndex: r, w: i }), this.ctx.fireEvent("dataPointMouseLeave", [e, this.ctx, { seriesIndex: a, dataPointIndex: r, w: i }]), "none" !== i.config.states.active.filter.type && "true" === t2.node.getAttribute("selected") || "none" !== i.config.states.hover.filter.type && s.getDefaultFilter(t2, a);
  } }, { key: "pathMouseDown", value: function(t2, e) {
    var i = this.w, s = new Filters(this.ctx), a = parseInt(t2.node.getAttribute("index")), r = parseInt(t2.node.getAttribute("j")), n = "false";
    if ("true" === t2.node.getAttribute("selected")) {
      if (t2.node.setAttribute("selected", "false"), i.globals.selectedDataPoints[a].indexOf(r) > -1) {
        var o = i.globals.selectedDataPoints[a].indexOf(r);
        i.globals.selectedDataPoints[a].splice(o, 1);
      }
    } else {
      if (!i.config.states.active.allowMultipleDataPointsSelection && i.globals.selectedDataPoints.length > 0) {
        i.globals.selectedDataPoints = [];
        var l = i.globals.dom.Paper.select(".apexcharts-series path").members, h = i.globals.dom.Paper.select(".apexcharts-series circle, .apexcharts-series rect").members;
        l.forEach(function(t3) {
          t3.node.setAttribute("selected", "false"), s.getDefaultFilter(t3, a);
        }), h.forEach(function(t3) {
          t3.node.setAttribute("selected", "false"), s.getDefaultFilter(t3, a);
        });
      }
      t2.node.setAttribute("selected", "true"), n = "true", void 0 === i.globals.selectedDataPoints[a] && (i.globals.selectedDataPoints[a] = []), i.globals.selectedDataPoints[a].push(r);
    }
    if ("true" === n) {
      var c = i.config.states.active.filter;
      "none" !== c && s.applyFilter(t2, a, c.type, c.value);
    } else "none" !== i.config.states.active.filter.type && s.getDefaultFilter(t2, a);
    "function" == typeof i.config.chart.events.dataPointSelection && i.config.chart.events.dataPointSelection(e, this.ctx, { selectedDataPoints: i.globals.selectedDataPoints, seriesIndex: a, dataPointIndex: r, w: i }), e && this.ctx.fireEvent("dataPointSelection", [e, this.ctx, { selectedDataPoints: i.globals.selectedDataPoints, seriesIndex: a, dataPointIndex: r, w: i }]);
  } }, { key: "rotateAroundCenter", value: function(t2) {
    var e = t2.getBBox();
    return { x: e.x + e.width / 2, y: e.y + e.height / 2 };
  } }, { key: "getTextRects", value: function(t2, e, i, s) {
    var a = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], r = this.w, n = this.drawText({ x: -200, y: -200, text: t2, textAnchor: "start", fontSize: e, fontFamily: i, foreColor: "#fff", opacity: 0 });
    s && n.attr("transform", s), r.globals.dom.Paper.add(n);
    var o = n.bbox();
    return a || (o = n.node.getBoundingClientRect()), n.remove(), { width: o.width, height: o.height };
  } }, { key: "placeTextWithEllipsis", value: function(t2, e, i) {
    if (t2.textContent = e, e.length > 0 && t2.getComputedTextLength() >= i) {
      for (var s = e.length - 3; s > 0; s -= 3) if (t2.getSubStringLength(0, s) <= i) return void (t2.textContent = e.substring(0, s) + "...");
      t2.textContent = "...";
    }
  } }], [{ key: "setAttrs", value: function(t2, e) {
    for (var i in e) e.hasOwnProperty(i) && t2.setAttribute(i, e[i]);
  } }]), t;
})();
var options = { months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], toolbar: { exportToSVG: "Download SVG", exportToPNG: "Download PNG", menu: "Menu", selection: "Selection", selectionZoom: "Selection Zoom", zoomIn: "Zoom In", zoomOut: "Zoom Out", pan: "Panning", reset: "Reset Zoom" } };
var en = { name: "en", options };
var Options = (function() {
  function t() {
    _classCallCheck(this, t), this.yAxis = { show: true, showAlways: false, seriesName: void 0, opposite: false, reversed: false, logarithmic: false, tickAmount: void 0, forceNiceScale: false, max: void 0, min: void 0, floating: false, decimalsInFloat: void 0, labels: { show: true, minWidth: 0, maxWidth: 160, offsetX: 0, offsetY: 0, align: void 0, rotate: 0, padding: 20, style: { colors: [], fontSize: "11px", fontFamily: void 0, cssClass: "" }, formatter: void 0 }, axisBorder: { show: false, color: "#78909C", offsetX: 0, offsetY: 0 }, axisTicks: { show: false, color: "#78909C", width: 6, offsetX: 0, offsetY: 0 }, title: { text: void 0, rotate: 90, offsetY: 0, offsetX: 0, style: { color: void 0, fontSize: "11px", fontFamily: void 0, cssClass: "" } }, tooltip: { enabled: false, offsetX: 0 }, crosshairs: { show: true, position: "front", stroke: { color: "#b6b6b6", width: 1, dashArray: 0 } } }, this.xAxisAnnotation = { x: 0, x2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", opacity: 0.3, offsetX: 0, offsetY: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, text: void 0, textAnchor: "middle", orientation: "vertical", position: "top", offsetX: 0, offsetY: 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.yAxisAnnotation = { y: 0, y2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", opacity: 0.3, offsetX: 0, offsetY: 0, yAxisIndex: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, text: void 0, textAnchor: "end", position: "right", offsetX: 0, offsetY: -3, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, cssClass: "", padding: { left: 5, right: 5, top: 0, bottom: 2 } } } }, this.pointAnnotation = { x: 0, y: null, yAxisIndex: 0, seriesIndex: 0, marker: { size: 4, fillColor: "#fff", strokeWidth: 2, strokeColor: "#333", shape: "circle", offsetX: 0, offsetY: 0, radius: 2, cssClass: "" }, label: { borderColor: "#c2c2c2", borderWidth: 1, text: void 0, textAnchor: "middle", offsetX: 0, offsetY: -15, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, cssClass: "", padding: { left: 5, right: 5, top: 0, bottom: 2 } } }, customSVG: { SVG: void 0, cssClass: void 0, offsetX: 0, offsetY: 0 } };
  }
  return _createClass(t, [{ key: "init", value: function() {
    return { annotations: { position: "front", yaxis: [this.yAxisAnnotation], xaxis: [this.xAxisAnnotation], points: [this.pointAnnotation] }, chart: { animations: { enabled: true, easing: "easeinout", speed: 800, animateGradually: { delay: 150, enabled: true }, dynamicAnimation: { enabled: true, speed: 350 } }, background: "transparent", locales: [en], defaultLocale: "en", dropShadow: { enabled: false, enabledSeries: void 0, top: 2, left: 2, blur: 4, color: "#000", opacity: 0.35 }, events: { animationEnd: void 0, beforeMount: void 0, mounted: void 0, updated: void 0, click: void 0, mouseMove: void 0, legendClick: void 0, markerClick: void 0, selection: void 0, dataPointSelection: void 0, dataPointMouseEnter: void 0, dataPointMouseLeave: void 0, beforeZoom: void 0, zoomed: void 0, scrolled: void 0 }, foreColor: "#373d3f", fontFamily: "Helvetica, Arial, sans-serif", height: "auto", parentHeightOffset: 15, id: void 0, group: void 0, offsetX: 0, offsetY: 0, selection: { enabled: false, type: "x", fill: { color: "#24292e", opacity: 0.1 }, stroke: { width: 1, color: "#24292e", opacity: 0.4, dashArray: 3 }, xaxis: { min: void 0, max: void 0 }, yaxis: { min: void 0, max: void 0 } }, sparkline: { enabled: false }, brush: { enabled: false, autoScaleYaxis: true, target: void 0 }, stacked: false, stackType: "normal", toolbar: { show: true, tools: { download: true, selection: true, zoom: true, zoomin: true, zoomout: true, pan: true, reset: true, customIcons: [] }, autoSelected: "zoom" }, type: "line", width: "100%", zoom: { enabled: true, type: "x", autoScaleYaxis: false, zoomedArea: { fill: { color: "#90CAF9", opacity: 0.4 }, stroke: { color: "#0D47A1", opacity: 0.4, width: 1 } } } }, plotOptions: { bar: { horizontal: false, columnWidth: "70%", barHeight: "70%", distributed: false, endingShape: "flat", colors: { ranges: [], backgroundBarColors: [], backgroundBarOpacity: 1 }, dataLabels: { maxItems: 100, hideOverflowingLabels: true, position: "top" } }, candlestick: { colors: { upward: "#00B746", downward: "#EF403C" }, wick: { useFillColor: true } }, heatmap: { radius: 2, enableShades: true, shadeIntensity: 0.5, reverseNegativeShade: true, distributed: false, colorScale: { inverse: false, ranges: [], min: void 0, max: void 0 } }, radialBar: { size: void 0, inverseOrder: false, startAngle: 0, endAngle: 360, offsetX: 0, offsetY: 0, hollow: { margin: 5, size: "50%", background: "transparent", image: void 0, imageWidth: 150, imageHeight: 150, imageOffsetX: 0, imageOffsetY: 0, imageClipped: true, position: "front", dropShadow: { enabled: false, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, track: { show: true, startAngle: void 0, endAngle: void 0, background: "#f2f2f2", strokeWidth: "97%", opacity: 1, margin: 5, dropShadow: { enabled: false, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, dataLabels: { show: true, name: { show: true, fontSize: "16px", fontFamily: void 0, color: void 0, offsetY: 0 }, value: { show: true, fontSize: "14px", fontFamily: void 0, color: void 0, offsetY: 16, formatter: function(t2) {
      return t2 + "%";
    } }, total: { show: false, label: "Total", color: void 0, formatter: function(t2) {
      return t2.globals.seriesTotals.reduce(function(t3, e) {
        return t3 + e;
      }, 0) / t2.globals.series.length + "%";
    } } } }, rangeBar: {}, pie: { size: void 0, customScale: 1, offsetX: 0, offsetY: 0, expandOnClick: true, dataLabels: { offset: 0, minAngleToShowLabel: 10 }, donut: { size: "65%", background: "transparent", labels: { show: false, name: { show: true, fontSize: "16px", fontFamily: void 0, color: void 0, offsetY: -10 }, value: { show: true, fontSize: "20px", fontFamily: void 0, color: void 0, offsetY: 10, formatter: function(t2) {
      return t2;
    } }, total: { show: false, label: "Total", color: void 0, formatter: function(t2) {
      return t2.globals.seriesTotals.reduce(function(t3, e) {
        return t3 + e;
      }, 0);
    } } } } }, radar: { size: void 0, offsetX: 0, offsetY: 0, polygons: { strokeColors: "#e8e8e8", connectorColors: "#e8e8e8", fill: { colors: void 0 } } } }, colors: void 0, dataLabels: { enabled: true, enabledOnSeries: void 0, formatter: function(t2) {
      return null !== t2 ? t2 : "";
    }, textAnchor: "middle", offsetX: 0, offsetY: 0, style: { fontSize: "12px", fontFamily: void 0, colors: void 0 }, dropShadow: { enabled: false, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.45 } }, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: true, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] }, image: { src: [], width: void 0, height: void 0 }, pattern: { style: "sqaures", width: 6, height: 6, strokeWidth: 2 } }, grid: { show: true, borderColor: "#e0e0e0", strokeDashArray: 0, position: "back", xaxis: { lines: { show: false, animate: false } }, yaxis: { lines: { show: true, animate: false } }, row: { colors: void 0, opacity: 0.5 }, column: { colors: void 0, opacity: 0.5 }, padding: { top: 0, right: 10, bottom: 0, left: 12 } }, labels: [], legend: { show: true, showForSingleSeries: false, showForNullSeries: true, showForZeroSeries: true, floating: false, position: "bottom", horizontalAlign: "center", inverseOrder: false, fontSize: "12px", fontFamily: void 0, width: void 0, height: void 0, formatter: void 0, tooltipHoverFormatter: void 0, offsetX: -20, offsetY: 0, labels: { colors: void 0, useSeriesColors: false }, markers: { width: 12, height: 12, strokeWidth: 0, strokeColor: "#fff", radius: 12, customHTML: void 0, offsetX: 0, offsetY: 0, onClick: void 0 }, itemMargin: { horizontal: 0, vertical: 5 }, onItemClick: { toggleDataSeries: true }, onItemHover: { highlightDataSeries: true } }, markers: { discrete: [], size: 0, colors: void 0, strokeColors: "#fff", strokeWidth: 2, strokeOpacity: 0.9, fillOpacity: 1, shape: "circle", radius: 2, offsetX: 0, offsetY: 0, onClick: void 0, onDblClick: void 0, hover: { size: void 0, sizeOffset: 3 } }, noData: { text: void 0, align: "center", verticalAlign: "middle", offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "14px", fontFamily: void 0 } }, responsive: [], series: void 0, states: { normal: { filter: { type: "none", value: 0 } }, hover: { filter: { type: "lighten", value: 0.15 } }, active: { allowMultipleDataPointsSelection: false, filter: { type: "darken", value: 0.65 } } }, title: { text: void 0, align: "left", margin: 10, offsetX: 0, offsetY: 0, floating: false, style: { fontSize: "14px", fontFamily: void 0, color: void 0 } }, subtitle: { text: void 0, align: "left", margin: 10, offsetX: 0, offsetY: 30, floating: false, style: { fontSize: "12px", fontFamily: void 0, color: void 0 } }, stroke: { show: true, curve: "smooth", lineCap: "butt", width: 2, colors: void 0, dashArray: 0 }, tooltip: { enabled: true, enabledOnSeries: void 0, shared: true, followCursor: false, intersect: false, inverseOrder: false, custom: void 0, fillSeriesColor: false, theme: "light", style: { fontSize: "12px", fontFamily: void 0 }, onDatasetHover: { highlightDataSeries: false }, x: { show: true, format: "dd MMM", formatter: void 0 }, y: { formatter: void 0, title: { formatter: function(t2) {
      return t2;
    } } }, z: { formatter: void 0, title: "Size: " }, marker: { show: true }, items: { display: "flex" }, fixed: { enabled: false, position: "topRight", offsetX: 0, offsetY: 0 } }, xaxis: { type: "category", categories: [], offsetX: 0, offsetY: 0, labels: { show: true, rotate: -45, rotateAlways: false, hideOverlappingLabels: true, trim: true, minHeight: void 0, maxHeight: 120, showDuplicates: true, style: { colors: [], fontSize: "12px", fontFamily: void 0, cssClass: "" }, offsetX: 0, offsetY: 0, format: void 0, formatter: void 0, datetimeFormatter: { year: "yyyy", month: "MMM 'yy", day: "dd MMM", hour: "HH:mm", minute: "HH:mm:ss" } }, axisBorder: { show: true, color: "#78909C", width: "100%", height: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: true, color: "#78909C", height: 6, offsetX: 0, offsetY: 0 }, tickAmount: void 0, tickPlacement: "on", min: void 0, max: void 0, range: void 0, floating: false, position: "bottom", title: { text: void 0, offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "12px", fontFamily: void 0, cssClass: "" } }, crosshairs: { show: true, width: 1, position: "back", opacity: 0.9, stroke: { color: "#b6b6b6", width: 1, dashArray: 3 }, fill: { type: "solid", color: "#B1B9C4", gradient: { colorFrom: "#D8E3F0", colorTo: "#BED1E6", stops: [0, 100], opacityFrom: 0.4, opacityTo: 0.5 } }, dropShadow: { enabled: false, left: 0, top: 0, blur: 1, opacity: 0.4 } }, tooltip: { enabled: true, offsetY: 0, formatter: void 0, style: { fontSize: "12px", fontFamily: void 0 } } }, yaxis: this.yAxis, theme: { mode: "light", palette: "palette1", monochrome: { enabled: false, color: "#008FFB", shadeTo: "light", shadeIntensity: 0.65 } } };
  } }]), t;
})();
var Annotations = (function() {
  function t(e) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.graphics = new Graphics(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = true), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints;
  }
  return _createClass(t, [{ key: "drawAnnotations", value: function() {
    var t2 = this.w;
    if (t2.globals.axisCharts) {
      for (var e = this.drawYAxisAnnotations(), i = this.drawXAxisAnnotations(), s = this.drawPointAnnotations(), a = t2.config.chart.animations.enabled, r = [e, i, s], n = [i.node, e.node, s.node], o = 0; o < 3; o++) t2.globals.dom.elGraphical.add(r[o]), !a || t2.globals.resized || t2.globals.dataChanged || "scatter" !== t2.config.chart.type && "bubble" !== t2.config.chart.type && n[o].classList.add("hidden"), t2.globals.delayedElements.push({ el: n[o], index: 0 });
      this.annotationsBackground();
    }
  } }, { key: "getStringX", value: function(t2) {
    var e = this.w, i = t2, s = e.globals.labels.indexOf(t2), a = e.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(" + (s + 1) + ")");
    return a && (i = parseFloat(a.getAttribute("x"))), i;
  } }, { key: "addXaxisAnnotation", value: function(t2, e, i) {
    var s = this.w, a = this.invertAxis ? s.globals.minY : s.globals.minX, r = this.invertAxis ? s.globals.yRange[0] : s.globals.xRange, n = (t2.x - a) / (r / s.globals.gridWidth), o = t2.label.text;
    "category" !== s.config.xaxis.type && !s.config.xaxis.convertedCatToNumeric || this.invertAxis || s.globals.isXNumeric || (n = this.getStringX(t2.x));
    var l = t2.strokeDashArray;
    if (!(n < 0 || n > s.globals.gridWidth)) {
      if (null === t2.x2) {
        var h = this.graphics.drawLine(n + t2.offsetX, 0 + t2.offsetY, n + t2.offsetX, s.globals.gridHeight + t2.offsetY, t2.borderColor, l);
        e.appendChild(h.node);
      } else {
        var c = (t2.x2 - a) / (r / s.globals.gridWidth);
        if ("category" !== s.config.xaxis.type && !s.config.xaxis.convertedCatToNumeric || this.invertAxis || s.globals.isXNumeric || (c = this.getStringX(t2.x2)), c < n) {
          var d = n;
          n = c, c = d;
        }
        if (o) {
          var u = this.graphics.drawRect(n + t2.offsetX, 0 + t2.offsetY, c - n, s.globals.gridHeight + t2.offsetY, 0, t2.fillColor, t2.opacity, 1, t2.borderColor, l);
          e.appendChild(u.node);
        }
      }
      var g = "top" === t2.label.position ? -3 : s.globals.gridHeight, f = this.graphics.drawText({ x: n + t2.label.offsetX, y: g + t2.label.offsetY, text: o, textAnchor: t2.label.textAnchor, fontSize: t2.label.style.fontSize, fontFamily: t2.label.style.fontFamily, foreColor: t2.label.style.color, cssClass: "apexcharts-xaxis-annotation-label " + t2.label.style.cssClass });
      f.attr({ rel: i }), e.appendChild(f.node), this.setOrientations(t2, i);
    }
  } }, { key: "drawXAxisAnnotations", value: function() {
    var t2 = this, e = this.w, i = this.graphics.group({ class: "apexcharts-xaxis-annotations" });
    return e.config.annotations.xaxis.map(function(e2, s) {
      t2.addXaxisAnnotation(e2, i.node, s);
    }), i;
  } }, { key: "addYaxisAnnotation", value: function(t2, e, i) {
    var s, a, r = this.w, n = t2.strokeDashArray;
    if (this.invertAxis) {
      var o = r.globals.labels.indexOf(t2.y), l = r.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(" + (o + 1) + ")");
      l && (s = parseFloat(l.getAttribute("y")));
    } else s = r.globals.gridHeight - (t2.y - r.globals.minYArr[t2.yAxisIndex]) / (r.globals.yRange[t2.yAxisIndex] / r.globals.gridHeight), r.config.yaxis[t2.yAxisIndex] && r.config.yaxis[t2.yAxisIndex].reversed && (s = (t2.y - r.globals.minYArr[t2.yAxisIndex]) / (r.globals.yRange[t2.yAxisIndex] / r.globals.gridHeight));
    var h = t2.label.text;
    if (null === t2.y2) {
      var c = this.graphics.drawLine(0 + t2.offsetX, s + t2.offsetY, r.globals.gridWidth + t2.offsetX, s + t2.offsetY, t2.borderColor, n);
      e.appendChild(c.node);
    } else {
      if (this.invertAxis) {
        var d = r.globals.labels.indexOf(t2.y2), u = r.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(" + (d + 1) + ")");
        u && (a = parseFloat(u.getAttribute("y")));
      } else a = r.globals.gridHeight - (t2.y2 - r.globals.minYArr[t2.yAxisIndex]) / (r.globals.yRange[t2.yAxisIndex] / r.globals.gridHeight), r.config.yaxis[t2.yAxisIndex] && r.config.yaxis[t2.yAxisIndex].reversed && (a = (t2.y2 - r.globals.minYArr[t2.yAxisIndex]) / (r.globals.yRange[t2.yAxisIndex] / r.globals.gridHeight));
      if (a > s) {
        var g = s;
        s = a, a = g;
      }
      if (h) {
        var f = this.graphics.drawRect(0 + t2.offsetX, a + t2.offsetY, r.globals.gridWidth + t2.offsetX, s - a, 0, t2.fillColor, t2.opacity, 1, t2.borderColor, n);
        e.appendChild(f.node);
      }
    }
    var p = "right" === t2.label.position ? r.globals.gridWidth : 0, x = this.graphics.drawText({ x: p + t2.label.offsetX, y: (a || s) + t2.label.offsetY - 3, text: h, textAnchor: t2.label.textAnchor, fontSize: t2.label.style.fontSize, fontFamily: t2.label.style.fontFamily, foreColor: t2.label.style.color, cssClass: "apexcharts-yaxis-annotation-label " + t2.label.style.cssClass });
    x.attr({ rel: i }), e.appendChild(x.node);
  } }, { key: "drawYAxisAnnotations", value: function() {
    var t2 = this, e = this.w, i = this.graphics.group({ class: "apexcharts-yaxis-annotations" });
    return e.config.annotations.yaxis.map(function(e2, s) {
      t2.addYaxisAnnotation(e2, i.node, s);
    }), i;
  } }, { key: "clearAnnotations", value: function(t2) {
    var e = t2.w.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations");
    (e = Utils.listToArray(e)).forEach(function(t3) {
      for (; t3.firstChild; ) t3.removeChild(t3.firstChild);
    });
  } }, { key: "addPointAnnotation", value: function(t2, e, i) {
    var s = this.w, a = 0, r = 0, n = 0;
    if (this.invertAxis && console.warn("Point annotation is not supported in horizontal bar charts."), "string" == typeof t2.x) {
      var o = s.globals.labels.indexOf(t2.x), l = s.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(" + (o + 1) + ")");
      a = parseFloat(l.getAttribute("x"));
      var h = t2.y;
      null === t2.y && (h = s.globals.series[t2.seriesIndex][o]), r = s.globals.gridHeight - (h - s.globals.minYArr[t2.yAxisIndex]) / (s.globals.yRange[t2.yAxisIndex] / s.globals.gridHeight) - parseInt(t2.label.style.fontSize) - t2.marker.size, n = s.globals.gridHeight - (h - s.globals.minYArr[t2.yAxisIndex]) / (s.globals.yRange[t2.yAxisIndex] / s.globals.gridHeight), s.config.yaxis[t2.yAxisIndex] && s.config.yaxis[t2.yAxisIndex].reversed && (r = (h - s.globals.minYArr[t2.yAxisIndex]) / (s.globals.yRange[t2.yAxisIndex] / s.globals.gridHeight) + parseInt(t2.label.style.fontSize) + t2.marker.size, n = (h - s.globals.minYArr[t2.yAxisIndex]) / (s.globals.yRange[t2.yAxisIndex] / s.globals.gridHeight));
    } else a = (t2.x - s.globals.minX) / (s.globals.xRange / s.globals.gridWidth), r = s.globals.gridHeight - (parseFloat(t2.y) - s.globals.minYArr[t2.yAxisIndex]) / (s.globals.yRange[t2.yAxisIndex] / s.globals.gridHeight) - parseInt(t2.label.style.fontSize) - t2.marker.size, n = s.globals.gridHeight - (t2.y - s.globals.minYArr[t2.yAxisIndex]) / (s.globals.yRange[t2.yAxisIndex] / s.globals.gridHeight), s.config.yaxis[t2.yAxisIndex] && s.config.yaxis[t2.yAxisIndex].reversed && (r = (parseFloat(t2.y) - s.globals.minYArr[t2.yAxisIndex]) / (s.globals.yRange[t2.yAxisIndex] / s.globals.gridHeight) - parseInt(t2.label.style.fontSize) - t2.marker.size, n = (t2.y - s.globals.minYArr[t2.yAxisIndex]) / (s.globals.yRange[t2.yAxisIndex] / s.globals.gridHeight));
    if (!(a < 0 || a > s.globals.gridWidth)) {
      var c = { pSize: t2.marker.size, pWidth: t2.marker.strokeWidth, pointFillColor: t2.marker.fillColor, pointStrokeColor: t2.marker.strokeColor, shape: t2.marker.shape, radius: t2.marker.radius, class: "apexcharts-point-annotation-marker " + t2.marker.cssClass }, d = this.graphics.drawMarker(a + t2.marker.offsetX, n + t2.marker.offsetY, c);
      e.appendChild(d.node);
      var u = t2.label.text ? t2.label.text : "", g = this.graphics.drawText({ x: a + t2.label.offsetX, y: r + t2.label.offsetY, text: u, textAnchor: t2.label.textAnchor, fontSize: t2.label.style.fontSize, fontFamily: t2.label.style.fontFamily, foreColor: t2.label.style.color, cssClass: "apexcharts-point-annotation-label " + t2.label.style.cssClass });
      if (g.attr({ rel: i }), e.appendChild(g.node), t2.customSVG.SVG) {
        var f = this.graphics.group({ class: "apexcharts-point-annotations-custom-svg " + t2.customSVG.cssClass });
        f.attr({ transform: "translate(".concat(a + t2.customSVG.offsetX, ", ").concat(r + t2.customSVG.offsetY, ")") }), f.node.innerHTML = t2.customSVG.SVG, e.appendChild(f.node);
      }
    }
  } }, { key: "drawPointAnnotations", value: function() {
    var t2 = this, e = this.w, i = this.graphics.group({ class: "apexcharts-point-annotations" });
    return e.config.annotations.points.map(function(e2, s) {
      t2.addPointAnnotation(e2, i.node, s);
    }), i;
  } }, { key: "setOrientations", value: function(t2) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i = this.w;
    if ("vertical" === t2.label.orientation) {
      var s = null !== e ? e : 0, a = i.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(s, "']"));
      if (null !== a) {
        var r = a.getBoundingClientRect();
        a.setAttribute("x", parseFloat(a.getAttribute("x")) - r.height + 4), "top" === t2.label.position ? a.setAttribute("y", parseFloat(a.getAttribute("y")) + r.width) : a.setAttribute("y", parseFloat(a.getAttribute("y")) - r.width);
        var n = this.graphics.rotateAroundCenter(a), o = n.x, l = n.y;
        a.setAttribute("transform", "rotate(-90 ".concat(o, " ").concat(l, ")"));
      }
    }
  } }, { key: "addBackgroundToAnno", value: function(t2, e) {
    var i = this.w;
    if (!e.label.text || e.label.text && !e.label.text.trim()) return null;
    var s = i.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(), a = t2.getBoundingClientRect(), r = e.label.style.padding.left, n = e.label.style.padding.right, o = e.label.style.padding.top, l = e.label.style.padding.bottom;
    "vertical" === e.label.orientation && (o = e.label.style.padding.left, l = e.label.style.padding.right, r = e.label.style.padding.top, n = e.label.style.padding.bottom);
    var h = a.left - s.left - r, c = a.top - s.top - o;
    return this.graphics.drawRect(h, c, a.width + r + n, a.height + o + l, 0, e.label.style.background, 1, e.label.borderWidth, e.label.borderColor, 0);
  } }, { key: "annotationsBackground", value: function() {
    var t2 = this, e = this.w, i = function(i2, s, a) {
      var r = e.globals.dom.baseEl.querySelector(".apexcharts-".concat(a, "-annotations .apexcharts-").concat(a, "-annotation-label[rel='").concat(s, "']"));
      if (r) {
        var n = r.parentNode, o = t2.addBackgroundToAnno(r, i2);
        o && n.insertBefore(o.node, r);
      }
    };
    e.config.annotations.xaxis.map(function(t3, e2) {
      i(t3, e2, "xaxis");
    }), e.config.annotations.yaxis.map(function(t3, e2) {
      i(t3, e2, "yaxis");
    }), e.config.annotations.points.map(function(t3, e2) {
      i(t3, e2, "point");
    });
  } }, { key: "addText", value: function(t2, e, i) {
    var s = t2.x, a = t2.y, r = t2.text, n = t2.textAnchor, o = t2.appendTo, l = void 0 === o ? ".apexcharts-inner" : o, h = t2.foreColor, c = t2.fontSize, d = t2.fontFamily, u = t2.cssClass, g = t2.backgroundColor, f = t2.borderWidth, p = t2.strokeDashArray, x = t2.radius, m = t2.borderColor, b = t2.paddingLeft, v = void 0 === b ? 4 : b, y = t2.paddingRight, w = void 0 === y ? 4 : y, k = t2.paddingBottom, A = void 0 === k ? 2 : k, S = t2.paddingTop, C = void 0 === S ? 2 : S, L = i, P = L.w, z = P.globals.dom.baseEl.querySelector(l), T = this.graphics.drawText({ x: s, y: a, text: r, textAnchor: n || "start", fontSize: c || "12px", fontFamily: d || P.config.chart.fontFamily, foreColor: h || P.config.chart.foreColor, cssClass: u });
    z.appendChild(T.node);
    var M = T.bbox();
    if (r) {
      var E = this.graphics.drawRect(M.x - v, M.y - C, M.width + v + w, M.height + A + C, x, g, 1, f, m, p);
      T.before(E);
    }
    return e && P.globals.memory.methodsToExec.push({ context: L, method: L.addText, params: { x: s, y: a, text: r, textAnchor: n, appendTo: l, foreColor: h, fontSize: c, cssClass: u, backgroundColor: g, borderWidth: f, strokeDashArray: p, radius: x, borderColor: m, paddingLeft: v, paddingRight: w, paddingBottom: A, paddingTop: C } }), i;
  } }, { key: "addPointAnnotationExternal", value: function(t2, e, i) {
    return void 0 === this.invertAxis && (this.invertAxis = i.w.globals.isBarHorizontal), this.addAnnotationExternal({ params: t2, pushToMemory: e, context: i, type: "point", contextMethod: i.addPointAnnotation }), i;
  } }, { key: "addYaxisAnnotationExternal", value: function(t2, e, i) {
    return this.addAnnotationExternal({ params: t2, pushToMemory: e, context: i, type: "yaxis", contextMethod: i.addYaxisAnnotation }), i;
  } }, { key: "addXaxisAnnotationExternal", value: function(t2, e, i) {
    return this.addAnnotationExternal({ params: t2, pushToMemory: e, context: i, type: "xaxis", contextMethod: i.addXaxisAnnotation }), i;
  } }, { key: "addAnnotationExternal", value: function(t2) {
    var e = t2.params, i = t2.pushToMemory, s = t2.context, a = t2.type, r = t2.contextMethod, n = s, o = n.w, l = o.globals.dom.baseEl.querySelector(".apexcharts-".concat(a, "-annotations")), h = l.childNodes.length + 1, c = new Options(), d = Object.assign({}, "xaxis" === a ? c.xAxisAnnotation : "yaxis" === a ? c.yAxisAnnotation : c.pointAnnotation), u = Utils.extend(d, e);
    switch (a) {
      case "xaxis":
        this.addXaxisAnnotation(u, l, h);
        break;
      case "yaxis":
        this.addYaxisAnnotation(u, l, h);
        break;
      case "point":
        this.addPointAnnotation(u, l, h);
    }
    var g = o.globals.dom.baseEl.querySelector(".apexcharts-".concat(a, "-annotations .apexcharts-").concat(a, "-annotation-label[rel='").concat(h, "']")), f = this.addBackgroundToAnno(g, u);
    return f && l.insertBefore(f.node, g), i && o.globals.memory.methodsToExec.push({ context: n, method: r, params: e }), s;
  } }]), t;
})();
var DateTime = (function() {
  function t(e) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.months31 = [1, 3, 5, 7, 8, 10, 12], this.months30 = [2, 4, 6, 9, 11], this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  }
  return _createClass(t, [{ key: "isValidDate", value: function(t2) {
    return !isNaN(this.parseDate(t2));
  } }, { key: "getUTCTimeStamp", value: function(t2) {
    return Date.parse(t2) ? new Date(new Date(t2).toISOString().substr(0, 25)).getTime() : t2;
  } }, { key: "parseDate", value: function(t2) {
    var e = Date.parse(t2);
    if (!isNaN(e)) return this.getUTCTimeStamp(t2);
    var i = Date.parse(t2.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
    return i = this.getUTCTimeStamp(i);
  } }, { key: "treatAsUtc", value: function(t2) {
    var e = new Date(t2);
    return e.setMinutes(e.getMinutes() - e.getTimezoneOffset()), e;
  } }, { key: "formatDate", value: function(t2, e) {
    var i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], s = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], a = this.w.globals.locale, r = ["\0"].concat(_toConsumableArray(a.months)), n = [""].concat(_toConsumableArray(a.shortMonths)), o = [""].concat(_toConsumableArray(a.days)), l = [""].concat(_toConsumableArray(a.shortDays));
    function h(t3, e2) {
      var i2 = t3 + "";
      for (e2 = e2 || 2; i2.length < e2; ) i2 = "0" + i2;
      return i2;
    }
    s && (t2 = this.treatAsUtc(t2));
    var c = i ? t2.getUTCFullYear() : t2.getFullYear();
    e = (e = (e = e.replace(/(^|[^\\])yyyy+/g, "$1" + c)).replace(/(^|[^\\])yy/g, "$1" + c.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + c);
    var d = (i ? t2.getUTCMonth() : t2.getMonth()) + 1;
    e = (e = (e = (e = e.replace(/(^|[^\\])MMMM+/g, "$1" + r[0])).replace(/(^|[^\\])MMM/g, "$1" + n[0])).replace(/(^|[^\\])MM/g, "$1" + h(d))).replace(/(^|[^\\])M/g, "$1" + d);
    var u = i ? t2.getUTCDate() : t2.getDate();
    e = (e = (e = (e = e.replace(/(^|[^\\])dddd+/g, "$1" + o[0])).replace(/(^|[^\\])ddd/g, "$1" + l[0])).replace(/(^|[^\\])dd/g, "$1" + h(u))).replace(/(^|[^\\])d/g, "$1" + u);
    var g = i ? t2.getUTCHours() : t2.getHours(), f = g > 12 ? g - 12 : 0 === g ? 12 : g;
    e = (e = (e = (e = e.replace(/(^|[^\\])HH+/g, "$1" + h(g))).replace(/(^|[^\\])H/g, "$1" + g)).replace(/(^|[^\\])hh+/g, "$1" + h(f))).replace(/(^|[^\\])h/g, "$1" + f);
    var p = i ? t2.getUTCMinutes() : t2.getMinutes();
    e = (e = e.replace(/(^|[^\\])mm+/g, "$1" + h(p))).replace(/(^|[^\\])m/g, "$1" + p);
    var x = i ? t2.getUTCSeconds() : t2.getSeconds();
    e = (e = e.replace(/(^|[^\\])ss+/g, "$1" + h(x))).replace(/(^|[^\\])s/g, "$1" + x);
    var m = i ? t2.getUTCMilliseconds() : t2.getMilliseconds();
    e = e.replace(/(^|[^\\])fff+/g, "$1" + h(m, 3)), m = Math.round(m / 10), e = e.replace(/(^|[^\\])ff/g, "$1" + h(m)), m = Math.round(m / 10);
    var b = g < 12 ? "AM" : "PM";
    e = (e = (e = e.replace(/(^|[^\\])f/g, "$1" + m)).replace(/(^|[^\\])TT+/g, "$1" + b)).replace(/(^|[^\\])T/g, "$1" + b.charAt(0));
    var v = b.toLowerCase();
    e = (e = e.replace(/(^|[^\\])tt+/g, "$1" + v)).replace(/(^|[^\\])t/g, "$1" + v.charAt(0));
    var y = -t2.getTimezoneOffset(), w = i || !y ? "Z" : y > 0 ? "+" : "-";
    if (!i) {
      var k = (y = Math.abs(y)) % 60;
      w += h(Math.floor(y / 60)) + ":" + h(k);
    }
    e = e.replace(/(^|[^\\])K/g, "$1" + w);
    var A = (i ? t2.getUTCDay() : t2.getDay()) + 1;
    return e = (e = (e = (e = (e = e.replace(new RegExp(o[0], "g"), o[A])).replace(new RegExp(l[0], "g"), l[A])).replace(new RegExp(r[0], "g"), r[d])).replace(new RegExp(n[0], "g"), n[d])).replace(/\\(.)/g, "$1");
  } }, { key: "getTimeUnitsfromTimestamp", value: function(t2, e) {
    var i = this.w;
    void 0 !== i.config.xaxis.min && (t2 = i.config.xaxis.min), void 0 !== i.config.xaxis.max && (e = i.config.xaxis.max);
    var s = new Date(t2).getFullYear(), a = new Date(e).getFullYear(), r = new Date(t2).getMonth(), n = new Date(e).getMonth(), o = new Date(t2).getDate(), l = new Date(e).getDate(), h = new Date(t2).getHours(), c = new Date(e).getHours();
    return { minMinute: new Date(t2).getMinutes(), maxMinute: new Date(e).getMinutes(), minHour: h, maxHour: c, minDate: o, maxDate: l, minMonth: r, maxMonth: n, minYear: s, maxYear: a };
  } }, { key: "isLeapYear", value: function(t2) {
    return t2 % 4 == 0 && t2 % 100 != 0 || t2 % 400 == 0;
  } }, { key: "calculcateLastDaysOfMonth", value: function(t2, e, i) {
    return this.determineDaysOfMonths(t2, e) - i;
  } }, { key: "determineDaysOfYear", value: function(t2) {
    var e = 365;
    return this.isLeapYear(t2) && (e = 366), e;
  } }, { key: "determineRemainingDaysOfYear", value: function(t2, e, i) {
    var s = this.daysCntOfYear[e] + i;
    return e > 1 && this.isLeapYear() && s++, s;
  } }, { key: "determineDaysOfMonths", value: function(t2, e) {
    var i = 30;
    switch (t2 = Utils.monthMod(t2), true) {
      case this.months30.indexOf(t2) > -1:
        2 === t2 && (i = this.isLeapYear(e) ? 29 : 28);
        break;
      case this.months31.indexOf(t2) > -1:
      default:
        i = 31;
    }
    return i;
  } }]), t;
})();
var Defaults = (function() {
  function t(e) {
    _classCallCheck(this, t), this.opts = e;
  }
  return _createClass(t, [{ key: "line", value: function() {
    return { chart: { animations: { easing: "swing" } }, dataLabels: { enabled: false }, stroke: { width: 5, curve: "straight" }, markers: { size: 0, hover: { sizeOffset: 6 } }, xaxis: { crosshairs: { width: 1 } } };
  } }, { key: "sparkline", value: function(t2) {
    this.opts.yaxis[0].labels.show = false, this.opts.yaxis[0].floating = true;
    return Utils.extend(t2, { grid: { show: false, padding: { left: 0, right: 0, top: 0, bottom: 0 } }, legend: { show: false }, xaxis: { labels: { show: false }, tooltip: { enabled: false }, axisBorder: { show: false } }, chart: { toolbar: { show: false }, zoom: { enabled: false } }, dataLabels: { enabled: false } });
  } }, { key: "bar", value: function() {
    return { chart: { stacked: false, animations: { easing: "swing" } }, plotOptions: { bar: { dataLabels: { position: "center" } } }, dataLabels: { style: { colors: ["#fff"] } }, stroke: { width: 0 }, fill: { opacity: 0.85 }, legend: { markers: { shape: "square", radius: 2, size: 8 } }, tooltip: { shared: false }, xaxis: { tooltip: { enabled: false }, crosshairs: { width: "barWidth", position: "back", fill: { type: "gradient" }, dropShadow: { enabled: false }, stroke: { width: 0 } } } };
  } }, { key: "candlestick", value: function() {
    return { stroke: { width: 1, colors: ["#333"] }, dataLabels: { enabled: false }, tooltip: { shared: true, custom: function(t2) {
      var e = t2.seriesIndex, i = t2.dataPointIndex, s = t2.w;
      return '<div class="apexcharts-tooltip-candlestick"><div>Open: <span class="value">' + s.globals.seriesCandleO[e][i] + '</span></div><div>High: <span class="value">' + s.globals.seriesCandleH[e][i] + '</span></div><div>Low: <span class="value">' + s.globals.seriesCandleL[e][i] + '</span></div><div>Close: <span class="value">' + s.globals.seriesCandleC[e][i] + "</span></div></div>";
    } }, states: { active: { filter: { type: "none" } } }, xaxis: { crosshairs: { width: 1 } } };
  } }, { key: "rangeBar", value: function() {
    return { stroke: { width: 0 }, plotOptions: { bar: { dataLabels: { position: "center" } } }, dataLabels: { enabled: false, formatter: function(t2, e) {
      e.ctx;
      var i = e.seriesIndex, s = e.dataPointIndex, a = e.w, r = a.globals.seriesRangeStart[i][s];
      return a.globals.seriesRangeEnd[i][s] - r;
    }, style: { colors: ["#fff"] } }, tooltip: { shared: false, followCursor: true, custom: function(t2) {
      var e = t2.ctx, i = t2.seriesIndex, s = t2.dataPointIndex, a = t2.w, r = a.globals.seriesRangeStart[i][s], n = a.globals.seriesRangeEnd[i][s], o = "", l = "", h = a.globals.colors[i];
      if (void 0 === a.config.tooltip.x.formatter) if ("datetime" === a.config.xaxis.type) {
        var c = new DateTime(e);
        o = c.formatDate(new Date(r), a.config.tooltip.x.format, true, true), l = c.formatDate(new Date(n), a.config.tooltip.x.format, true, true);
      } else o = r, l = n;
      else o = a.config.tooltip.x.formatter(r), l = a.config.tooltip.x.formatter(n);
      var d = a.globals.labels[s];
      return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + h + '">' + (a.config.series[i].name ? a.config.series[i].name : "") + '</span></div><div> <span class="category">' + d + ': </span> <span class="value start-value">' + o + '</span> <span class="separator">-</span> <span class="value end-value">' + l + "</span></div></div>";
    } }, xaxis: { tooltip: { enabled: false }, crosshairs: { stroke: { width: 0 } } } };
  } }, { key: "area", value: function() {
    return { stroke: { width: 4 }, fill: { type: "gradient", gradient: { inverseColors: false, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } }, markers: { size: 0, hover: { sizeOffset: 6 } }, tooltip: { followCursor: false } };
  } }, { key: "brush", value: function(t2) {
    return Utils.extend(t2, { chart: { toolbar: { autoSelected: "selection", show: false }, zoom: { enabled: false } }, dataLabels: { enabled: false }, stroke: { width: 1 }, tooltip: { enabled: false }, xaxis: { tooltip: { enabled: false } } });
  } }, { key: "stacked100", value: function() {
    var t2 = this;
    this.opts.dataLabels = this.opts.dataLabels || {}, this.opts.dataLabels.formatter = this.opts.dataLabels.formatter || void 0;
    var e = this.opts.dataLabels.formatter;
    this.opts.yaxis.forEach(function(e2, i) {
      t2.opts.yaxis[i].min = 0, t2.opts.yaxis[i].max = 100;
    }), "bar" === this.opts.chart.type && (this.opts.dataLabels.formatter = e || function(t3) {
      return "number" == typeof t3 && t3 ? t3.toFixed(0) + "%" : t3;
    });
  } }, { key: "bubble", value: function() {
    return { dataLabels: { style: { colors: ["#fff"] } }, tooltip: { shared: false, intersect: true }, xaxis: { crosshairs: { width: 0 } }, fill: { type: "solid", gradient: { shade: "light", inverse: true, shadeIntensity: 0.55, opacityFrom: 0.4, opacityTo: 0.8 } } };
  } }, { key: "scatter", value: function() {
    return { dataLabels: { enabled: false }, tooltip: { shared: false, intersect: true }, markers: { size: 6, strokeWidth: 2, hover: { sizeOffset: 2 } } };
  } }, { key: "heatmap", value: function() {
    return { chart: { stacked: false, zoom: { enabled: false } }, fill: { opacity: 1 }, dataLabels: { style: { colors: ["#fff"] } }, stroke: { colors: ["#fff"] }, tooltip: { followCursor: true, marker: { show: false }, x: { show: false } }, legend: { position: "top", markers: { shape: "square", size: 10, offsetY: 2 } }, grid: { padding: { right: 20 } } };
  } }, { key: "pie", value: function() {
    return { chart: { toolbar: { show: false } }, plotOptions: { pie: { donut: { labels: { show: false } } } }, dataLabels: { formatter: function(t2) {
      return t2.toFixed(1) + "%";
    }, style: { colors: ["#fff"] }, dropShadow: { enabled: true } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "dark", shadeIntensity: 0.35, inverseColors: false, stops: [0, 100, 100] } }, padding: { right: 0, left: 0 }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" } };
  } }, { key: "donut", value: function() {
    return { chart: { toolbar: { show: false } }, dataLabels: { formatter: function(t2) {
      return t2.toFixed(1) + "%";
    }, style: { colors: ["#fff"] }, dropShadow: { enabled: true } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "dark", shadeIntensity: 0.4, inverseColors: false, type: "vertical", opacityFrom: 1, opacityTo: 1, stops: [70, 98, 100] } }, padding: { right: 0, left: 0 }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" } };
  } }, { key: "radar", value: function() {
    return this.opts.yaxis[0].labels.style.fontSize = "13px", this.opts.yaxis[0].labels.offsetY = 6, { dataLabels: { enabled: true, style: { colors: ["#a8a8a8"], fontSize: "11px" } }, stroke: { width: 2 }, markers: { size: 3, strokeWidth: 1, strokeOpacity: 1 }, fill: { opacity: 0.2 }, tooltip: { shared: false, intersect: true, followCursor: true }, grid: { show: false }, xaxis: { tooltip: { enabled: false }, crosshairs: { show: false } } };
  } }, { key: "radialBar", value: function() {
    return { chart: { animations: { dynamicAnimation: { enabled: true, speed: 800 } }, toolbar: { show: false } }, fill: { gradient: { shade: "dark", shadeIntensity: 0.4, inverseColors: false, type: "diagonal2", opacityFrom: 1, opacityTo: 1, stops: [70, 98, 100] } }, padding: { right: 0, left: 0 }, legend: { show: false, position: "right" }, tooltip: { enabled: false, fillSeriesColor: true } };
  } }], [{ key: "convertCatToNumeric", value: function(t2) {
    t2.xaxis.type = "numeric", t2.xaxis.convertedCatToNumeric = true, t2.xaxis.labels = t2.xaxis.labels || {}, t2.xaxis.labels.formatter = t2.xaxis.labels.formatter || function(t3) {
      return t3;
    }, t2.chart = t2.chart || {}, t2.chart.zoom = t2.chart.zoom || window.Apex.chart && window.Apex.chart.zoom || {};
    var e = t2.xaxis.labels.formatter, i = t2.xaxis.categories && t2.xaxis.categories.length ? t2.xaxis.categories : t2.labels;
    return i && i.length && (t2.xaxis.labels.formatter = function(t3) {
      return e(i[t3 - 1]);
    }), t2.xaxis.categories = [], t2.labels = [], t2.chart.zoom.enabled = t2.chart.zoom.enabled || false, t2;
  } }]), t;
})();
var CoreUtils = (function() {
  function t(e) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w;
  }
  return _createClass(t, [{ key: "getStackedSeriesTotals", value: function() {
    var t2 = this.w, e = [];
    if (0 === t2.globals.series.length) return e;
    for (var i = 0; i < t2.globals.series[t2.globals.maxValsInArrayIndex].length; i++) {
      for (var s = 0, a = 0; a < t2.globals.series.length; a++) s += t2.globals.series[a][i];
      e.push(s);
    }
    return t2.globals.stackedSeriesTotals = e, e;
  } }, { key: "getSeriesTotalByIndex", value: function() {
    var t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
    return null === t2 ? this.w.config.series.reduce(function(t3, e) {
      return t3 + e;
    }, 0) : this.w.globals.series[t2].reduce(function(t3, e) {
      return t3 + e;
    }, 0);
  } }, { key: "isSeriesNull", value: function() {
    var t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
    return 0 === (null === t2 ? this.w.config.series.filter(function(t3) {
      return null !== t3;
    }) : this.w.globals.series[t2].filter(function(t3) {
      return null !== t3;
    })).length;
  } }, { key: "seriesHaveSameValues", value: function(t2) {
    return this.w.globals.series[t2].every(function(t3, e, i) {
      return t3 === i[0];
    });
  } }, { key: "getLargestSeries", value: function() {
    var t2 = this.w;
    t2.globals.maxValsInArrayIndex = t2.globals.series.map(function(t3) {
      return t3.length;
    }).indexOf(Math.max.apply(Math, t2.globals.series.map(function(t3) {
      return t3.length;
    })));
  } }, { key: "getLargestMarkerSize", value: function() {
    var t2 = this.w, e = 0;
    return t2.globals.markers.size.forEach(function(t3) {
      e = Math.max(e, t3);
    }), t2.globals.markers.largestSize = e, e;
  } }, { key: "getSeriesTotals", value: function() {
    var t2 = this.w;
    t2.globals.seriesTotals = t2.globals.series.map(function(t3, e) {
      var i = 0;
      if (Array.isArray(t3)) for (var s = 0; s < t3.length; s++) i += t3[s];
      else i += t3;
      return i;
    });
  } }, { key: "getSeriesTotalsXRange", value: function(t2, e) {
    var i = this.w;
    return i.globals.series.map(function(s, a) {
      for (var r = 0, n = 0; n < s.length; n++) i.globals.seriesX[a][n] > t2 && i.globals.seriesX[a][n] < e && (r += s[n]);
      return r;
    });
  } }, { key: "getPercentSeries", value: function() {
    var t2 = this.w;
    t2.globals.seriesPercent = t2.globals.series.map(function(e, i) {
      var s = [];
      if (Array.isArray(e)) for (var a = 0; a < e.length; a++) {
        var r = t2.globals.stackedSeriesTotals[a], n = 0;
        r && (n = 100 * e[a] / r), s.push(n);
      }
      else {
        var o = 100 * e / t2.globals.seriesTotals.reduce(function(t3, e2) {
          return t3 + e2;
        }, 0);
        s.push(o);
      }
      return s;
    });
  } }, { key: "getCalculatedRatios", value: function() {
    var t2, e, i, s, a, r = this.w.globals, n = [], o = [], l = 0.1, h = 0;
    if (r.yRange = [], r.isMultipleYAxis) for (var c = 0; c < r.minYArr.length; c++) r.yRange.push(Math.abs(r.minYArr[c] - r.maxYArr[c])), o.push(0);
    else r.yRange.push(Math.abs(r.minY - r.maxY));
    r.xRange = Math.abs(r.maxX - r.minX), r.zRange = Math.abs(r.maxZ - r.minZ);
    for (var d = 0; d < r.yRange.length; d++) n.push(r.yRange[d] / r.gridHeight);
    if (e = r.xRange / r.gridWidth, i = Math.abs(r.initialmaxX - r.initialminX) / r.gridWidth, t2 = r.yRange / r.gridWidth, s = r.xRange / r.gridHeight, a = r.zRange / r.gridHeight * 16, r.minY !== Number.MIN_VALUE && 0 !== Math.abs(r.minY) && (r.hasNegs = true), r.isMultipleYAxis) {
      o = [];
      for (var u = 0; u < n.length; u++) o.push(-r.minYArr[u] / n[u]);
    } else o.push(-r.minY / n[0]), r.minY !== Number.MIN_VALUE && 0 !== Math.abs(r.minY) && (l = -r.minY / t2, h = r.minX / e);
    return { yRatio: n, invertedYRatio: t2, zRatio: a, xRatio: e, initialXRatio: i, invertedXRatio: s, baseLineInvertedY: l, baseLineY: o, baseLineX: h };
  } }, { key: "getLogSeries", value: function(t2) {
    var e = this.w;
    return e.globals.seriesLog = t2.map(function(t3, i) {
      return e.config.yaxis[i] && e.config.yaxis[i].logarithmic ? t3.map(function(t4) {
        return null === t4 ? null : (Math.log(t4) - Math.log(e.globals.minYArr[i])) / (Math.log(e.globals.maxYArr[i]) - Math.log(e.globals.minYArr[i]));
      }) : t3;
    }), e.globals.seriesLog;
  } }, { key: "getLogYRatios", value: function(t2) {
    var e = this, i = this.w, s = this.w.globals;
    return s.yLogRatio = t2.slice(), s.logYRange = s.yRange.map(function(t3, a) {
      if (i.config.yaxis[a] && e.w.config.yaxis[a].logarithmic) {
        var r, n = -Number.MAX_VALUE, o = Number.MIN_VALUE;
        return s.seriesLog.forEach(function(t4, e2) {
          t4.forEach(function(t5) {
            i.config.yaxis[e2] && i.config.yaxis[e2].logarithmic && (n = Math.max(t5, n), o = Math.min(t5, o));
          });
        }), r = Math.pow(s.yRange[a], Math.abs(o - n) / s.yRange[a]), s.yLogRatio[a] = r / s.gridHeight, r;
      }
    }), s.yLogRatio;
  } }], [{ key: "checkComboSeries", value: function(t2) {
    var e = false, i = false;
    return t2.length && void 0 !== t2[0].type && (e = true, t2.forEach(function(t3) {
      "bar" !== t3.type && "column" !== t3.type || (i = true);
    })), { comboCharts: e, comboChartsHasBars: i };
  } }, { key: "extendArrayProps", value: function(t2, e) {
    return e.yaxis && (e = t2.extendYAxis(e)), e.annotations && (e.annotations.yaxis && (e = t2.extendYAxisAnnotations(e)), e.annotations.xaxis && (e = t2.extendXAxisAnnotations(e)), e.annotations.points && (e = t2.extendPointAnnotations(e))), e;
  } }]), t;
})();
var Config = (function() {
  function t(e) {
    _classCallCheck(this, t), this.opts = e;
  }
  return _createClass(t, [{ key: "init", value: function() {
    var t2 = this.opts, e = new Options(), i = new Defaults(t2);
    this.chartType = t2.chart.type, "histogram" === this.chartType && (t2.chart.type = "bar", t2 = Utils.extend({ plotOptions: { bar: { columnWidth: "99.99%" } } }, t2)), t2 = this.extendYAxis(t2), t2 = this.extendAnnotations(t2);
    var s = e.init(), a = {};
    if (t2 && "object" === _typeof(t2)) {
      var r = {};
      switch (this.chartType) {
        case "line":
          r = i.line();
          break;
        case "area":
          r = i.area();
          break;
        case "bar":
          r = i.bar();
          break;
        case "candlestick":
          r = i.candlestick();
          break;
        case "rangeBar":
          r = i.rangeBar();
          break;
        case "histogram":
          r = i.bar();
          break;
        case "bubble":
          r = i.bubble();
          break;
        case "scatter":
          r = i.scatter();
          break;
        case "heatmap":
          r = i.heatmap();
          break;
        case "pie":
          r = i.pie();
          break;
        case "donut":
          r = i.donut();
          break;
        case "radar":
          r = i.radar();
          break;
        case "radialBar":
          r = i.radialBar();
          break;
        default:
          r = i.line();
      }
      t2.chart.brush && t2.chart.brush.enabled && (r = i.brush(r)), t2.chart.stacked && "100%" === t2.chart.stackType && i.stacked100(), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(t2), t2.xaxis = t2.xaxis || window.Apex.xaxis || {};
      var n = CoreUtils.checkComboSeries(t2.series);
      "line" !== t2.chart.type && "area" !== t2.chart.type && "scatter" !== t2.chart.type || n.comboChartsHasBars || "datetime" === t2.xaxis.type || "numeric" === t2.xaxis.type || "between" === t2.xaxis.tickPlacement || (t2 = Defaults.convertCatToNumeric(t2)), (t2.chart.sparkline && t2.chart.sparkline.enabled || window.Apex.chart && window.Apex.chart.sparkline && window.Apex.chart.sparkline.enabled) && (r = i.sparkline(r)), a = Utils.extend(s, r);
    }
    var o = Utils.extend(a, window.Apex);
    return s = Utils.extend(o, t2), s = this.handleUserInputErrors(s);
  } }, { key: "extendYAxis", value: function(t2) {
    var e = new Options();
    return void 0 === t2.yaxis && (t2.yaxis = {}), t2.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (t2.yaxis = Utils.extend(t2.yaxis, window.Apex.yaxis)), t2.yaxis.constructor !== Array ? t2.yaxis = [Utils.extend(e.yAxis, t2.yaxis)] : t2.yaxis = Utils.extendArray(t2.yaxis, e.yAxis), t2;
  } }, { key: "extendAnnotations", value: function(t2) {
    return void 0 === t2.annotations && (t2.annotations = {}, t2.annotations.yaxis = [], t2.annotations.xaxis = [], t2.annotations.points = []), t2 = this.extendYAxisAnnotations(t2), t2 = this.extendXAxisAnnotations(t2), t2 = this.extendPointAnnotations(t2);
  } }, { key: "extendYAxisAnnotations", value: function(t2) {
    var e = new Options();
    return t2.annotations.yaxis = Utils.extendArray(void 0 !== t2.annotations.yaxis ? t2.annotations.yaxis : [], e.yAxisAnnotation), t2;
  } }, { key: "extendXAxisAnnotations", value: function(t2) {
    var e = new Options();
    return t2.annotations.xaxis = Utils.extendArray(void 0 !== t2.annotations.xaxis ? t2.annotations.xaxis : [], e.xAxisAnnotation), t2;
  } }, { key: "extendPointAnnotations", value: function(t2) {
    var e = new Options();
    return t2.annotations.points = Utils.extendArray(void 0 !== t2.annotations.points ? t2.annotations.points : [], e.pointAnnotation), t2;
  } }, { key: "checkForDarkTheme", value: function(t2) {
    t2.theme && "dark" === t2.theme.mode && (t2.tooltip || (t2.tooltip = {}), "light" !== t2.tooltip.theme && (t2.tooltip.theme = "dark"), t2.chart.foreColor || (t2.chart.foreColor = "#f6f7f8"), t2.theme.palette || (t2.theme.palette = "palette4"));
  } }, { key: "handleUserInputErrors", value: function(t2) {
    var e = t2;
    if (e.tooltip.shared && e.tooltip.intersect) throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");
    if (e.chart.scroller && console.warn("Scroller has been deprecated since v2.0.0. Please remove the configuration for chart.scroller"), ("bar" === e.chart.type || "rangeBar" === e.chart.type) && e.plotOptions.bar.horizontal) {
      if (e.yaxis.length > 1) throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
      e.yaxis[0].reversed && (e.yaxis[0].opposite = true), e.xaxis.tooltip.enabled = false, e.yaxis[0].tooltip.enabled = false, e.chart.zoom.enabled = false;
    }
    return "bar" !== e.chart.type && "rangeBar" !== e.chart.type || e.tooltip.shared && ("barWidth" === e.xaxis.crosshairs.width && e.series.length > 1 && (console.warn('crosshairs.width = "barWidth" is only supported in single series, not in a multi-series barChart.'), e.xaxis.crosshairs.width = "tickWidth"), e.plotOptions.bar.horizontal && (e.states.hover.type = "none", e.tooltip.shared = false), e.tooltip.followCursor || (console.warn("followCursor option in shared columns cannot be turned off. Please set %ctooltip.followCursor: true", "color: blue;"), e.tooltip.followCursor = true)), "candlestick" === e.chart.type && e.yaxis[0].reversed && (console.warn("Reversed y-axis in candlestick chart is not supported."), e.yaxis[0].reversed = false), e.chart.group && 0 === e.yaxis[0].labels.minWidth && console.warn("It looks like you have multiple charts in synchronization. You must provide yaxis.labels.minWidth which must be EQUAL for all grouped charts to prevent incorrect behaviour."), Array.isArray(e.stroke.width) && "line" !== e.chart.type && "area" !== e.chart.type && (console.warn("stroke.width option accepts array only for line and area charts. Reverted back to Number"), e.stroke.width = e.stroke.width[0]), e;
  } }]), t;
})();
var Globals = (function() {
  function t() {
    _classCallCheck(this, t);
  }
  return _createClass(t, [{ key: "globalVars", value: function(t2) {
    return { chartID: null, cuid: null, events: { beforeMount: [], mounted: [], updated: [], clicked: [], selection: [], dataPointSelection: [], zoomed: [], scrolled: [] }, colors: [], clientX: null, clientY: null, fill: { colors: [] }, stroke: { colors: [] }, dataLabels: { style: { colors: [] } }, radarPolygons: { fill: { colors: [] } }, markers: { colors: [], size: t2.markers.size, largestSize: 0 }, animationEnded: false, isTouchDevice: "ontouchstart" in window || navigator.msMaxTouchPoints, isDirty: false, isExecCalled: false, initialConfig: null, lastXAxis: [], lastYAxis: [], series: [], seriesRangeStart: [], seriesRangeEnd: [], seriesPercent: [], seriesTotals: [], stackedSeriesTotals: [], seriesX: [], seriesZ: [], labels: [], timelineLabels: [], invertedTimelineLabels: [], seriesNames: [], noLabelsProvided: false, allSeriesCollapsed: false, collapsedSeries: [], collapsedSeriesIndices: [], ancillaryCollapsedSeries: [], ancillaryCollapsedSeriesIndices: [], risingSeries: [], dataFormatXNumeric: false, capturedSeriesIndex: -1, capturedDataPointIndex: -1, selectedDataPoints: [], ignoreYAxisIndexes: [], yAxisSameScaleIndices: [], padHorizontal: 0, maxValsInArrayIndex: 0, radialSize: 0, zoomEnabled: "zoom" === t2.chart.toolbar.autoSelected && t2.chart.toolbar.tools.zoom && t2.chart.zoom.enabled, panEnabled: "pan" === t2.chart.toolbar.autoSelected && t2.chart.toolbar.tools.pan, selectionEnabled: "selection" === t2.chart.toolbar.autoSelected && t2.chart.toolbar.tools.selection, yaxis: null, minY: Number.MIN_VALUE, maxY: -Number.MAX_VALUE, minYArr: [], maxYArr: [], maxX: -Number.MAX_VALUE, initialmaxX: -Number.MAX_VALUE, minX: Number.MIN_VALUE, initialminX: Number.MIN_VALUE, minZ: Number.MIN_VALUE, maxZ: -Number.MAX_VALUE, minXDiff: Number.MAX_VALUE, mousedown: false, lastClientPosition: {}, visibleXRange: void 0, yRange: [], zRange: 0, xRange: 0, yValueDecimal: 0, total: 0, SVGNS: "http://www.w3.org/2000/svg", svgWidth: 0, svgHeight: 0, noData: false, locale: {}, dom: {}, memory: { methodsToExec: [] }, shouldAnimate: true, skipLastTimelinelabel: false, delayedElements: [], axisCharts: true, isXNumeric: false, isDataXYZ: false, resized: false, resizeTimer: null, comboCharts: false, comboChartsHasBars: false, dataChanged: false, previousPaths: [], seriesXvalues: [], seriesYvalues: [], seriesCandleO: [], seriesCandleH: [], seriesCandleL: [], seriesCandleC: [], allSeriesHasEqualX: true, dataPoints: 0, pointsArray: [], dataLabelsRects: [], lastDrawnDataLabelsIndexes: [], hasNullValues: false, easing: null, zoomed: false, gridWidth: 0, gridHeight: 0, yAxisScale: [], xAxisScale: null, xAxisTicksPositions: [], timescaleTicks: [], rotateXLabels: false, defaultLabels: false, xLabelFormatter: void 0, yLabelFormatters: [], xaxisTooltipFormatter: void 0, ttKeyFormatter: void 0, ttVal: void 0, ttZFormatter: void 0, LINE_HEIGHT_RATIO: 1.618, xAxisLabelsHeight: 0, yAxisLabelsWidth: 0, scaleX: 1, scaleY: 1, translateX: 0, translateY: 0, translateYAxisX: [], yLabelsCoords: [], yTitleCoords: [], yAxisWidths: [], translateXAxisY: 0, translateXAxisX: 0, tooltip: null, tooltipOpts: null };
  } }, { key: "init", value: function(t2) {
    var e = this.globalVars(t2);
    return e.initialConfig = Utils.extend({}, t2), e.initialSeries = JSON.parse(JSON.stringify(e.initialConfig.series)), e.lastXAxis = JSON.parse(JSON.stringify(e.initialConfig.xaxis)), e.lastYAxis = JSON.parse(JSON.stringify(e.initialConfig.yaxis)), e;
  } }]), t;
})();
var Base = (function() {
  function t(e) {
    _classCallCheck(this, t), this.opts = e;
  }
  return _createClass(t, [{ key: "init", value: function() {
    var t2 = new Config(this.opts).init();
    return { config: t2, globals: new Globals().init(t2) };
  } }]), t;
})();
var Fill = (function() {
  function t(e) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.opts = null, this.seriesIndex = 0;
  }
  return _createClass(t, [{ key: "clippedImgArea", value: function(t2) {
    var e = this.w, i = e.config, s = parseInt(e.globals.gridWidth), a = parseInt(e.globals.gridHeight), r = s > a ? s : a, n = t2.image, o = 0, l = 0;
    void 0 === t2.width && void 0 === t2.height ? void 0 !== i.fill.image.width && void 0 !== i.fill.image.height ? (o = i.fill.image.width + 1, l = i.fill.image.height) : (o = r + 1, l = r) : (o = t2.width, l = t2.height);
    var h = document.createElementNS(e.globals.SVGNS, "pattern");
    Graphics.setAttrs(h, { id: t2.patternID, patternUnits: t2.patternUnits ? t2.patternUnits : "userSpaceOnUse", width: o + "px", height: l + "px" });
    var c = document.createElementNS(e.globals.SVGNS, "image");
    h.appendChild(c), c.setAttributeNS("http://www.w3.org/1999/xlink", "href", n), Graphics.setAttrs(c, { x: 0, y: 0, preserveAspectRatio: "none", width: o + "px", height: l + "px" }), c.style.opacity = t2.opacity, e.globals.dom.elDefs.node.appendChild(h);
  } }, { key: "getSeriesIndex", value: function(t2) {
    var e = this.w;
    return "bar" === e.config.chart.type && e.config.plotOptions.bar.distributed || "heatmap" === e.config.chart.type ? this.seriesIndex = t2.seriesNumber : this.seriesIndex = t2.seriesNumber % e.globals.series.length, this.seriesIndex;
  } }, { key: "fillPath", value: function(t2) {
    var e = this.w;
    this.opts = t2;
    var i, s, a, r = this.w.config;
    this.seriesIndex = this.getSeriesIndex(t2);
    var n = this.getFillColors()[this.seriesIndex];
    "function" == typeof n && (n = n({ seriesIndex: this.seriesIndex, value: t2.value, w: e }));
    var o = this.getFillType(this.seriesIndex), l = Array.isArray(r.fill.opacity) ? r.fill.opacity[this.seriesIndex] : r.fill.opacity, h = n;
    return t2.color && (n = t2.color), -1 === n.indexOf("rgb") ? h = Utils.hexToRgba(n, l) : n.indexOf("rgba") > -1 && (l = "0." + Utils.getOpacityFromRGBA(n)), "pattern" === o && (s = this.handlePatternFill(s, n, l, h)), "gradient" === o && (a = this.handleGradientFill(a, n, l, this.seriesIndex)), r.fill.image.src.length > 0 && "image" === o ? t2.seriesNumber < r.fill.image.src.length ? (this.clippedImgArea({ opacity: l, image: r.fill.image.src[t2.seriesNumber], patternUnits: t2.patternUnits, patternID: "pattern".concat(e.globals.cuid).concat(t2.seriesNumber + 1) }), i = "url(#pattern".concat(e.globals.cuid).concat(t2.seriesNumber + 1, ")")) : i = h : i = "gradient" === o ? a : "pattern" === o ? s : h, t2.solid && (i = h), i;
  } }, { key: "getFillType", value: function(t2) {
    var e = this.w;
    return Array.isArray(e.config.fill.type) ? e.config.fill.type[t2] : e.config.fill.type;
  } }, { key: "getFillColors", value: function() {
    var t2 = this.w, e = t2.config, i = this.opts, s = [];
    return t2.globals.comboCharts ? "line" === t2.config.series[this.seriesIndex].type ? t2.globals.stroke.colors instanceof Array ? s = t2.globals.stroke.colors : s.push(t2.globals.stroke.colors) : t2.globals.fill.colors instanceof Array ? s = t2.globals.fill.colors : s.push(t2.globals.fill.colors) : "line" === e.chart.type ? t2.globals.stroke.colors instanceof Array ? s = t2.globals.stroke.colors : s.push(t2.globals.stroke.colors) : t2.globals.fill.colors instanceof Array ? s = t2.globals.fill.colors : s.push(t2.globals.fill.colors), void 0 !== i.fillColors && (s = [], i.fillColors instanceof Array ? s = i.fillColors.slice() : s.push(i.fillColors)), s;
  } }, { key: "handlePatternFill", value: function(t2, e, i, s) {
    var a = this.w.config, r = this.opts, n = new Graphics(this.ctx), o = void 0 === a.fill.pattern.strokeWidth ? Array.isArray(a.stroke.width) ? a.stroke.width[this.seriesIndex] : a.stroke.width : Array.isArray(a.fill.pattern.strokeWidth) ? a.fill.pattern.strokeWidth[this.seriesIndex] : a.fill.pattern.strokeWidth, l = e;
    a.fill.pattern.style instanceof Array ? t2 = void 0 !== a.fill.pattern.style[r.seriesNumber] ? n.drawPattern(a.fill.pattern.style[r.seriesNumber], a.fill.pattern.width, a.fill.pattern.height, l, o, i) : s : t2 = n.drawPattern(a.fill.pattern.style, a.fill.pattern.width, a.fill.pattern.height, l, o, i);
    return t2;
  } }, { key: "handleGradientFill", value: function(t2, e, i, s) {
    var a, r, n = this.w.config, o = this.opts, l = new Graphics(this.ctx), h = new Utils(), c = n.fill.gradient.type, d = void 0 === n.fill.gradient.opacityFrom ? i : Array.isArray(n.fill.gradient.opacityFrom) ? n.fill.gradient.opacityFrom[s] : n.fill.gradient.opacityFrom, u = void 0 === n.fill.gradient.opacityTo ? i : Array.isArray(n.fill.gradient.opacityTo) ? n.fill.gradient.opacityTo[s] : n.fill.gradient.opacityTo;
    if (a = e, r = void 0 === n.fill.gradient.gradientToColors || 0 === n.fill.gradient.gradientToColors.length ? "dark" === n.fill.gradient.shade ? h.shadeColor(-1 * parseFloat(n.fill.gradient.shadeIntensity), e) : h.shadeColor(parseFloat(n.fill.gradient.shadeIntensity), e) : n.fill.gradient.gradientToColors[o.seriesNumber], n.fill.gradient.inverseColors) {
      var g = a;
      a = r, r = g;
    }
    return l.drawGradient(c, a, r, d, u, o.size, n.fill.gradient.stops, n.fill.gradient.colorStops, s);
  } }]), t;
})();
var Markers = (function() {
  function t(e, i) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w;
  }
  return _createClass(t, [{ key: "setGlobalMarkerSize", value: function() {
    var t2 = this.w;
    if (t2.globals.markers.size = Array.isArray(t2.config.markers.size) ? t2.config.markers.size : [t2.config.markers.size], t2.globals.markers.size.length > 0) {
      if (t2.globals.markers.size.length < t2.globals.series.length + 1) for (var e = 0; e <= t2.globals.series.length; e++) void 0 === t2.globals.markers.size[e] && t2.globals.markers.size.push(t2.globals.markers.size[0]);
    } else t2.globals.markers.size = t2.config.series.map(function(e2) {
      return t2.config.markers.size;
    });
  } }, { key: "plotChartMarkers", value: function(t2, e, i) {
    var s, a = this.w, r = e, n = t2, o = null, l = new Graphics(this.ctx);
    if (a.globals.markers.size[e] > 0 && (o = l.group({ class: "apexcharts-series-markers" })).attr("clip-path", "url(#gridRectMarkerMask".concat(a.globals.cuid, ")")), n.x instanceof Array) for (var h = 0; h < n.x.length; h++) {
      var c = i;
      1 === i && 0 === h && (c = 0), 1 === i && 1 === h && (c = 1);
      var d = "apexcharts-marker";
      if ("line" !== a.config.chart.type && "area" !== a.config.chart.type || a.globals.comboCharts || a.config.tooltip.intersect || (d += " no-pointer-events"), Array.isArray(a.config.markers.size) ? a.globals.markers.size[e] > 0 : a.config.markers.size > 0) {
        Utils.isNumber(n.y[h]) ? d += " w".concat((Math.random() + 1).toString(36).substring(4)) : d = "apexcharts-nullpoint";
        var u = this.getMarkerConfig(d, e, c);
        a.config.series[r].data[i] && (a.config.series[r].data[i].fillColor && (u.pointFillColor = a.config.series[r].data[i].fillColor), a.config.series[r].data[i].strokeColor && (u.pointStrokeColor = a.config.series[r].data[i].strokeColor)), (s = l.drawMarker(n.x[h], n.y[h], u)).attr("rel", c), s.attr("j", c), s.attr("index", e), s.node.setAttribute("default-marker-size", u.pSize), new Filters(this.ctx).setSelectionFilter(s, e, c), this.addEvents(s), o && o.add(s);
      } else void 0 === a.globals.pointsArray[e] && (a.globals.pointsArray[e] = []), a.globals.pointsArray[e].push([n.x[h], n.y[h]]);
    }
    return o;
  } }, { key: "getMarkerConfig", value: function(t2, e) {
    var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s = this.w, a = this.getMarkerStyle(e), r = s.globals.markers.size[e];
    return null !== i && s.config.markers.discrete.length && s.config.markers.discrete.map(function(t3) {
      t3.seriesIndex === e && t3.dataPointIndex === i && (a.pointStrokeColor = t3.strokeColor, a.pointFillColor = t3.fillColor, r = t3.size);
    }), { pSize: r, pRadius: s.config.markers.radius, pWidth: s.config.markers.strokeWidth, pointStrokeColor: a.pointStrokeColor, pointFillColor: a.pointFillColor, shape: s.config.markers.shape instanceof Array ? s.config.markers.shape[e] : s.config.markers.shape, class: t2, pointStrokeOpacity: s.config.markers.strokeOpacity, pointFillOpacity: s.config.markers.fillOpacity, seriesIndex: e };
  } }, { key: "addEvents", value: function(t2) {
    var e = this.w, i = new Graphics(this.ctx);
    t2.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this.ctx, t2)), t2.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this.ctx, t2)), t2.node.addEventListener("mousedown", i.pathMouseDown.bind(this.ctx, t2)), t2.node.addEventListener("click", e.config.markers.onClick), t2.node.addEventListener("dblclick", e.config.markers.onDblClick), t2.node.addEventListener("touchstart", i.pathMouseDown.bind(this.ctx, t2), { passive: true });
  } }, { key: "getMarkerStyle", value: function(t2) {
    var e = this.w, i = e.globals.markers.colors, s = e.config.markers.strokeColor || e.config.markers.strokeColors;
    return { pointStrokeColor: s instanceof Array ? s[t2] : s, pointFillColor: i instanceof Array ? i[t2] : i };
  } }]), t;
})();
var Scatter = (function() {
  function t(e) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.radiusSizes = [];
  }
  return _createClass(t, [{ key: "draw", value: function(t2, e, i) {
    var s = this.w, a = new Graphics(this.ctx), r = i.realIndex, n = i.pointsPos, o = i.zRatio, l = i.elParent, h = a.group({ class: "apexcharts-series-markers apexcharts-series-".concat(s.config.chart.type) });
    if (h.attr("clip-path", "url(#gridRectMarkerMask".concat(s.globals.cuid, ")")), n.x instanceof Array) for (var c = 0; c < n.x.length; c++) {
      var d = e + 1, u = true;
      0 === e && 0 === c && (d = 0), 0 === e && 1 === c && (d = 1);
      var g = 0, f = s.globals.markers.size[r];
      o !== 1 / 0 && (f = s.globals.seriesZ[r][d] / o, void 0 === this.radiusSizes[r] && this.radiusSizes.push([]), this.radiusSizes[r].push(f)), s.config.chart.animations.enabled || (g = f);
      var p = n.x[c], x = n.y[c];
      if (g = g || 0, (0 === p && 0 === x || null === x || void 0 === s.globals.series[r][d]) && (u = false), u) {
        var m = this.drawPoint(p, x, g, f, r, d, e);
        h.add(m);
      }
      l.add(h);
    }
  } }, { key: "drawPoint", value: function(t2, e, i, s, a, r, n) {
    var o = this.w, l = a, h = new Animations(this.ctx), c = new Filters(this.ctx), d = new Fill(this.ctx), u = new Markers(this.ctx), g = new Graphics(this.ctx), f = u.getMarkerConfig("apexcharts-marker", l), p = d.fillPath({ seriesNumber: a, patternUnits: "objectBoundingBox", value: o.globals.series[a][n] }), x = g.drawCircle(i);
    if (o.config.series[l].data[r] && o.config.series[l].data[r].fillColor && (p = o.config.series[l].data[r].fillColor), x.attr({ cx: t2, cy: e, fill: p, stroke: f.pointStrokeColor, strokeWidth: f.pWidth }), o.config.chart.dropShadow.enabled) {
      var m = o.config.chart.dropShadow;
      c.dropShadow(x, m, a);
    }
    if (this.initialAnim && !o.globals.dataChanged) {
      var b = 1;
      o.globals.resized || (b = o.config.chart.animations.speed), h.animateCircleRadius(x, 0, s, b, o.globals.easing);
    }
    if (o.globals.dataChanged) if (this.dynamicAnim) {
      var v, y, w, k, A = o.config.chart.animations.dynamicAnimation.speed;
      null != (k = o.globals.previousPaths[a] && o.globals.previousPaths[a][n]) && (v = k.x, y = k.y, w = void 0 !== k.r ? k.r : s);
      for (var S = 0; S < o.globals.collapsedSeries.length; S++) o.globals.collapsedSeries[S].index === a && (A = 1, s = 0);
      0 === t2 && 0 === e && (s = 0), h.animateCircle(x, { cx: v, cy: y, r: w }, { cx: t2, cy: e, r: s }, A, o.globals.easing);
    } else x.attr({ r: s });
    return x.attr({ rel: r, j: r, index: a, "default-marker-size": s }), c.setSelectionFilter(x, a, r), u.addEvents(x), x.node.classList.add("apexcharts-marker"), x;
  } }, { key: "centerTextInBubble", value: function(t2) {
    var e = this.w;
    return { y: t2 += parseInt(e.config.dataLabels.style.fontSize) / 4 };
  } }]), t;
})();
var DataLabels = (function() {
  function t(e) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w;
  }
  return _createClass(t, [{ key: "dataLabelsCorrection", value: function(t2, e, i, s, a, r, n) {
    var o = this.w, l = false, h = new Graphics(this.ctx).getTextRects(i, n), c = h.width, d = h.height;
    void 0 === o.globals.dataLabelsRects[s] && (o.globals.dataLabelsRects[s] = []), o.globals.dataLabelsRects[s].push({ x: t2, y: e, width: c, height: d });
    var u = o.globals.dataLabelsRects[s].length - 2, g = void 0 !== o.globals.lastDrawnDataLabelsIndexes[s] ? o.globals.lastDrawnDataLabelsIndexes[s][o.globals.lastDrawnDataLabelsIndexes[s].length - 1] : 0;
    if (void 0 !== o.globals.dataLabelsRects[s][u]) {
      var f = o.globals.dataLabelsRects[s][g];
      (t2 > f.x + f.width + 2 || e > f.y + f.height + 2 || t2 + c < f.x) && (l = true);
    }
    return (0 === a || r) && (l = true), { x: t2, y: e, textRects: h, drawnextLabel: l };
  } }, { key: "drawDataLabel", value: function(t2, e, i) {
    var s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "top", a = this.w, r = new Graphics(this.ctx), n = a.config.dataLabels, o = 0, l = 0, h = i, c = null;
    if (!n.enabled || t2.x instanceof Array != true) return c;
    c = r.group({ class: "apexcharts-data-labels" });
    for (var d = 0; d < t2.x.length; d++) if (o = t2.x[d] + n.offsetX, l = t2.y[d] + n.offsetY - a.globals.markers.size[e] - 5, "bottom" === s && (l = l + 2 * a.globals.markers.size[e] + 1.4 * parseInt(n.style.fontSize)), !isNaN(o)) {
      1 === i && 0 === d && (h = 0), 1 === i && 1 === d && (h = 1);
      var u = a.globals.series[e][h], g = "";
      if ("bubble" === a.config.chart.type) g = a.globals.seriesZ[e][h], l = t2.y[d] + a.config.dataLabels.offsetY, l = new Scatter(this.ctx).centerTextInBubble(l, e, h).y;
      else void 0 !== u && (g = a.config.dataLabels.formatter(u, { ctx: this.ctx, seriesIndex: e, dataPointIndex: h, w: a }));
      this.plotDataLabelsText({ x: o, y: l, text: g, i: e, j: h, parent: c, offsetCorrection: true, dataLabelsConfig: a.config.dataLabels });
    }
    return c;
  } }, { key: "plotDataLabelsText", value: function(t2) {
    var e = this.w, i = new Graphics(this.ctx), s = t2.x, a = t2.y, r = t2.i, n = t2.j, o = t2.text, l = t2.textAnchor, h = t2.parent, c = t2.dataLabelsConfig, d = t2.alwaysDrawDataLabel, u = t2.offsetCorrection;
    if (!(Array.isArray(e.config.dataLabels.enabledOnSeries) && e.config.dataLabels.enabledOnSeries.indexOf(r) < 0)) {
      var g = { x: s, y: a, drawnextLabel: true };
      if (u && (g = this.dataLabelsCorrection(s, a, o, r, n, d, parseInt(c.style.fontSize))), e.globals.zoomed || (s = g.x, a = g.y), g.textRects && (s + g.textRects.width < 10 || s > e.globals.gridWidth + 10) && (o = ""), g.drawnextLabel) {
        var f = i.drawText({ width: 100, height: parseInt(c.style.fontSize), x: s, y: a, foreColor: e.globals.dataLabels.style.colors[r], textAnchor: l || c.textAnchor, text: o, fontSize: c.style.fontSize, fontFamily: c.style.fontFamily });
        if (f.attr({ class: "apexcharts-datalabel", cx: s, cy: a }), c.dropShadow.enabled) {
          var p = c.dropShadow;
          new Filters(this.ctx).dropShadow(f, p);
        }
        h.add(f), void 0 === e.globals.lastDrawnDataLabelsIndexes[r] && (e.globals.lastDrawnDataLabelsIndexes[r] = []), e.globals.lastDrawnDataLabelsIndexes[r].push(n);
      }
    }
  } }]), t;
})();
var Bar = (function() {
  function t(e, i) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w;
    var s = this.w;
    this.barOptions = s.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = s.config.stroke.width, this.isNullValue = false, this.xyRatios = i, null !== this.xyRatios && (this.xRatio = i.xRatio, this.yRatio = i.yRatio, this.invertedXRatio = i.invertedXRatio, this.invertedYRatio = i.invertedYRatio, this.baseLineY = i.baseLineY, this.baseLineInvertedY = i.baseLineInvertedY), this.yaxisIndex = 0, this.seriesLen = 0;
  }
  return _createClass(t, [{ key: "draw", value: function(t2, e) {
    var i = this.w, s = new Graphics(this.ctx), a = new CoreUtils(this.ctx, i);
    t2 = a.getLogSeries(t2), this.series = t2, this.yRatio = a.getLogYRatios(this.yRatio), this.initVariables(t2);
    var r = s.group({ class: "apexcharts-bar-series apexcharts-plot-series" });
    i.config.dataLabels.enabled && this.totalItems > i.config.plotOptions.bar.dataLabels.maxItems && console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering.");
    for (var n = 0, o = 0; n < t2.length; n++, o++) {
      var l, h, c, d, u = void 0, g = void 0, f = void 0, p = void 0, x = [], m = [], b = i.globals.comboCharts ? e[n] : n, v = s.group({ class: "apexcharts-series", rel: n + 1, seriesName: Utils.escapeString(i.globals.seriesNames[b]), "data:realIndex": b });
      this.ctx.series.addCollapsedClassToSeries(v, b), t2[n].length > 0 && (this.visibleI = this.visibleI + 1);
      var y = 0, w = 0, k = 0;
      this.yRatio.length > 1 && (this.yaxisIndex = b), this.isReversed = i.config.yaxis[this.yaxisIndex] && i.config.yaxis[this.yaxisIndex].reversed;
      var A = this.initialPositions();
      p = A.y, w = A.barHeight, h = A.yDivision, d = A.zeroW, f = A.x, k = A.barWidth, l = A.xDivision, c = A.zeroH, this.horizontal || m.push(f + k / 2);
      for (var S = s.group({ class: "apexcharts-datalabels" }), C = 0, L = i.globals.dataPoints; C < i.globals.dataPoints; C++, L--) {
        void 0 === this.series[n][C] || null === t2[n][C] ? this.isNullValue = true : this.isNullValue = false, i.config.stroke.show && (y = this.isNullValue ? 0 : Array.isArray(this.strokeWidth) ? this.strokeWidth[b] : this.strokeWidth);
        var P = null;
        this.isHorizontal ? (P = this.drawBarPaths({ indexes: { i: n, j: C, realIndex: b, bc: o }, barHeight: w, strokeWidth: y, pathTo: u, pathFrom: g, zeroW: d, x: f, y: p, yDivision: h, elSeries: v }), k = this.series[n][C] / this.invertedYRatio) : (P = this.drawColumnPaths({ indexes: { i: n, j: C, realIndex: b, bc: o }, x: f, y: p, xDivision: l, pathTo: u, pathFrom: g, barWidth: k, zeroH: c, strokeWidth: y, elSeries: v }), w = this.series[n][C] / this.yRatio[this.yaxisIndex]), u = P.pathTo, g = P.pathFrom, p = P.y, f = P.x, C > 0 && m.push(f + k / 2), x.push(p);
        var z = this.getPathFillColor(t2, n, C, b);
        v = this.renderSeries({ realIndex: b, pathFill: z, j: C, i: n, pathFrom: g, pathTo: u, strokeWidth: y, elSeries: v, x: f, y: p, series: t2, barHeight: w, barWidth: k, elDataLabelsWrap: S, visibleSeries: this.visibleI, type: "bar" });
      }
      i.globals.seriesXvalues[b] = m, i.globals.seriesYvalues[b] = x, r.add(v);
    }
    return r;
  } }, { key: "getPathFillColor", value: function(t2, e, i, s) {
    var a = this.w, r = new Fill(this.ctx), n = null, o = this.barOptions.distributed ? i : e;
    this.barOptions.colors.ranges.length > 0 && this.barOptions.colors.ranges.map(function(s2) {
      t2[e][i] >= s2.from && t2[e][i] <= s2.to && (n = s2.color);
    });
    return a.config.series[e].data[i] && a.config.series[e].data[i].fillColor && (n = a.config.series[e].data[i].fillColor), r.fillPath({ seriesNumber: this.barOptions.distributed ? o : s, color: n, value: t2[e][i] });
  } }, { key: "renderSeries", value: function(t2) {
    var e = t2.realIndex, i = t2.pathFill, s = t2.lineFill, a = t2.j, r = t2.i, n = t2.pathFrom, o = t2.pathTo, l = t2.strokeWidth, h = t2.elSeries, c = t2.x, d = t2.y, u = t2.series, g = t2.barHeight, f = t2.barWidth, p = t2.elDataLabelsWrap, x = t2.visibleSeries, m = t2.type, b = this.w, v = new Graphics(this.ctx);
    s || (s = this.barOptions.distributed ? b.globals.stroke.colors[a] : b.globals.stroke.colors[e]), b.config.series[r].data[a] && b.config.series[r].data[a].strokeColor && (s = b.config.series[r].data[a].strokeColor), this.isNullValue && (i = "none");
    var y = a / b.config.chart.animations.animateGradually.delay * (b.config.chart.animations.speed / b.globals.dataPoints) / 2.4, w = v.renderPaths({ i: r, j: a, realIndex: e, pathFrom: n, pathTo: o, stroke: s, strokeWidth: l, strokeLineCap: b.config.stroke.lineCap, fill: i, animationDelay: y, initialSpeed: b.config.chart.animations.speed, dataChangeSpeed: b.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(m, "-area") });
    w.attr("clip-path", "url(#gridRectMask".concat(b.globals.cuid, ")")), new Filters(this.ctx).setSelectionFilter(w, e, a), h.add(w);
    var k = this.calculateDataLabelsPos({ x: c, y: d, i: r, j: a, series: u, realIndex: e, barHeight: g, barWidth: f, renderedPath: w, visibleSeries: x });
    return null !== k && p.add(k), h.add(p), h;
  } }, { key: "initVariables", value: function(t2) {
    var e = this.w;
    this.series = t2, this.totalItems = 0, this.seriesLen = 0, this.visibleI = -1, this.visibleItems = 1;
    for (var i = 0; i < t2.length; i++) if (t2[i].length > 0 && (this.seriesLen = this.seriesLen + 1, this.totalItems += t2[i].length), e.globals.isXNumeric) for (var s = 0; s < t2[i].length; s++) e.globals.seriesX[i][s] > e.globals.minX && e.globals.seriesX[i][s] < e.globals.maxX && this.visibleItems++;
    else this.visibleItems = e.globals.dataPoints;
    0 === this.seriesLen && (this.seriesLen = 1);
  } }, { key: "initialPositions", value: function() {
    var t2, e, i, s, a, r, n, o, l = this.w;
    return this.isHorizontal ? (a = (i = l.globals.gridHeight / l.globals.dataPoints) / this.seriesLen, l.globals.isXNumeric && (a = (i = l.globals.gridHeight / this.totalItems) / this.seriesLen), a = a * parseInt(this.barOptions.barHeight) / 100, o = this.baseLineInvertedY + l.globals.padHorizontal + (this.isReversed ? l.globals.gridWidth : 0) - (this.isReversed ? 2 * this.baseLineInvertedY : 0), e = (i - a * this.seriesLen) / 2) : (r = (s = l.globals.gridWidth / this.visibleItems) / this.seriesLen * parseInt(this.barOptions.columnWidth) / 100, l.globals.isXNumeric && (l.globals.minXDiff && (s = l.globals.minXDiff / this.xRatio), r = s / this.seriesLen * parseInt(this.barOptions.columnWidth) / 100), n = l.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? l.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), t2 = l.globals.padHorizontal + (s - r * this.seriesLen) / 2), { x: t2, y: e, yDivision: i, xDivision: s, barHeight: a, barWidth: r, zeroH: n, zeroW: o };
  } }, { key: "drawBarPaths", value: function(t2) {
    var e = t2.indexes, i = t2.barHeight, s = t2.strokeWidth, a = t2.pathTo, r = t2.pathFrom, n = t2.zeroW, o = t2.x, l = t2.y, h = t2.yDivision, c = t2.elSeries, d = this.w, u = new Graphics(this.ctx), g = e.i, f = e.j, p = e.realIndex, x = e.bc;
    d.globals.isXNumeric && (l = (d.globals.seriesX[g][f] - d.globals.minX) / this.invertedXRatio - i);
    var m = l + i * this.visibleI;
    a = u.move(n, m), r = u.move(n, m), d.globals.previousPaths.length > 0 && (r = this.getPathFrom(p, f));
    var b = { barHeight: i, strokeWidth: s, barYPosition: m, x: o = void 0 === this.series[g][f] || null === this.series[g][f] ? n : n + this.series[g][f] / this.invertedYRatio - 2 * (this.isReversed ? this.series[g][f] / this.invertedYRatio : 0), zeroW: n }, v = this.barEndingShape(d, b, this.series, g, f);
    if (a = a + u.line(v.newX, m) + v.path + u.line(n, m + i - s) + u.line(n, m), r = r + u.line(n, m) + v.ending_p_from + u.line(n, m + i - s) + u.line(n, m + i - s) + u.line(n, m), d.globals.isXNumeric || (l += h), this.barOptions.colors.backgroundBarColors.length > 0 && 0 === g) {
      x >= this.barOptions.colors.backgroundBarColors.length && (x = 0);
      var y = this.barOptions.colors.backgroundBarColors[x], w = u.drawRect(0, m - i * this.visibleI, d.globals.gridWidth, i * this.seriesLen, 0, y, this.barOptions.colors.backgroundBarOpacity);
      c.add(w), w.node.classList.add("apexcharts-backgroundBar");
    }
    return { pathTo: a, pathFrom: r, x: o, y: l, barYPosition: m };
  } }, { key: "drawColumnPaths", value: function(t2) {
    var e = t2.indexes, i = t2.x, s = t2.y, a = t2.xDivision, r = t2.pathTo, n = t2.pathFrom, o = t2.barWidth, l = t2.zeroH, h = t2.strokeWidth, c = t2.elSeries, d = this.w, u = new Graphics(this.ctx), g = e.i, f = e.j, p = e.realIndex, x = e.bc, m = i + o * this.visibleI;
    if (d.globals.isXNumeric) {
      var b = g;
      d.globals.seriesX[g].length || (b = d.globals.maxValsInArrayIndex), m = (i = (d.globals.seriesX[b][f] - d.globals.minX) / this.xRatio) + o * this.visibleI - o * this.seriesLen / 2;
    }
    r = u.move(m, l), n = u.move(m, l), d.globals.previousPaths.length > 0 && (n = this.getPathFrom(p, f));
    var v = { barWidth: o, strokeWidth: h, barXPosition: m, y: s = void 0 === this.series[g][f] || null === this.series[g][f] ? l : l - this.series[g][f] / this.yRatio[this.yaxisIndex] + 2 * (this.isReversed ? this.series[g][f] / this.yRatio[this.yaxisIndex] : 0), zeroH: l }, y = this.barEndingShape(d, v, this.series, g, f);
    if (r = r + u.line(m, y.newY) + y.path + u.line(m + o - h, l) + u.line(m - h / 2, l), n = n + u.line(m, l) + y.ending_p_from + u.line(m + o - h, l) + u.line(m + o - h, l) + u.line(m - h / 2, l), d.globals.isXNumeric || (i += a), this.barOptions.colors.backgroundBarColors.length > 0 && 0 === g) {
      x >= this.barOptions.colors.backgroundBarColors.length && (x = 0);
      var w = this.barOptions.colors.backgroundBarColors[x], k = u.drawRect(m - o * this.visibleI, 0, o * this.seriesLen, d.globals.gridHeight, 0, w, this.barOptions.colors.backgroundBarOpacity);
      c.add(k), k.node.classList.add("apexcharts-backgroundBar");
    }
    return { pathTo: r, pathFrom: n, x: i, y: s, barXPosition: m };
  } }, { key: "getPathFrom", value: function(t2, e) {
    for (var i, s = this.w, a = 0; a < s.globals.previousPaths.length; a++) {
      var r = s.globals.previousPaths[a];
      r.paths.length > 0 && parseInt(r.realIndex) === parseInt(t2) && void 0 !== s.globals.previousPaths[a].paths[e] && (i = s.globals.previousPaths[a].paths[e].d);
    }
    return i;
  } }, { key: "calculateDataLabelsPos", value: function(t2) {
    var e = t2.x, i = t2.y, s = t2.i, a = t2.j, r = t2.realIndex, n = t2.series, o = t2.barHeight, l = t2.barWidth, h = t2.visibleSeries, c = t2.renderedPath, d = this.w, u = new Graphics(this.ctx), g = Array.isArray(this.strokeWidth) ? this.strokeWidth[r] : this.strokeWidth, f = e + parseFloat(l * h), p = i + parseFloat(o * h);
    d.globals.isXNumeric && !d.globals.isBarHorizontal && (f = e + parseFloat(l * (h + 1)) / 2, p = i + parseFloat(o * (h + 1)) - g);
    var x = e, m = i, b = {}, v = d.config.dataLabels, y = this.barOptions.dataLabels, w = v.offsetX, k = v.offsetY, A = { width: 0, height: 0 };
    return d.config.dataLabels.enabled && (A = u.getTextRects(d.globals.yLabelFormatters[0](d.globals.maxY), parseInt(v.style.fontSize))), b = this.isHorizontal ? this.calculateBarsDataLabelsPosition({ x: e, y: i, i: s, j: a, renderedPath: c, bcy: p, barHeight: o, barWidth: l, textRects: A, strokeWidth: g, dataLabelsX: x, dataLabelsY: m, barDataLabelsConfig: y, offX: w, offY: k }) : this.calculateColumnsDataLabelsPosition({ x: e, y: i, i: s, j: a, renderedPath: c, realIndex: r, bcx: f, bcy: p, barHeight: o, barWidth: l, textRects: A, strokeWidth: g, dataLabelsY: m, barDataLabelsConfig: y, offX: w, offY: k }), c.attr({ cy: b.bcy, cx: b.bcx, j: a, val: n[s][a], barHeight: o, barWidth: l }), this.drawCalculatedDataLabels({ x: b.dataLabelsX, y: b.dataLabelsY, val: n[s][a], i: r, j: a, barWidth: l, barHeight: o, textRects: A, dataLabelsConfig: v });
  } }, { key: "calculateColumnsDataLabelsPosition", value: function(t2) {
    var e, i = this.w, s = t2.i, a = t2.j, r = t2.y, n = t2.bcx, o = t2.barWidth, l = t2.barHeight, h = t2.textRects, c = t2.dataLabelsY, d = t2.barDataLabelsConfig, u = t2.strokeWidth, g = t2.offX, f = t2.offY, p = i.globals.gridWidth / i.globals.dataPoints;
    n -= u / 2, e = i.globals.isXNumeric ? n - o / 2 + g : n - p + o / 2 + g;
    var x = this.series[s][a] <= 0;
    switch (this.isReversed && (r -= l), d.position) {
      case "center":
        c = x ? r + l / 2 + h.height / 2 + f : r + l / 2 + h.height / 2 - f;
        break;
      case "bottom":
        c = x ? r + l + h.height + u + f : r + l - h.height / 2 + u - f;
        break;
      case "top":
        c = x ? r - h.height / 2 - f : r + h.height + f;
    }
    return i.config.chart.stacked || (c < 0 ? c = 0 + u : c + h.height / 3 > i.globals.gridHeight && (c = i.globals.gridHeight - u)), { bcx: n, bcy: r, dataLabelsX: e, dataLabelsY: c };
  } }, { key: "calculateBarsDataLabelsPosition", value: function(t2) {
    var e = this.w, i = t2.x, s = t2.i, a = t2.j, r = t2.bcy, n = t2.barHeight, o = t2.barWidth, l = t2.textRects, h = t2.dataLabelsX, c = t2.strokeWidth, d = t2.barDataLabelsConfig, u = t2.offX, g = t2.offY, f = r - e.globals.gridHeight / e.globals.dataPoints + n / 2 + l.height / 2 + g - 3, p = this.series[s][a] <= 0;
    switch (this.isReversed && (i += o), d.position) {
      case "center":
        h = p ? i - o / 2 - u : i - o / 2 + u;
        break;
      case "bottom":
        h = p ? i - o - c - Math.round(l.width / 2) - u : i - o + c + Math.round(l.width / 2) + u;
        break;
      case "top":
        h = p ? i - c + Math.round(l.width / 2) - u : i - c - Math.round(l.width / 2) + u;
    }
    return e.config.chart.stacked || (h < 0 ? h = h + l.width + c : h + l.width / 2 > e.globals.gridWidth && (h = e.globals.gridWidth - l.width - c)), { bcx: i, bcy: r, dataLabelsX: h, dataLabelsY: f };
  } }, { key: "drawCalculatedDataLabels", value: function(t2) {
    var e = t2.x, i = t2.y, s = t2.val, a = t2.i, r = t2.j, n = t2.textRects, o = t2.barHeight, l = t2.barWidth, h = t2.dataLabelsConfig, c = this.w, d = new DataLabels(this.ctx), u = new Graphics(this.ctx), g = h.formatter, f = null, p = c.globals.collapsedSeriesIndices.indexOf(a) > -1;
    if (h.enabled && !p) {
      f = u.group({ class: "apexcharts-data-labels" });
      var x = "";
      void 0 !== s && (x = g(s, { seriesIndex: a, dataPointIndex: r, w: c })), 0 === s && c.config.chart.stacked && (x = ""), c.config.chart.stacked && this.barOptions.dataLabels.hideOverflowingLabels && (this.isHorizontal ? ((l = this.series[a][r] / this.yRatio[this.yaxisIndex]) > 0 && n.width / 1.6 > l || l < 0 && n.width / 1.6 < l) && (x = "") : (o = this.series[a][r] / this.yRatio[this.yaxisIndex], n.height / 1.6 > o && (x = "")));
      var m = _objectSpread({}, h);
      this.isHorizontal && s < 0 && ("start" === h.textAnchor ? m.textAnchor = "end" : "end" === h.textAnchor && (m.textAnchor = "start")), d.plotDataLabelsText({ x: e, y: i, text: x, i: a, j: r, parent: f, dataLabelsConfig: m, alwaysDrawDataLabel: true, offsetCorrection: true });
    }
    return f;
  } }, { key: "barEndingShape", value: function(t2, e, i, s, a) {
    var r = new Graphics(this.ctx);
    if (this.isHorizontal) {
      var n = null, o = e.x;
      if (void 0 !== i[s][a] || null !== i[s][a]) {
        var l = i[s][a] < 0, h = e.barHeight / 2 - e.strokeWidth;
        switch (l && (h = -e.barHeight / 2 - e.strokeWidth), t2.config.chart.stacked || "rounded" === this.barOptions.endingShape && (o = e.x - h / 2), this.barOptions.endingShape) {
          case "flat":
            n = r.line(o, e.barYPosition + e.barHeight - e.strokeWidth);
            break;
          case "rounded":
            n = r.quadraticCurve(o + h, e.barYPosition + (e.barHeight - e.strokeWidth) / 2, o, e.barYPosition + e.barHeight - e.strokeWidth);
        }
      }
      return { path: n, ending_p_from: "", newX: o };
    }
    var c = null, d = e.y;
    if (void 0 !== i[s][a] || null !== i[s][a]) {
      var u = i[s][a] < 0, g = e.barWidth / 2 - e.strokeWidth;
      switch (u && (g = -e.barWidth / 2 - e.strokeWidth), t2.config.chart.stacked || "rounded" === this.barOptions.endingShape && (d += g / 2), this.barOptions.endingShape) {
        case "flat":
          c = r.line(e.barXPosition + e.barWidth - e.strokeWidth, d);
          break;
        case "rounded":
          c = r.quadraticCurve(e.barXPosition + (e.barWidth - e.strokeWidth) / 2, d - g, e.barXPosition + e.barWidth - e.strokeWidth, d);
      }
    }
    return { path: c, ending_p_from: "", newY: d };
  } }]), t;
})();
var BarStacked = (function(t) {
  function e() {
    return _classCallCheck(this, e), _possibleConstructorReturn(this, _getPrototypeOf(e).apply(this, arguments));
  }
  return _inherits(e, Bar), _createClass(e, [{ key: "draw", value: function(t2, e2) {
    var i = this.w;
    this.graphics = new Graphics(this.ctx), this.fill = new Fill(this.ctx), this.bar = new Bar(this.ctx, this.xyRatios);
    var s = new CoreUtils(this.ctx, i);
    t2 = s.getLogSeries(t2), this.yRatio = s.getLogYRatios(this.yRatio), this.initVariables(t2), "100%" === i.config.chart.stackType && (t2 = i.globals.seriesPercent.slice()), this.series = t2, this.totalItems = 0, this.prevY = [], this.prevX = [], this.prevYF = [], this.prevXF = [], this.prevYVal = [], this.prevXVal = [], this.xArrj = [], this.xArrjF = [], this.xArrjVal = [], this.yArrj = [], this.yArrjF = [], this.yArrjVal = [];
    for (var a = 0; a < t2.length; a++) t2[a].length > 0 && (this.totalItems += t2[a].length);
    for (var r = this.graphics.group({ class: "apexcharts-bar-series apexcharts-plot-series" }), n = 0, o = 0, l = 0, h = 0; l < t2.length; l++, h++) {
      var c = void 0, d = void 0, u = void 0, g = void 0, f = void 0, p = void 0, x = [], m = [], b = i.globals.comboCharts ? e2[l] : l;
      this.yRatio.length > 1 && (this.yaxisIndex = b), this.isReversed = i.config.yaxis[this.yaxisIndex] && i.config.yaxis[this.yaxisIndex].reversed;
      var v = this.graphics.group({ class: "apexcharts-series", seriesName: Utils.escapeString(i.globals.seriesNames[b]), rel: l + 1, "data:realIndex": b }), y = this.graphics.group({ class: "apexcharts-datalabels" }), w = 0, k = 0, A = 0, S = this.initialPositions(n, o, u, g, f, p);
      o = S.y, k = S.barHeight, g = S.yDivision, p = S.zeroW, n = S.x, A = S.barWidth, u = S.xDivision, f = S.zeroH, this.yArrj = [], this.yArrjF = [], this.yArrjVal = [], this.xArrj = [], this.xArrjF = [], this.xArrjVal = [];
      for (var C = 0; C < i.globals.dataPoints; C++) {
        i.config.stroke.show && (w = this.isNullValue ? 0 : Array.isArray(this.strokeWidth) ? this.strokeWidth[b] : this.strokeWidth);
        var L = null;
        this.isHorizontal ? (L = this.drawBarPaths({ indexes: { i: l, j: C, realIndex: b, bc: h }, barHeight: k, strokeWidth: w, pathTo: c, pathFrom: d, zeroW: p, x: n, y: o, yDivision: g, elSeries: v }), A = this.series[l][C] / this.invertedYRatio) : (L = this.drawColumnPaths({ indexes: { i: l, j: C, realIndex: b, bc: h }, x: n, y: o, xDivision: u, pathTo: c, pathFrom: d, barWidth: A, zeroH: f, strokeWidth: w, elSeries: v }), k = this.series[l][C] / this.yRatio[this.yaxisIndex]), c = L.pathTo, d = L.pathFrom, o = L.y, n = L.x, x.push(n), m.push(o);
        var P = this.bar.getPathFillColor(t2, l, C, b);
        v = this.renderSeries({ realIndex: b, pathFill: P, j: C, i: l, pathFrom: d, pathTo: c, strokeWidth: w, elSeries: v, x: n, y: o, series: t2, barHeight: k, barWidth: A, elDataLabelsWrap: y, type: "bar", visibleSeries: 0 });
      }
      i.globals.seriesXvalues[b] = x, i.globals.seriesYvalues[b] = m, this.prevY.push(this.yArrj), this.prevYF.push(this.yArrjF), this.prevYVal.push(this.yArrjVal), this.prevX.push(this.xArrj), this.prevXF.push(this.xArrjF), this.prevXVal.push(this.xArrjVal), r.add(v);
    }
    return r;
  } }, { key: "initialPositions", value: function(t2, e2, i, s, a, r) {
    var n, o, l = this.w;
    return this.isHorizontal ? (n = (n = s = l.globals.gridHeight / l.globals.dataPoints) * parseInt(l.config.plotOptions.bar.barHeight) / 100, r = this.baseLineInvertedY + l.globals.padHorizontal + (this.isReversed ? l.globals.gridWidth : 0) - (this.isReversed ? 2 * this.baseLineInvertedY : 0), e2 = (s - n) / 2) : (o = i = l.globals.gridWidth / l.globals.dataPoints, o = l.globals.isXNumeric ? (i = l.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth) / 100 : o * parseInt(l.config.plotOptions.bar.columnWidth) / 100, a = this.baseLineY[this.yaxisIndex] + (this.isReversed ? l.globals.gridHeight : 0) - (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), t2 = l.globals.padHorizontal + (i - o) / 2), { x: t2, y: e2, yDivision: s, xDivision: i, barHeight: n, barWidth: o, zeroH: a, zeroW: r };
  } }, { key: "drawBarPaths", value: function(t2) {
    for (var e2, i = t2.indexes, s = t2.barHeight, a = t2.strokeWidth, r = t2.pathTo, n = t2.pathFrom, o = t2.zeroW, l = t2.x, h = t2.y, c = t2.yDivision, d = t2.elSeries, u = this.w, g = h, f = i.i, p = i.j, x = i.realIndex, m = i.bc, b = 0, v = 0; v < this.prevXF.length; v++) b += this.prevXF[v][p];
    if (f > 0) {
      var y = o;
      this.prevXVal[f - 1][p] < 0 ? y = this.series[f][p] >= 0 ? this.prevX[f - 1][p] + b - 2 * (this.isReversed ? b : 0) : this.prevX[f - 1][p] : this.prevXVal[f - 1][p] >= 0 && (y = this.series[f][p] >= 0 ? this.prevX[f - 1][p] : this.prevX[f - 1][p] - b + 2 * (this.isReversed ? b : 0)), e2 = y;
    } else e2 = o;
    l = null === this.series[f][p] ? e2 : e2 + this.series[f][p] / this.invertedYRatio - 2 * (this.isReversed ? this.series[f][p] / this.invertedYRatio : 0);
    var w = { barHeight: s, strokeWidth: a, invertedYRatio: this.invertedYRatio, barYPosition: g, x: l }, k = this.bar.barEndingShape(u, w, this.series, f, p);
    if (this.series.length > 1 && f !== this.endingShapeOnSeriesNumber && (k.path = this.graphics.line(k.newX, g + s - a)), this.xArrj.push(k.newX), this.xArrjF.push(Math.abs(e2 - k.newX)), this.xArrjVal.push(this.series[f][p]), r = this.graphics.move(e2, g), n = this.graphics.move(e2, g), u.globals.previousPaths.length > 0 && (n = this.bar.getPathFrom(x, p, false)), r = r + this.graphics.line(k.newX, g) + k.path + this.graphics.line(e2, g + s - a) + this.graphics.line(e2, g), n = n + this.graphics.line(e2, g) + this.graphics.line(e2, g + s - a) + this.graphics.line(e2, g + s - a) + this.graphics.line(e2, g + s - a) + this.graphics.line(e2, g), u.config.plotOptions.bar.colors.backgroundBarColors.length > 0 && 0 === f) {
      m >= u.config.plotOptions.bar.colors.backgroundBarColors.length && (m = 0);
      var A = u.config.plotOptions.bar.colors.backgroundBarColors[m], S = this.graphics.drawRect(0, g, u.globals.gridWidth, s, 0, A, u.config.plotOptions.bar.colors.backgroundBarOpacity);
      d.add(S), S.node.classList.add("apexcharts-backgroundBar");
    }
    return { pathTo: r, pathFrom: n, x: l, y: h += c };
  } }, { key: "drawColumnPaths", value: function(t2) {
    var e2 = t2.indexes, i = t2.x, s = t2.y, a = t2.xDivision, r = t2.pathTo, n = t2.pathFrom, o = t2.barWidth, l = t2.zeroH, h = t2.strokeWidth, c = t2.elSeries, d = this.w, u = e2.i, g = e2.j, f = e2.realIndex, p = e2.bc;
    if (d.globals.isXNumeric) {
      var x = d.globals.seriesX[u][g];
      x || (x = 0), i = (x - d.globals.minX) / this.xRatio - o / 2;
    }
    for (var m, b = i, v = 0, y = 0; y < this.prevYF.length; y++) v += this.prevYF[y][g];
    if (u > 0 && !d.globals.isXNumeric || u > 0 && d.globals.isXNumeric && d.globals.seriesX[u - 1][g] === d.globals.seriesX[u][g]) {
      var w = this.prevY[u - 1][g];
      m = this.prevYVal[u - 1][g] < 0 ? this.series[u][g] >= 0 ? w - v + 2 * (this.isReversed ? v : 0) : w : this.series[u][g] >= 0 ? w : w + v - 2 * (this.isReversed ? v : 0);
    } else m = d.globals.gridHeight - l;
    s = m - this.series[u][g] / this.yRatio[this.yaxisIndex] + 2 * (this.isReversed ? this.series[u][g] / this.yRatio[this.yaxisIndex] : 0);
    var k = { barWidth: o, strokeWidth: h, yRatio: this.yRatio[this.yaxisIndex], barXPosition: b, y: s }, A = this.bar.barEndingShape(d, k, this.series, u, g);
    if (this.yArrj.push(A.newY), this.yArrjF.push(Math.abs(m - A.newY)), this.yArrjVal.push(this.series[u][g]), r = this.graphics.move(b, m), n = this.graphics.move(b, m), d.globals.previousPaths.length > 0 && (n = this.bar.getPathFrom(f, g, false)), r = r + this.graphics.line(b, A.newY) + A.path + this.graphics.line(b + o - h, m) + this.graphics.line(b - h / 2, m), n = n + this.graphics.line(b, m) + this.graphics.line(b + o - h, m) + this.graphics.line(b + o - h, m) + this.graphics.line(b + o - h, m) + this.graphics.line(b - h / 2, m), d.config.plotOptions.bar.colors.backgroundBarColors.length > 0 && 0 === u) {
      p >= d.config.plotOptions.bar.colors.backgroundBarColors.length && (p = 0);
      var S = d.config.plotOptions.bar.colors.backgroundBarColors[p], C = this.graphics.drawRect(b, 0, o, d.globals.gridHeight, 0, S, d.config.plotOptions.bar.colors.backgroundBarOpacity);
      c.add(C), C.node.classList.add("apexcharts-backgroundBar");
    }
    return i += a, { pathTo: r, pathFrom: n, x: d.globals.isXNumeric ? i - a : i, y: s };
  } }, { key: "checkZeroSeries", value: function(t2) {
    for (var e2 = t2.series, i = this.w, s = 0; s < e2.length; s++) {
      for (var a = 0, r = 0; r < e2[i.globals.maxValsInArrayIndex].length; r++) a += e2[s][r];
      0 === a && this.zeroSerieses.push(s);
    }
    for (var n = e2.length - 1; n >= 0; n--) this.zeroSerieses.indexOf(n) > -1 && n === this.endingShapeOnSeriesNumber && (this.endingShapeOnSeriesNumber -= 1);
  } }]), e;
})();
var CandleStick = (function(t) {
  function e() {
    return _classCallCheck(this, e), _possibleConstructorReturn(this, _getPrototypeOf(e).apply(this, arguments));
  }
  return _inherits(e, Bar), _createClass(e, [{ key: "draw", value: function(t2, e2) {
    var i = this.w, s = new Graphics(this.ctx), a = new Fill(this.ctx);
    this.candlestickOptions = this.w.config.plotOptions.candlestick;
    var r = new CoreUtils(this.ctx, i);
    t2 = r.getLogSeries(t2), this.series = t2, this.yRatio = r.getLogYRatios(this.yRatio), this.initVariables(t2);
    for (var n = s.group({ class: "apexcharts-candlestick-series apexcharts-plot-series" }), o = 0, l = 0; o < t2.length; o++, l++) {
      var h, c, d = void 0, u = void 0, g = void 0, f = void 0, p = [], x = [], m = i.globals.comboCharts ? e2[o] : o, b = s.group({ class: "apexcharts-series", seriesName: Utils.escapeString(i.globals.seriesNames[m]), rel: o + 1, "data:realIndex": m });
      t2[o].length > 0 && (this.visibleI = this.visibleI + 1);
      var v, y, w = 0;
      this.yRatio.length > 1 && (this.yaxisIndex = m);
      var k = this.initialPositions();
      f = k.y, v = k.barHeight, g = k.x, y = k.barWidth, h = k.xDivision, c = k.zeroH, x.push(g + y / 2);
      for (var A = s.group({ class: "apexcharts-datalabels" }), S = 0, C = i.globals.dataPoints; S < i.globals.dataPoints; S++, C--) {
        void 0 === this.series[o][S] || null === t2[o][S] ? this.isNullValue = true : this.isNullValue = false, i.config.stroke.show && (w = this.isNullValue ? 0 : Array.isArray(this.strokeWidth) ? this.strokeWidth[m] : this.strokeWidth);
        var L, P = this.drawCandleStickPaths({ indexes: { i: o, j: S, realIndex: m, bc: l }, x: g, y: f, xDivision: h, pathTo: d, pathFrom: u, barWidth: y, zeroH: c, strokeWidth: w, elSeries: b });
        d = P.pathTo, u = P.pathFrom, f = P.y, g = P.x, L = P.color, S > 0 && x.push(g + y / 2), p.push(f);
        var z = a.fillPath({ seriesNumber: m, color: L, value: t2[o][S] }), T = this.candlestickOptions.wick.useFillColor ? L : void 0;
        b = this.renderSeries({ realIndex: m, pathFill: z, lineFill: T, j: S, i: o, pathFrom: u, pathTo: d, strokeWidth: w, elSeries: b, x: g, y: f, series: t2, barHeight: v, barWidth: y, elDataLabelsWrap: A, visibleSeries: this.visibleI, type: "candlestick" });
      }
      i.globals.seriesXvalues[m] = x, i.globals.seriesYvalues[m] = p, n.add(b);
    }
    return n;
  } }, { key: "drawCandleStickPaths", value: function(t2) {
    var e2 = t2.indexes, i = t2.x, s = (t2.y, t2.xDivision), a = t2.pathTo, r = t2.pathFrom, n = t2.barWidth, o = t2.zeroH, l = t2.strokeWidth, h = this.w, c = new Graphics(this.ctx), d = e2.i, u = e2.j, g = true, f = h.config.plotOptions.candlestick.colors.upward, p = h.config.plotOptions.candlestick.colors.downward, x = this.yRatio[this.yaxisIndex], m = e2.realIndex, b = this.getOHLCValue(m, u), v = o, y = o;
    b.o > b.c && (g = false);
    var w = Math.min(b.o, b.c), k = Math.max(b.o, b.c);
    h.globals.isXNumeric && (i = (h.globals.seriesX[d][u] - h.globals.minX) / this.xRatio - n / 2);
    var A = i + n * this.visibleI;
    return void 0 === this.series[d][u] || null === this.series[d][u] ? w = o : (w = o - w / x, k = o - k / x, v = o - b.h / x, y = o - b.l / x), c.move(A, o), r = c.move(A, w), h.globals.previousPaths.length > 0 && (r = this.getPathFrom(m, u, true)), a = c.move(A, k) + c.line(A + n / 2, k) + c.line(A + n / 2, v) + c.line(A + n / 2, k) + c.line(A + n, k) + c.line(A + n, w) + c.line(A + n / 2, w) + c.line(A + n / 2, y) + c.line(A + n / 2, w) + c.line(A, w) + c.line(A, k - l / 2), r += c.move(A, w), h.globals.isXNumeric || (i += s), { pathTo: a, pathFrom: r, x: i, y: k, barXPosition: A, color: g ? f : p };
  } }, { key: "getOHLCValue", value: function(t2, e2) {
    var i = this.w;
    return { o: i.globals.seriesCandleO[t2][e2], h: i.globals.seriesCandleH[t2][e2], l: i.globals.seriesCandleL[t2][e2], c: i.globals.seriesCandleC[t2][e2] };
  } }]), e;
})();
var Crosshairs = (function() {
  function t(e) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w;
  }
  return _createClass(t, [{ key: "drawXCrosshairs", value: function() {
    var t2 = this.w, e = new Graphics(this.ctx), i = new Filters(this.ctx), s = t2.config.xaxis.crosshairs.fill.gradient, a = t2.config.xaxis.crosshairs.dropShadow, r = t2.config.xaxis.crosshairs.fill.type, n = s.colorFrom, o = s.colorTo, l = s.opacityFrom, h = s.opacityTo, c = s.stops, d = a.enabled, u = a.left, g = a.top, f = a.blur, p = a.color, x = a.opacity, m = t2.config.xaxis.crosshairs.fill.color;
    if (t2.config.xaxis.crosshairs.show) {
      "gradient" === r && (m = e.drawGradient("vertical", n, o, l, h, null, c, null));
      var b = e.drawRect();
      1 === t2.config.xaxis.crosshairs.width && (b = e.drawLine()), b.attr({ class: "apexcharts-xcrosshairs", x: 0, y: 0, y2: t2.globals.gridHeight, width: Utils.isNumber(t2.config.xaxis.crosshairs.width) ? t2.config.xaxis.crosshairs.width : 0, height: t2.globals.gridHeight, fill: m, filter: "none", "fill-opacity": t2.config.xaxis.crosshairs.opacity, stroke: t2.config.xaxis.crosshairs.stroke.color, "stroke-width": t2.config.xaxis.crosshairs.stroke.width, "stroke-dasharray": t2.config.xaxis.crosshairs.stroke.dashArray }), d && (b = i.dropShadow(b, { left: u, top: g, blur: f, color: p, opacity: x })), t2.globals.dom.elGraphical.add(b);
    }
  } }, { key: "drawYCrosshairs", value: function() {
    var t2 = this.w, e = new Graphics(this.ctx), i = t2.config.yaxis[0].crosshairs;
    if (t2.config.yaxis[0].crosshairs.show) {
      var s = e.drawLine(0, 0, t2.globals.gridWidth, 0, i.stroke.color, i.stroke.dashArray, i.stroke.width);
      s.attr({ class: "apexcharts-ycrosshairs" }), t2.globals.dom.elGraphical.add(s);
    }
    var a = e.drawLine(0, 0, t2.globals.gridWidth, 0, i.stroke.color, 0, 0);
    a.attr({ class: "apexcharts-ycrosshairs-hidden" }), t2.globals.dom.elGraphical.add(a);
  } }]), t;
})();
var HeatMap = (function() {
  function t(e, i) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.xRatio = i.xRatio, this.yRatio = i.yRatio, this.negRange = false, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.width;
  }
  return _createClass(t, [{ key: "draw", value: function(t2) {
    var e = this.w, i = new Graphics(this.ctx), s = i.group({ class: "apexcharts-heatmap" });
    s.attr("clip-path", "url(#gridRectMask".concat(e.globals.cuid, ")"));
    var a = e.globals.gridWidth / e.globals.dataPoints, r = e.globals.gridHeight / e.globals.series.length, n = 0, o = false;
    this.checkColorRange();
    var l = t2.slice();
    e.config.yaxis[0].reversed && (o = true, l.reverse());
    for (var h = o ? 0 : l.length - 1; o ? h < l.length : h >= 0; o ? h++ : h--) {
      var c = i.group({ class: "apexcharts-series apexcharts-heatmap-series", seriesName: Utils.escapeString(e.globals.seriesNames[h]), rel: h + 1, "data:realIndex": h });
      if (e.config.chart.dropShadow.enabled) {
        var d = e.config.chart.dropShadow;
        new Filters(this.ctx).dropShadow(c, d, h);
      }
      for (var u = 0, g = 0; g < l[h].length; g++) {
        var f = 1, p = this.determineHeatColor(h, g);
        if (e.globals.hasNegs || this.negRange) {
          var x = e.config.plotOptions.heatmap.shadeIntensity;
          f = e.config.plotOptions.heatmap.reverseNegativeShade ? p.percent < 0 ? p.percent / 100 * (1.25 * x) : (1 - p.percent / 100) * (1.25 * x) : p.percent < 0 ? 1 - (1 + p.percent / 100) * x : (1 - p.percent / 100) * x;
        } else f = 1 - p.percent / 100;
        var m = p.color;
        if (e.config.plotOptions.heatmap.enableShades) {
          var b = new Utils();
          m = Utils.hexToRgba(b.shadeColor(f, p.color), e.config.fill.opacity);
        }
        var v = this.rectRadius, y = i.drawRect(u, n, a, r, v);
        if (y.attr({ cx: u, cy: n }), y.node.classList.add("apexcharts-heatmap-rect"), c.add(y), y.attr({ fill: m, i: h, index: h, j: g, val: l[h][g], "stroke-width": this.strokeWidth, stroke: e.globals.stroke.colors[0], color: m }), y.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this, y)), y.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this, y)), y.node.addEventListener("mousedown", i.pathMouseDown.bind(this, y)), e.config.chart.animations.enabled && !e.globals.dataChanged) {
          var w = 1;
          e.globals.resized || (w = e.config.chart.animations.speed), this.animateHeatMap(y, u, n, a, r, w);
        }
        if (e.globals.dataChanged) {
          var k = 1;
          if (this.dynamicAnim.enabled && e.globals.shouldAnimate) {
            k = this.dynamicAnim.speed;
            var A = e.globals.previousPaths[h] && e.globals.previousPaths[h][g] && e.globals.previousPaths[h][g].color;
            A || (A = "rgba(255, 255, 255, 0)"), this.animateHeatColor(y, Utils.isColorHex(A) ? A : Utils.rgb2hex(A), Utils.isColorHex(m) ? m : Utils.rgb2hex(m), k);
          }
        }
        var S = this.calculateHeatmapDataLabels({ x: u, y: n, i: h, j: g, series: l, rectHeight: r, rectWidth: a });
        null !== S && c.add(S), u += a;
      }
      n += r, s.add(c);
    }
    var C = e.globals.yAxisScale[0].result.slice();
    e.config.yaxis[0].reversed ? C.unshift("") : C.push(""), e.globals.yAxisScale[0].result = C;
    var L = e.globals.gridHeight / e.globals.series.length;
    return e.config.yaxis[0].labels.offsetY = -L / 2, s;
  } }, { key: "checkColorRange", value: function() {
    var t2 = this, e = this.w.config.plotOptions.heatmap;
    e.colorScale.ranges.length > 0 && e.colorScale.ranges.map(function(e2, i) {
      e2.from < 0 && (t2.negRange = true);
    });
  } }, { key: "determineHeatColor", value: function(t2, e) {
    var i = this.w, s = i.globals.series[t2][e], a = i.config.plotOptions.heatmap, r = a.colorScale.inverse ? e : t2, n = i.globals.colors[r], o = Math.min.apply(Math, _toConsumableArray(i.globals.series[t2])), l = Math.max.apply(Math, _toConsumableArray(i.globals.series[t2]));
    a.distributed || (o = i.globals.minY, l = i.globals.maxY), void 0 !== a.colorScale.min && (o = a.colorScale.min < i.globals.minY ? a.colorScale.min : i.globals.minY, l = a.colorScale.max > i.globals.maxY ? a.colorScale.max : i.globals.maxY);
    var h = Math.abs(l) + Math.abs(o), c = 100 * s / (0 === h ? h - 1e-6 : h);
    a.colorScale.ranges.length > 0 && a.colorScale.ranges.map(function(t3, e2) {
      if (s >= t3.from && s <= t3.to) {
        n = t3.color, o = t3.from, l = t3.to;
        var i2 = Math.abs(l) + Math.abs(o);
        c = 100 * s / (0 === i2 ? i2 - 1e-6 : i2);
      }
    });
    return { color: n, percent: c };
  } }, { key: "calculateHeatmapDataLabels", value: function(t2) {
    var e = t2.x, i = t2.y, s = t2.i, a = t2.j, r = (t2.series, t2.rectHeight), n = t2.rectWidth, o = this.w, l = o.config.dataLabels, h = new Graphics(this.ctx), c = new DataLabels(this.ctx), d = l.formatter, u = null;
    if (l.enabled) {
      u = h.group({ class: "apexcharts-data-labels" });
      var g = l.offsetX, f = l.offsetY, p = e + n / 2 + g, x = i + r / 2 + parseInt(l.style.fontSize) / 3 + f, m = d(o.globals.series[s][a], { seriesIndex: s, dataPointIndex: a, w: o });
      c.plotDataLabelsText({ x: p, y: x, text: m, i: s, j: a, parent: u, dataLabelsConfig: l });
    }
    return u;
  } }, { key: "animateHeatMap", value: function(t2, e, i, s, a, r) {
    var n = new Animations(this.ctx);
    n.animateRect(t2, { x: e + s / 2, y: i + a / 2, width: 0, height: 0 }, { x: e, y: i, width: s, height: a }, r, function() {
      n.animationCompleted();
    });
  } }, { key: "animateHeatColor", value: function(t2, e, i, s) {
    t2.attr({ fill: e }).animate(s).attr({ fill: i });
  } }]), t;
})();
var Pie = (function() {
  function t(e) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels;
    var i = this.w;
    this.lineColorArr = void 0 !== i.globals.stroke.colors ? i.globals.stroke.colors : i.globals.colors, this.defaultSize = i.globals.svgHeight < i.globals.svgWidth ? i.globals.svgHeight - 35 : i.globals.gridWidth, this.centerY = this.defaultSize / 2, this.centerX = i.globals.gridWidth / 2, this.fullAngle = 360, i.globals.radialSize = this.defaultSize / 2.05 - i.config.stroke.width - i.config.chart.dropShadow.blur, void 0 !== i.config.plotOptions.pie.size && (i.globals.radialSize = i.config.plotOptions.pie.size), this.donutSize = i.globals.radialSize * parseInt(i.config.plotOptions.pie.donut.size) / 100, this.sliceLabels = [], this.prevSectorAngleArr = [];
  }
  return _createClass(t, [{ key: "draw", value: function(t2) {
    var e = this.w, i = new Graphics(this.ctx), s = i.group({ class: "apexcharts-pie" });
    if (e.globals.noData) return s;
    for (var a = 0, r = 0; r < t2.length; r++) a += Utils.negToZero(t2[r]);
    var n = [], o = i.group();
    0 === a && (a = 1e-5);
    for (var l = 0; l < t2.length; l++) {
      var h = this.fullAngle * Utils.negToZero(t2[l]) / a;
      n.push(h);
    }
    if (e.globals.dataChanged) {
      for (var c, d = 0, u = 0; u < e.globals.previousPaths.length; u++) d += Utils.negToZero(e.globals.previousPaths[u]);
      for (var g = 0; g < e.globals.previousPaths.length; g++) c = this.fullAngle * Utils.negToZero(e.globals.previousPaths[g]) / d, this.prevSectorAngleArr.push(c);
    }
    this.donutSize < 0 && (this.donutSize = 0);
    var f = e.config.plotOptions.pie.customScale, p = e.globals.gridWidth / 2, x = e.globals.gridHeight / 2, m = p - e.globals.gridWidth / 2 * f, b = x - e.globals.gridHeight / 2 * f;
    if ("donut" === e.config.chart.type) {
      var v = i.drawCircle(this.donutSize);
      v.attr({ cx: this.centerX, cy: this.centerY, fill: e.config.plotOptions.pie.donut.background }), o.add(v);
    }
    var y = this.drawArcs(n, t2);
    if (this.sliceLabels.forEach(function(t3) {
      y.add(t3);
    }), o.attr({ transform: "translate(".concat(m, ", ").concat(b - 5, ") scale(").concat(f, ")") }), s.attr({ "data:innerTranslateX": m, "data:innerTranslateY": b - 25 }), o.add(y), s.add(o), this.donutDataLabels.show) {
      var w = this.renderInnerDataLabels(this.donutDataLabels, { hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show, translateX: m, translateY: b });
      s.add(w);
    }
    return s;
  } }, { key: "drawArcs", value: function(t2, e) {
    var i = this.w, s = new Filters(this.ctx), a = new Graphics(this.ctx), r = new Fill(this.ctx), n = a.group({ class: "apexcharts-slices" }), o = 0, l = 0, h = 0, c = 0;
    this.strokeWidth = i.config.stroke.show ? i.config.stroke.width : 0;
    for (var d = 0; d < t2.length; d++) {
      var u = a.group({ class: "apexcharts-series apexcharts-pie-series", seriesName: Utils.escapeString(i.globals.seriesNames[d]), rel: d + 1, "data:realIndex": d });
      n.add(u), l = c, h = (o = h) + t2[d], c = l + this.prevSectorAngleArr[d];
      var g = h - o, f = r.fillPath({ seriesNumber: d, size: i.globals.radialSize, value: e[d] }), p = this.getChangedPath(l, c), x = a.drawPath({ d: p, stroke: this.lineColorArr instanceof Array ? this.lineColorArr[d] : this.lineColorArr, strokeWidth: this.strokeWidth, fill: f, fillOpacity: i.config.fill.opacity, classes: "apexcharts-pie-area apexcharts-".concat(i.config.chart.type, "-slice-").concat(d) });
      if (x.attr({ index: 0, j: d }), i.config.chart.dropShadow.enabled) {
        var m = i.config.chart.dropShadow;
        s.dropShadow(x, m, d);
      }
      this.addListeners(x, this.donutDataLabels), Graphics.setAttrs(x.node, { "data:angle": g, "data:startAngle": o, "data:strokeWidth": this.strokeWidth, "data:value": e[d] });
      var b = { x: 0, y: 0 };
      "pie" === i.config.chart.type ? b = Utils.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize / 1.25 + i.config.plotOptions.pie.dataLabels.offset, o + (h - o) / 2) : "donut" === i.config.chart.type && (b = Utils.polarToCartesian(this.centerX, this.centerY, (i.globals.radialSize + this.donutSize) / 2 + i.config.plotOptions.pie.dataLabels.offset, o + (h - o) / 2)), u.add(x);
      var v = 0;
      if (!this.initialAnim || i.globals.resized || i.globals.dataChanged ? this.animBeginArr.push(0) : (v = (h - o) / this.fullAngle * i.config.chart.animations.speed, this.animDur = v + this.animDur, this.animBeginArr.push(this.animDur)), this.dynamicAnim && i.globals.dataChanged ? this.animatePaths(x, { size: i.globals.radialSize, endAngle: h, startAngle: o, prevStartAngle: l, prevEndAngle: c, animateStartingPos: true, i: d, animBeginArr: this.animBeginArr, dur: i.config.chart.animations.dynamicAnimation.speed }) : this.animatePaths(x, { size: i.globals.radialSize, endAngle: h, startAngle: o, i: d, totalItems: t2.length - 1, animBeginArr: this.animBeginArr, dur: v }), i.config.plotOptions.pie.expandOnClick && x.click(this.pieClicked.bind(this, d)), i.config.dataLabels.enabled) {
        var y = b.x, w = b.y, k = 100 * (h - o) / 360 + "%";
        if (0 !== g && i.config.plotOptions.pie.dataLabels.minAngleToShowLabel < t2[d]) {
          var A = i.config.dataLabels.formatter;
          void 0 !== A && (k = A(i.globals.seriesPercent[d][0], { seriesIndex: d, w: i }));
          var S = i.globals.dataLabels.style.colors[d], C = a.drawText({ x: y, y: w, text: k, textAnchor: "middle", fontSize: i.config.dataLabels.style.fontSize, fontFamily: i.config.dataLabels.style.fontFamily, foreColor: S });
          if (i.config.dataLabels.dropShadow.enabled) {
            var L = i.config.dataLabels.dropShadow;
            new Filters(this.ctx).dropShadow(C, L);
          }
          C.node.classList.add("apexcharts-pie-label"), i.config.chart.animations.animate && false === i.globals.resized && (C.node.classList.add("apexcharts-pie-label-delay"), C.node.style.animationDelay = i.config.chart.animations.speed / 940 + "s"), this.sliceLabels.push(C);
        }
      }
    }
    return n;
  } }, { key: "addListeners", value: function(t2, e) {
    var i = new Graphics(this.ctx);
    t2.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this, t2)), t2.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, t2.node, e)), t2.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this, t2)), t2.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, t2.node, e)), t2.node.addEventListener("mousedown", i.pathMouseDown.bind(this, t2)), t2.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, t2.node, e));
  } }, { key: "animatePaths", value: function(t2, e) {
    var i = this.w, s = e.endAngle - e.startAngle, a = s, r = e.startAngle, n = e.startAngle;
    void 0 !== e.prevStartAngle && void 0 !== e.prevEndAngle && (r = e.prevEndAngle, a = e.prevEndAngle - e.prevStartAngle), e.i === i.config.series.length - 1 && (s + n > this.fullAngle ? e.endAngle = e.endAngle - (s + n) : s + n < this.fullAngle && (e.endAngle = e.endAngle + (this.fullAngle - (s + n)))), s === this.fullAngle && (s = this.fullAngle - 0.01), this.animateArc(t2, r, n, s, a, e);
  } }, { key: "animateArc", value: function(t2, e, i, s, a, r) {
    var n, o = this, l = this.w, h = new Animations(this.ctx), c = r.size;
    (isNaN(e) || isNaN(a)) && (e = i, a = s, r.dur = 0);
    var d = s, u = i, g = e - i;
    l.globals.dataChanged && r.shouldSetPrevPaths && (n = o.getPiePath({ me: o, startAngle: u, angle: a, size: c }), t2.attr({ d: n })), 0 !== r.dur ? t2.animate(r.dur, l.globals.easing, r.animBeginArr[r.i]).afterAll(function() {
      "pie" !== l.config.chart.type && "donut" !== l.config.chart.type || this.animate(300).attr({ "stroke-width": l.config.stroke.width }), r.i === l.config.series.length - 1 && h.animationCompleted();
    }).during(function(l2) {
      d = g + (s - g) * l2, r.animateStartingPos && (d = a + (s - a) * l2, u = e - a + (i - (e - a)) * l2), n = o.getPiePath({ me: o, startAngle: u, angle: d, size: c }), t2.node.setAttribute("data:pathOrig", n), t2.attr({ d: n });
    }) : (n = o.getPiePath({ me: o, startAngle: u, angle: s, size: c }), r.isTrack || (l.globals.animationEnded = true), t2.node.setAttribute("data:pathOrig", n), t2.attr({ d: n }));
  } }, { key: "pieClicked", value: function(t2) {
    var e, i = this.w, s = this.w.globals.radialSize + 4, a = i.globals.dom.Paper.select(".apexcharts-".concat(i.config.chart.type.toLowerCase(), "-slice-").concat(t2)).members[0], r = a.attr("d");
    if ("true" !== a.attr("data:pieClicked")) {
      var n = i.globals.dom.baseEl.querySelectorAll(".apexcharts-pie-area");
      Array.prototype.forEach.call(n, function(t3) {
        t3.setAttribute("data:pieClicked", "false");
        var e2 = t3.getAttribute("data:pathOrig");
        t3.setAttribute("d", e2);
      }), a.attr("data:pieClicked", "true");
      var o = parseInt(a.attr("data:startAngle")), l = parseInt(a.attr("data:angle"));
      e = this.getPiePath({ me: this, startAngle: o, angle: l, size: s }), 360 !== l && a.plot(e).animate(1).plot(r).animate(100).plot(e);
    } else {
      a.attr({ "data:pieClicked": "false" }), this.revertDataLabelsInner(a.node, this.donutDataLabels);
      var h = a.attr("data:pathOrig");
      a.attr({ d: h });
    }
  } }, { key: "getChangedPath", value: function(t2, e) {
    var i = "";
    return this.dynamicAnim && this.w.globals.dataChanged && (i = this.getPiePath({ me: this, startAngle: t2, angle: e - t2, size: this.size })), i;
  } }, { key: "getPiePath", value: function(t2) {
    var e = t2.me, i = t2.startAngle, s = t2.angle, a = t2.size, r = this.w, n = i, o = Math.PI * (n - 90) / 180, l = s + i;
    Math.ceil(l) >= 360 && (l = 359.99);
    var h = Math.PI * (l - 90) / 180, c = e.centerX + a * Math.cos(o), d = e.centerY + a * Math.sin(o), u = e.centerX + a * Math.cos(h), g = e.centerY + a * Math.sin(h), f = Utils.polarToCartesian(e.centerX, e.centerY, e.donutSize, l), p = Utils.polarToCartesian(e.centerX, e.centerY, e.donutSize, n), x = s > 180 ? 1 : 0;
    return "donut" === r.config.chart.type ? ["M", c, d, "A", a, a, 0, x, 1, u, g, "L", f.x, f.y, "A", e.donutSize, e.donutSize, 0, x, 0, p.x, p.y, "L", c, d, "z"].join(" ") : "pie" === r.config.chart.type ? ["M", c, d, "A", a, a, 0, x, 1, u, g, "L", e.centerX, e.centerY, "L", c, d].join(" ") : ["M", c, d, "A", a, a, 0, x, 1, u, g].join(" ");
  } }, { key: "renderInnerDataLabels", value: function(t2, e) {
    var i = this.w, s = new Graphics(this.ctx), a = s.group({ class: "apexcharts-datalabels-group", transform: "translate(".concat(e.translateX ? e.translateX : 0, ", ").concat(e.translateY ? e.translateY : 0, ")") }), r = t2.total.show;
    a.node.style.opacity = e.opacity;
    var n, o, l = e.centerX, h = e.centerY;
    n = void 0 === t2.name.color ? i.globals.colors[0] : t2.name.color, o = void 0 === t2.value.color ? i.config.chart.foreColor : t2.value.color;
    var c = t2.value.formatter, d = "", u = "";
    if (r ? (n = t2.total.color, u = t2.total.label, d = t2.total.formatter(i)) : 1 === i.globals.series.length && (d = c(i.globals.series[0], i), u = i.globals.seriesNames[0]), t2.name.show) {
      var g = s.drawText({ x: l, y: h + parseInt(t2.name.offsetY), text: u, textAnchor: "middle", foreColor: n, fontSize: t2.name.fontSize, fontFamily: t2.name.fontFamily });
      g.node.classList.add("apexcharts-datalabel-label"), a.add(g);
    }
    if (t2.value.show) {
      var f = t2.name.show ? parseInt(t2.value.offsetY) + 16 : t2.value.offsetY, p = s.drawText({ x: l, y: h + f, text: d, textAnchor: "middle", foreColor: o, fontSize: t2.value.fontSize, fontFamily: t2.value.fontFamily });
      p.node.classList.add("apexcharts-datalabel-value"), a.add(p);
    }
    return a;
  } }, { key: "printInnerLabels", value: function(t2, e, i, s) {
    var a, r = this.w;
    s ? a = void 0 === t2.name.color ? r.globals.colors[parseInt(s.parentNode.getAttribute("rel")) - 1] : t2.name.color : r.globals.series.length > 1 && t2.total.show && (a = t2.total.color);
    var n = r.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"), o = r.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
    i = (0, t2.value.formatter)(i, r), s || "function" != typeof t2.total.formatter || (i = t2.total.formatter(r)), null !== n && (n.textContent = e), null !== o && (o.textContent = i), null !== n && (n.style.fill = a);
  } }, { key: "printDataLabelsInner", value: function(t2, e) {
    var i = this.w, s = t2.getAttribute("data:value"), a = i.globals.seriesNames[parseInt(t2.parentNode.getAttribute("rel")) - 1];
    i.globals.series.length > 1 && this.printInnerLabels(e, a, s, t2);
    var r = i.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
    null !== r && (r.style.opacity = 1);
  } }, { key: "revertDataLabelsInner", value: function(e, i, s) {
    var a = this, r = this.w, n = r.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
    if (i.total.show && r.globals.series.length > 1) {
      new t(this.ctx).printInnerLabels(i, i.total.label, i.total.formatter(r));
    } else {
      var o = document.querySelectorAll(".apexcharts-pie-area"), l = false;
      if (Array.prototype.forEach.call(o, function(t2) {
        "true" === t2.getAttribute("data:pieClicked") && (l = true, a.printDataLabelsInner(t2, i));
      }), !l) if (r.globals.selectedDataPoints.length && r.globals.series.length > 1) if (r.globals.selectedDataPoints[0].length > 0) {
        var h = r.globals.selectedDataPoints[0], c = r.globals.dom.baseEl.querySelector(".apexcharts-".concat(r.config.chart.type.toLowerCase(), "-slice-").concat(h));
        this.printDataLabelsInner(c, i);
      } else n && r.globals.selectedDataPoints.length && 0 === r.globals.selectedDataPoints[0].length && (n.style.opacity = 0);
      else n && r.globals.series.length > 1 && (n.style.opacity = 0);
    }
  } }]), t;
})();
var Radar = (function() {
  function t(e) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0;
    var i = this.w;
    this.graphics = new Graphics(this.ctx), this.lineColorArr = void 0 !== i.globals.stroke.colors ? i.globals.stroke.colors : i.globals.colors, this.defaultSize = i.globals.svgHeight < i.globals.svgWidth ? i.globals.svgHeight - 35 : i.globals.gridWidth, this.maxValue = this.w.globals.maxY, this.polygons = i.config.plotOptions.radar.polygons, this.maxLabelWidth = 20;
    var s = i.globals.labels.slice().sort(function(t2, e2) {
      return e2.length - t2.length;
    })[0], a = this.graphics.getTextRects(s, i.config.dataLabels.style.fontSize);
    this.size = this.defaultSize / 2.1 - i.config.stroke.width - i.config.chart.dropShadow.blur - a.width / 1.75, void 0 !== i.config.plotOptions.radar.size && (this.size = i.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = [];
  }
  return _createClass(t, [{ key: "draw", value: function(t2) {
    var e = this, i = this.w, s = new Fill(this.ctx), a = [];
    t2.length && (this.dataPointsLen = t2[i.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen;
    var r = i.globals.gridWidth / 2, n = i.globals.gridHeight / 2, o = this.graphics.group({ class: "apexcharts-radar-series", "data:innerTranslateX": r, "data:innerTranslateY": n - 25, transform: "translate(".concat(r || 0, ", ").concat(n || 0, ")") }), l = [], h = null;
    if (this.yaxisLabels = this.graphics.group({ class: "apexcharts-yaxis" }), t2.forEach(function(t3, r2) {
      var n2 = e.graphics.group().attr({ class: "apexcharts-series", seriesName: Utils.escapeString(i.globals.seriesNames[r2]), rel: r2 + 1, "data:realIndex": r2 });
      e.dataRadiusOfPercent[r2] = [], e.dataRadius[r2] = [], e.angleArr[r2] = [], t3.forEach(function(t4, i2) {
        e.dataRadiusOfPercent[r2][i2] = t4 / e.maxValue, e.dataRadius[r2][i2] = e.dataRadiusOfPercent[r2][i2] * e.size, e.angleArr[r2][i2] = i2 * e.disAngle;
      }), l = e.getDataPointsPos(e.dataRadius[r2], e.angleArr[r2]);
      var o2 = e.createPaths(l, { x: 0, y: 0 });
      h = e.graphics.group({ class: "apexcharts-series-markers-wrap hidden" }), i.globals.delayedElements.push({ el: h.node, index: r2 });
      var c2 = { i: r2, realIndex: r2, animationDelay: r2, initialSpeed: i.config.chart.animations.speed, dataChangeSpeed: i.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-radar", shouldClipToGrid: false, bindEventsOnPaths: false, stroke: i.globals.stroke.colors[r2], strokeLineCap: i.config.stroke.lineCap }, d = null;
      i.globals.previousPaths.length > 0 && (d = e.getPathFrom(r2));
      for (var u = 0; u < o2.linePathsTo.length; u++) {
        var g = e.graphics.renderPaths(_objectSpread({}, c2, { pathFrom: null === d ? o2.linePathsFrom[u] : d, pathTo: o2.linePathsTo[u], strokeWidth: Array.isArray(i.config.stroke.width) ? i.config.stroke.width[r2] : i.config.stroke.width, fill: "none", drawShadow: false }));
        n2.add(g);
        var f = s.fillPath({ seriesNumber: r2 }), p = e.graphics.renderPaths(_objectSpread({}, c2, { pathFrom: null === d ? o2.areaPathsFrom[u] : d, pathTo: o2.areaPathsTo[u], strokeWidth: 0, fill: f, drawShadow: false }));
        if (i.config.chart.dropShadow.enabled) {
          var x = new Filters(e.ctx), m = i.config.chart.dropShadow;
          x.dropShadow(p, Object.assign({}, m, { noUserSpaceOnUse: true }), r2);
        }
        n2.add(p);
      }
      t3.forEach(function(t4, i2) {
        var s2 = new Markers(e.ctx).getMarkerConfig("apexcharts-marker", r2, i2), a2 = e.graphics.drawMarker(l[i2].x, l[i2].y, s2);
        a2.attr("rel", i2), a2.attr("j", i2), a2.attr("index", r2), a2.node.setAttribute("default-marker-size", s2.pSize);
        var o3 = e.graphics.group({ class: "apexcharts-series-markers" });
        o3 && o3.add(a2), h.add(o3), n2.add(h);
      }), a.push(n2);
    }), this.drawPolygons({ parent: o }), i.config.dataLabels.enabled) {
      var c = this.drawLabels();
      o.add(c);
    }
    return o.add(this.yaxisLabels), a.forEach(function(t3) {
      o.add(t3);
    }), o;
  } }, { key: "drawPolygons", value: function(t2) {
    for (var e = this, i = this.w, s = t2.parent, a = i.globals.yAxisScale[0].result.reverse(), r = a.length, n = [], o = this.size / (r - 1), l = 0; l < r; l++) n[l] = o * l;
    n.reverse();
    var h = [], c = [];
    n.forEach(function(t3, i2) {
      var s2 = e.getPolygonPos(t3), a2 = "";
      s2.forEach(function(t4, s3) {
        if (0 === i2) {
          var r2 = e.graphics.drawLine(t4.x, t4.y, 0, 0, Array.isArray(e.polygons.connectorColors) ? e.polygons.connectorColors[s3] : e.polygons.connectorColors);
          c.push(r2);
        }
        0 === s3 && e.yaxisLabelsTextsPos.push({ x: t4.x, y: t4.y }), a2 += t4.x + "," + t4.y + " ";
      }), h.push(a2);
    }), h.forEach(function(t3, a2) {
      var r2 = e.polygons.strokeColors, n2 = e.graphics.drawPolygon(t3, Array.isArray(r2) ? r2[a2] : r2, i.globals.radarPolygons.fill.colors[a2]);
      s.add(n2);
    }), c.forEach(function(t3) {
      s.add(t3);
    }), i.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach(function(t3, i2) {
      var s2 = e.drawYAxisText(t3.x, t3.y, i2, a[i2]);
      e.yaxisLabels.add(s2);
    });
  } }, { key: "drawYAxisText", value: function(t2, e, i, s) {
    var a = this.w, r = a.config.yaxis[0], n = a.globals.yLabelFormatters[0];
    return this.graphics.drawText({ x: t2 + r.labels.offsetX, y: e + r.labels.offsetY, text: n(s, i), textAnchor: "middle", fontSize: r.labels.style.fontSize, fontFamily: r.labels.style.fontFamily, foreColor: r.labels.style.color });
  } }, { key: "drawLabels", value: function() {
    var t2 = this, e = this.w, i = "middle", s = e.config.dataLabels, a = this.graphics.group({ class: "apexcharts-datalabels" }), r = this.getPolygonPos(this.size), n = 0, o = 0;
    return e.globals.labels.forEach(function(l, h) {
      var c = s.formatter, d = new DataLabels(t2.ctx);
      if (r[h]) {
        n = r[h].x, o = r[h].y, Math.abs(r[h].x) >= 10 ? r[h].x > 0 ? (i = "start", n += 10) : r[h].x < 0 && (i = "end", n -= 10) : i = "middle", Math.abs(r[h].y) >= t2.size - 10 && (r[h].y < 0 ? o -= 10 : r[h].y > 0 && (o += 10));
        var u = c(l, { seriesIndex: -1, dataPointIndex: h, w: e });
        d.plotDataLabelsText({ x: n, y: o, text: u, textAnchor: i, i: h, j: h, parent: a, dataLabelsConfig: s, offsetCorrection: false });
      }
    }), a;
  } }, { key: "createPaths", value: function(t2, e) {
    var i = this, s = [], a = [], r = [], n = [];
    if (t2.length) {
      a = [this.graphics.move(e.x, e.y)], n = [this.graphics.move(e.x, e.y)];
      var o = this.graphics.move(t2[0].x, t2[0].y), l = this.graphics.move(t2[0].x, t2[0].y);
      t2.forEach(function(e2, s2) {
        o += i.graphics.line(e2.x, e2.y), l += i.graphics.line(e2.x, e2.y), s2 === t2.length - 1 && (o += "Z", l += "Z");
      }), s.push(o), r.push(l);
    }
    return { linePathsFrom: a, linePathsTo: s, areaPathsFrom: n, areaPathsTo: r };
  } }, { key: "getPathFrom", value: function(t2) {
    for (var e = this.w, i = null, s = 0; s < e.globals.previousPaths.length; s++) {
      var a = e.globals.previousPaths[s];
      a.paths.length > 0 && parseInt(a.realIndex) === parseInt(t2) && void 0 !== e.globals.previousPaths[s].paths[0] && (i = e.globals.previousPaths[s].paths[0].d);
    }
    return i;
  } }, { key: "getDataPointsPos", value: function(t2, e) {
    var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.dataPointsLen;
    t2 = t2 || [], e = e || [];
    for (var s = [], a = 0; a < i; a++) {
      var r = {};
      r.x = t2[a] * Math.sin(e[a]), r.y = -t2[a] * Math.cos(e[a]), s.push(r);
    }
    return s;
  } }, { key: "getPolygonPos", value: function(t2) {
    for (var e = [], i = 2 * Math.PI / this.dataPointsLen, s = 0; s < this.dataPointsLen; s++) {
      var a = {};
      a.x = t2 * Math.sin(s * i), a.y = -t2 * Math.cos(s * i), e.push(a);
    }
    return e;
  } }]), t;
})();
var Radial = (function(t) {
  function e(t2) {
    var i;
    _classCallCheck(this, e), (i = _possibleConstructorReturn(this, _getPrototypeOf(e).call(this, t2))).ctx = t2, i.w = t2.w, i.animBeginArr = [0], i.animDur = 0;
    var s = i.w;
    return i.startAngle = s.config.plotOptions.radialBar.startAngle, i.endAngle = s.config.plotOptions.radialBar.endAngle, i.trackStartAngle = s.config.plotOptions.radialBar.track.startAngle, i.trackEndAngle = s.config.plotOptions.radialBar.track.endAngle, i.radialDataLabels = s.config.plotOptions.radialBar.dataLabels, i.trackStartAngle || (i.trackStartAngle = i.startAngle), i.trackEndAngle || (i.trackEndAngle = i.endAngle), 360 === i.endAngle && (i.endAngle = 359.99), i.fullAngle = 360 - s.config.plotOptions.radialBar.endAngle - s.config.plotOptions.radialBar.startAngle, i.margin = parseInt(s.config.plotOptions.radialBar.track.margin), i;
  }
  return _inherits(e, Pie), _createClass(e, [{ key: "draw", value: function(t2) {
    var e2 = this.w, i = new Graphics(this.ctx), s = i.group({ class: "apexcharts-radialbar" });
    if (e2.globals.noData) return s;
    var a = i.group(), r = this.defaultSize / 2, n = e2.globals.gridWidth / 2, o = this.defaultSize / 2.05 - e2.config.stroke.width - e2.config.chart.dropShadow.blur;
    void 0 !== e2.config.plotOptions.radialBar.size && (o = e2.config.plotOptions.radialBar.size);
    var l = e2.globals.fill.colors;
    if (e2.config.plotOptions.radialBar.track.show) {
      var h = this.drawTracks({ size: o, centerX: n, centerY: r, colorArr: l, series: t2 });
      a.add(h);
    }
    var c = this.drawArcs({ size: o, centerX: n, centerY: r, colorArr: l, series: t2 }), d = 360;
    return e2.config.plotOptions.radialBar.startAngle < 0 && (d = Math.abs(e2.config.plotOptions.radialBar.endAngle - e2.config.plotOptions.radialBar.startAngle)), e2.globals.radialSize = o - o / (360 / (360 - d)), a.add(c.g), "front" === e2.config.plotOptions.radialBar.hollow.position && (c.g.add(c.elHollow), c.dataLabels && c.g.add(c.dataLabels)), s.add(a), s;
  } }, { key: "drawTracks", value: function(t2) {
    var e2 = this.w, i = new Graphics(this.ctx), s = i.group({ class: "apexcharts-tracks" }), a = new Filters(this.ctx), r = new Fill(this.ctx), n = this.getStrokeWidth(t2);
    t2.size = t2.size - n / 2;
    for (var o = 0; o < t2.series.length; o++) {
      var l = i.group({ class: "apexcharts-radialbar-track apexcharts-track" });
      s.add(l), l.attr({ rel: o + 1 }), t2.size = t2.size - n - this.margin;
      var h = e2.config.plotOptions.radialBar.track, c = r.fillPath({ seriesNumber: 0, size: t2.size, fillColors: Array.isArray(h.background) ? h.background[o] : h.background, solid: true }), d = this.trackStartAngle, u = this.trackEndAngle;
      Math.abs(u) + Math.abs(d) >= 360 && (u = 360 - Math.abs(this.startAngle) - 0.1);
      var g = i.drawPath({ d: "", stroke: c, strokeWidth: n * parseInt(h.strokeWidth) / 100, fill: "none", strokeOpacity: h.opacity, classes: "apexcharts-radialbar-area" });
      if (h.dropShadow.enabled) {
        var f = h.dropShadow;
        a.dropShadow(g, f);
      }
      l.add(g), g.attr("id", "apexcharts-radialbarTrack-" + o), this.animatePaths(g, { centerX: t2.centerX, centerY: t2.centerY, endAngle: u, startAngle: d, size: t2.size, i: o, totalItems: 2, animBeginArr: 0, dur: 0, isTrack: true, easing: e2.globals.easing });
    }
    return s;
  } }, { key: "drawArcs", value: function(t2) {
    var e2 = this.w, i = new Graphics(this.ctx), s = new Fill(this.ctx), a = new Filters(this.ctx), r = i.group(), n = this.getStrokeWidth(t2);
    t2.size = t2.size - n / 2;
    var o = e2.config.plotOptions.radialBar.hollow.background, l = t2.size - n * t2.series.length - this.margin * t2.series.length - n * parseInt(e2.config.plotOptions.radialBar.track.strokeWidth) / 100 / 2, h = l - e2.config.plotOptions.radialBar.hollow.margin;
    void 0 !== e2.config.plotOptions.radialBar.hollow.image && (o = this.drawHollowImage(t2, r, l, o));
    var c = this.drawHollow({ size: h, centerX: t2.centerX, centerY: t2.centerY, fill: o });
    if (e2.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
      var d = e2.config.plotOptions.radialBar.hollow.dropShadow;
      a.dropShadow(c, d);
    }
    var u = 1;
    !this.radialDataLabels.total.show && e2.globals.series.length > 1 && (u = 0);
    var g = null;
    this.radialDataLabels.show && (g = this.renderInnerDataLabels(this.radialDataLabels, { hollowSize: l, centerX: t2.centerX, centerY: t2.centerY, opacity: u })), "back" === e2.config.plotOptions.radialBar.hollow.position && (r.add(c), g && r.add(g));
    var f = false;
    e2.config.plotOptions.radialBar.inverseOrder && (f = true);
    for (var p = f ? t2.series.length - 1 : 0; f ? p >= 0 : p < t2.series.length; f ? p-- : p++) {
      var x = i.group({ class: "apexcharts-series apexcharts-radial-series", seriesName: Utils.escapeString(e2.globals.seriesNames[p]) });
      r.add(x), x.attr({ rel: p + 1, "data:realIndex": p }), this.ctx.series.addCollapsedClassToSeries(x, p), t2.size = t2.size - n - this.margin;
      var m = s.fillPath({ seriesNumber: p, size: t2.size, value: t2.series[p] }), b = this.startAngle, v = void 0, y = Math.abs(e2.config.plotOptions.radialBar.endAngle - e2.config.plotOptions.radialBar.startAngle), w = Utils.negToZero(t2.series[p] > 100 ? 100 : t2.series[p]) / 100, k = Math.round(y * w) + this.startAngle, A = void 0;
      e2.globals.dataChanged && (v = this.startAngle, A = Math.round(y * Utils.negToZero(e2.globals.previousPaths[p]) / 100) + v), Math.abs(k) + Math.abs(b) >= 360 && (k -= 0.01), Math.abs(A) + Math.abs(v) >= 360 && (A -= 0.01);
      var S = k - b, C = Array.isArray(e2.config.stroke.dashArray) ? e2.config.stroke.dashArray[p] : e2.config.stroke.dashArray, L = i.drawPath({ d: "", stroke: m, strokeWidth: n, fill: "none", fillOpacity: e2.config.fill.opacity, classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + p, strokeDashArray: C });
      if (Graphics.setAttrs(L.node, { "data:angle": S, "data:value": t2.series[p] }), e2.config.chart.dropShadow.enabled) {
        var P = e2.config.chart.dropShadow;
        a.dropShadow(L, P, p);
      }
      this.addListeners(L, this.radialDataLabels), x.add(L), L.attr({ index: 0, j: p });
      var z = 0;
      !this.initialAnim || e2.globals.resized || e2.globals.dataChanged || (z = (k - b) / 360 * e2.config.chart.animations.speed, this.animDur = z / (1.2 * t2.series.length) + this.animDur, this.animBeginArr.push(this.animDur)), e2.globals.dataChanged && (z = (k - b) / 360 * e2.config.chart.animations.dynamicAnimation.speed, this.animDur = z / (1.2 * t2.series.length) + this.animDur, this.animBeginArr.push(this.animDur)), this.animatePaths(L, { centerX: t2.centerX, centerY: t2.centerY, endAngle: k, startAngle: b, prevEndAngle: A, prevStartAngle: v, size: t2.size, i: p, totalItems: 2, animBeginArr: this.animBeginArr, dur: z, shouldSetPrevPaths: true, easing: e2.globals.easing });
    }
    return { g: r, elHollow: c, dataLabels: g };
  } }, { key: "drawHollow", value: function(t2) {
    var e2 = new Graphics(this.ctx).drawCircle(2 * t2.size);
    return e2.attr({ class: "apexcharts-radialbar-hollow", cx: t2.centerX, cy: t2.centerY, r: t2.size, fill: t2.fill }), e2;
  } }, { key: "drawHollowImage", value: function(t2, e2, i, s) {
    var a = this.w, r = new Fill(this.ctx), n = (Math.random() + 1).toString(36).substring(4), o = a.config.plotOptions.radialBar.hollow.image;
    if (a.config.plotOptions.radialBar.hollow.imageClipped) r.clippedImgArea({ width: i, height: i, image: o, patternID: "pattern".concat(a.globals.cuid).concat(n) }), s = "url(#pattern".concat(a.globals.cuid).concat(n, ")");
    else {
      var l = a.config.plotOptions.radialBar.hollow.imageWidth, h = a.config.plotOptions.radialBar.hollow.imageHeight;
      if (void 0 === l && void 0 === h) {
        var c = a.globals.dom.Paper.image(o).loaded(function(e3) {
          this.move(t2.centerX - e3.width / 2 + a.config.plotOptions.radialBar.hollow.imageOffsetX, t2.centerY - e3.height / 2 + a.config.plotOptions.radialBar.hollow.imageOffsetY);
        });
        e2.add(c);
      } else {
        var d = a.globals.dom.Paper.image(o).loaded(function(e3) {
          this.move(t2.centerX - l / 2 + a.config.plotOptions.radialBar.hollow.imageOffsetX, t2.centerY - h / 2 + a.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(l, h);
        });
        e2.add(d);
      }
    }
    return s;
  } }, { key: "getStrokeWidth", value: function(t2) {
    var e2 = this.w;
    return t2.size * (100 - parseInt(e2.config.plotOptions.radialBar.hollow.size)) / 100 / (t2.series.length + 1) - this.margin;
  } }]), e;
})();
var RangeBar = (function(t) {
  function e() {
    return _classCallCheck(this, e), _possibleConstructorReturn(this, _getPrototypeOf(e).apply(this, arguments));
  }
  return _inherits(e, Bar), _createClass(e, [{ key: "draw", value: function(t2, e2) {
    var i = this.w, s = new Graphics(this.ctx), a = new Fill(this.ctx);
    this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = t2, this.seriesRangeStart = i.globals.seriesRangeStart, this.seriesRangeEnd = i.globals.seriesRangeEnd, this.initVariables(t2);
    for (var r = s.group({ class: "apexcharts-rangebar-series apexcharts-plot-series" }), n = 0, o = 0; n < t2.length; n++, o++) {
      var l, h, c, d, u = void 0, g = void 0, f = void 0, p = void 0, x = [], m = [], b = i.globals.comboCharts ? e2[n] : n, v = s.group({ class: "apexcharts-series", seriesName: Utils.escapeString(i.globals.seriesNames[b]), rel: n + 1, "data:realIndex": b });
      t2[n].length > 0 && (this.visibleI = this.visibleI + 1);
      var y = 0, w = 0, k = 0;
      this.yRatio.length > 1 && (this.yaxisIndex = b);
      var A = this.initialPositions();
      p = A.y, h = A.yDivision, w = A.barHeight, d = A.zeroW, f = A.x, k = A.barWidth, l = A.xDivision, c = A.zeroH, m.push(f + k / 2);
      for (var S = s.group({ class: "apexcharts-datalabels" }), C = 0, L = i.globals.dataPoints; C < i.globals.dataPoints; C++, L--) {
        void 0 === this.series[n][C] || null === t2[n][C] ? this.isNullValue = true : this.isNullValue = false, i.config.stroke.show && (y = this.isNullValue ? 0 : Array.isArray(this.strokeWidth) ? this.strokeWidth[b] : this.strokeWidth);
        var P = null;
        this.isHorizontal ? k = (P = this.drawRangeBarPaths({ indexes: { i: n, j: C, realIndex: b, bc: o }, barHeight: w, strokeWidth: y, pathTo: u, pathFrom: g, zeroW: d, x: f, y: p, yDivision: h, elSeries: v })).barWidth : w = (P = this.drawRangeColumnPaths({ indexes: { i: n, j: C, realIndex: b, bc: o }, x: f, y: p, xDivision: l, pathTo: u, pathFrom: g, barWidth: k, zeroH: c, strokeWidth: y, elSeries: v })).barHeight, u = P.pathTo, g = P.pathFrom, p = P.y, f = P.x, C > 0 && m.push(f + k / 2), x.push(p);
        var z = a.fillPath({ seriesNumber: b }), T = i.globals.stroke.colors[b];
        v = this.renderSeries({ realIndex: b, pathFill: z, lineFill: T, j: C, i: n, pathFrom: g, pathTo: u, strokeWidth: y, elSeries: v, x: f, y: p, series: t2, barHeight: w, barWidth: k, elDataLabelsWrap: S, visibleSeries: this.visibleI, type: "rangebar" });
      }
      i.globals.seriesXvalues[b] = m, i.globals.seriesYvalues[b] = x, r.add(v);
    }
    return r;
  } }, { key: "drawRangeColumnPaths", value: function(t2) {
    var e2 = t2.indexes, i = t2.x, s = (t2.y, t2.strokeWidth), a = t2.xDivision, r = t2.pathTo, n = t2.pathFrom, o = t2.barWidth, l = t2.zeroH, h = this.w, c = new Graphics(this.ctx), d = e2.i, u = e2.j, g = this.yRatio[this.yaxisIndex], f = e2.realIndex, p = this.getRangeValue(f, u), x = Math.min(p.start, p.end), m = Math.max(p.start, p.end);
    h.globals.isXNumeric && (i = (h.globals.seriesX[d][u] - h.globals.minX) / this.xRatio - o / 2);
    var b = i + o * this.visibleI;
    void 0 === this.series[d][u] || null === this.series[d][u] ? x = l : (x = l - x / g, m = l - m / g);
    var v = Math.abs(m - x);
    return c.move(b, l), n = c.move(b, x), h.globals.previousPaths.length > 0 && (n = this.getPathFrom(f, u, true)), r = c.move(b, m) + c.line(b + o, m) + c.line(b + o, x) + c.line(b, x) + c.line(b, m - s / 2), n = n + c.move(b, x) + c.line(b + o, x) + c.line(b + o, x) + c.line(b, x), h.globals.isXNumeric || (i += a), { pathTo: r, pathFrom: n, barHeight: v, x: i, y: m, barXPosition: b };
  } }, { key: "drawRangeBarPaths", value: function(t2) {
    var e2 = t2.indexes, i = (t2.x, t2.y), s = t2.yDivision, a = t2.pathTo, r = t2.pathFrom, n = t2.barHeight, o = t2.zeroW, l = this.w, h = new Graphics(this.ctx), c = e2.i, d = e2.j, u = e2.realIndex, g = o, f = o;
    l.globals.isXNumeric && (i = (l.globals.seriesX[c][d] - l.globals.minX) / this.invertedXRatio - n);
    var p = i + n * this.visibleI;
    void 0 !== this.series[c][d] && null !== this.series[c][d] && (g = o + this.seriesRangeStart[c][d] / this.invertedYRatio, f = o + this.seriesRangeEnd[c][d] / this.invertedYRatio), h.move(o, p), r = h.move(o, p), l.globals.previousPaths.length > 0 && (r = this.getPathFrom(u, d));
    var x = Math.abs(f - g);
    return a = h.move(g, p) + h.line(f, p) + h.line(f, p + n) + h.line(g, p + n) + h.line(g, p), r = r + h.line(g, p) + h.line(g, p + n) + h.line(g, p + n) + h.line(g, p), l.globals.isXNumeric || (i += s), { pathTo: a, pathFrom: r, barWidth: x, x: f, y: i, barYPosition: p };
  } }, { key: "getRangeValue", value: function(t2, e2) {
    var i = this.w;
    return { start: i.globals.seriesRangeStart[t2][e2], end: i.globals.seriesRangeEnd[t2][e2] };
  } }]), e;
})();
var Formatters = (function() {
  function t(e) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.tooltipKeyFormat = "dd MMM";
  }
  return _createClass(t, [{ key: "xLabelFormat", value: function(t2, e, i) {
    var s = this.w;
    if ("datetime" === s.config.xaxis.type && (void 0 === s.config.xaxis.labels.formatter && void 0 === s.config.tooltip.x.formatter)) return new DateTime(this.ctx).formatDate(new Date(e), s.config.tooltip.x.format, true, true);
    return t2(e, i);
  } }, { key: "setLabelFormatters", value: function() {
    var t2 = this.w;
    return t2.globals.xLabelFormatter = function(t3) {
      return t3;
    }, t2.globals.xaxisTooltipFormatter = function(t3) {
      return t3;
    }, t2.globals.ttKeyFormatter = function(t3) {
      return t3;
    }, t2.globals.ttZFormatter = function(t3) {
      return t3;
    }, t2.globals.legendFormatter = function(t3) {
      return t3;
    }, void 0 !== t2.config.xaxis.labels.formatter ? t2.globals.xLabelFormatter = t2.config.xaxis.labels.formatter : t2.globals.xLabelFormatter = function(e) {
      if (Utils.isNumber(e)) {
        if ("numeric" === t2.config.xaxis.type && t2.globals.dataPoints < 50) return e.toFixed(1);
        if (t2.globals.isBarHorizontal) {
          if (t2.globals.maxY - t2.globals.minYArr < 4) return e.toFixed(1);
        }
        return e.toFixed(0);
      }
      return e;
    }, "function" == typeof t2.config.tooltip.x.formatter ? t2.globals.ttKeyFormatter = t2.config.tooltip.x.formatter : t2.globals.ttKeyFormatter = t2.globals.xLabelFormatter, "function" == typeof t2.config.xaxis.tooltip.formatter && (t2.globals.xaxisTooltipFormatter = t2.config.xaxis.tooltip.formatter), Array.isArray(t2.config.tooltip.y) ? t2.globals.ttVal = t2.config.tooltip.y : void 0 !== t2.config.tooltip.y.formatter && (t2.globals.ttVal = t2.config.tooltip.y), void 0 !== t2.config.tooltip.z.formatter && (t2.globals.ttZFormatter = t2.config.tooltip.z.formatter), void 0 !== t2.config.legend.formatter && (t2.globals.legendFormatter = t2.config.legend.formatter), t2.config.yaxis.forEach(function(e, i) {
      void 0 !== e.labels.formatter ? t2.globals.yLabelFormatters[i] = e.labels.formatter : t2.globals.yLabelFormatters[i] = function(s) {
        return t2.globals.xyCharts && Utils.isNumber(s) ? 0 !== t2.globals.yValueDecimal ? s.toFixed(void 0 !== e.decimalsInFloat ? e.decimalsInFloat : t2.globals.yValueDecimal) : t2.globals.maxYArr[i] - t2.globals.minYArr[i] < 10 ? s.toFixed(1) : s.toFixed(0) : s;
      };
    }), t2.globals;
  } }, { key: "heatmapLabelFormatters", value: function() {
    var t2 = this.w;
    if ("heatmap" === t2.config.chart.type) {
      t2.globals.yAxisScale[0].result = t2.globals.seriesNames.slice();
      var e = t2.globals.seriesNames.reduce(function(t3, e2) {
        return t3.length > e2.length ? t3 : e2;
      }, 0);
      t2.globals.yAxisScale[0].niceMax = e, t2.globals.yAxisScale[0].niceMin = e;
    }
  } }]), t;
})();
var AxesUtils = (function() {
  function t(e) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w;
  }
  return _createClass(t, [{ key: "getLabel", value: function(t2, e, i, s) {
    var a, r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : [], n = this.w, o = void 0 === t2[s] ? "" : t2[s], l = n.globals.xLabelFormatter, h = n.config.xaxis.labels.formatter, c = false, d = o;
    a = new Formatters(this.ctx).xLabelFormat(l, o, d), void 0 !== h && (a = h(o, t2[s], s));
    var u, g;
    return e.length > 0 ? (u = e[s].unit, g = null, e.forEach(function(t3) {
      "month" === t3.unit ? g = "year" : "day" === t3.unit ? g = "month" : "hour" === t3.unit ? g = "day" : "minute" === t3.unit && (g = "hour");
    }), c = g === u, i = e[s].position, a = e[s].value) : "datetime" === n.config.xaxis.type && void 0 === h && (a = ""), void 0 === a && (a = ""), (0 === (a = a.toString()).indexOf("NaN") || 0 === a.toLowerCase().indexOf("invalid") || a.toLowerCase().indexOf("infinity") >= 0 || r.indexOf(a) >= 0 && !n.config.xaxis.labels.showDuplicates) && (a = ""), { x: i, text: a, isBold: c };
  } }, { key: "drawYAxisTicks", value: function(t2, e, i, s, a, r, n) {
    var o = this.w, l = new Graphics(this.ctx), h = o.globals.translateY;
    if (s.show) {
      true === o.config.yaxis[a].opposite && (t2 += s.width);
      for (var c = e; c >= 0; c--) {
        var d = h + e / 10 + o.config.yaxis[a].labels.offsetY - 1;
        o.globals.isBarHorizontal && (d = r * c);
        var u = l.drawLine(t2 + i.offsetX - s.width + s.offsetX, d + s.offsetY, t2 + i.offsetX + s.offsetX, d + s.offsetY, i.color);
        n.add(u), h += r;
      }
    }
  } }]), t;
})();
var YAxis = (function() {
  function t(e) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w;
    var i = this.w;
    this.xaxisFontSize = i.config.xaxis.labels.style.fontSize, this.axisFontFamily = i.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = i.config.xaxis.labels.style.colors, this.xAxisoffX = 0, "bottom" === i.config.xaxis.position && (this.xAxisoffX = i.globals.gridHeight), this.drawnLabels = [], this.axesUtils = new AxesUtils(e);
  }
  return _createClass(t, [{ key: "drawYaxis", value: function(t2) {
    var e = this.w, i = new Graphics(this.ctx), s = e.config.yaxis[t2].labels.style.fontSize, a = e.config.yaxis[t2].labels.style.fontFamily, r = i.group({ class: "apexcharts-yaxis", rel: t2, transform: "translate(" + e.globals.translateYAxisX[t2] + ", 0)" });
    if (!e.config.yaxis[t2].show) return r;
    var n = i.group({ class: "apexcharts-yaxis-texts-g" });
    r.add(n);
    var o = e.globals.yAxisScale[t2].result.length - 1, l = e.globals.gridHeight / o + 0.1, h = e.globals.translateY, c = e.globals.yLabelFormatters[t2], d = e.globals.yAxisScale[t2].result.slice();
    if (e.config.yaxis[t2] && e.config.yaxis[t2].reversed && d.reverse(), e.config.yaxis[t2].labels.show) for (var u = o; u >= 0; u--) {
      var g = d[u];
      g = c(g, u);
      var f = e.config.yaxis[t2].labels.padding;
      e.config.yaxis[t2].opposite && 0 !== e.config.yaxis.length && (f *= -1);
      var p = i.drawText({ x: f, y: h + o / 10 + e.config.yaxis[t2].labels.offsetY + 1, text: g, textAnchor: e.config.yaxis[t2].opposite ? "start" : "end", fontSize: s, fontFamily: a, foreColor: e.config.yaxis[t2].labels.style.color, cssClass: "apexcharts-yaxis-label " + e.config.yaxis[t2].labels.style.cssClass });
      n.add(p);
      var x = i.rotateAroundCenter(p.node);
      0 !== e.config.yaxis[t2].labels.rotate && p.node.setAttribute("transform", "rotate(".concat(e.config.yaxis[t2].labels.rotate, " ").concat(x.x, " ").concat(x.y, ")")), h += l;
    }
    if (void 0 !== e.config.yaxis[t2].title.text) {
      var m = i.group({ class: "apexcharts-yaxis-title" }), b = 0;
      e.config.yaxis[t2].opposite && (b = e.globals.translateYAxisX[t2]);
      var v = i.drawText({ x: b, y: e.globals.gridHeight / 2 + e.globals.translateY, text: e.config.yaxis[t2].title.text, textAnchor: "end", foreColor: e.config.yaxis[t2].title.style.color, fontSize: e.config.yaxis[t2].title.style.fontSize, fontFamily: e.config.yaxis[t2].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text " + e.config.yaxis[t2].title.style.cssClass });
      m.add(v), r.add(m);
    }
    var y = e.config.yaxis[t2].axisBorder;
    if (y.show) {
      var w = 31 + y.offsetX;
      e.config.yaxis[t2].opposite && (w = -31 - y.offsetX);
      var k = i.drawLine(w, e.globals.translateY + y.offsetY - 2, w, e.globals.gridHeight + e.globals.translateY + y.offsetY + 2, y.color);
      r.add(k), this.axesUtils.drawYAxisTicks(w, o, y, e.config.yaxis[t2].axisTicks, t2, l, r);
    }
    return r;
  } }, { key: "drawYaxisInversed", value: function(t2) {
    var e = this.w, i = new Graphics(this.ctx), s = i.group({ class: "apexcharts-xaxis apexcharts-yaxis-inversed" }), a = i.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(e.globals.translateXAxisX, ", ").concat(e.globals.translateXAxisY, ")") });
    s.add(a);
    var r = e.globals.yAxisScale[t2].result.length - 1, n = e.globals.gridWidth / r + 0.1, o = n + e.config.xaxis.labels.offsetX, l = e.globals.xLabelFormatter, h = e.globals.yAxisScale[t2].result.slice(), c = e.globals.invertedTimelineLabels;
    c.length > 0 && (this.xaxisLabels = c.slice(), r = (h = c.slice()).length), e.config.yaxis[t2] && e.config.yaxis[t2].reversed && h.reverse();
    var d = c.length;
    if (e.config.xaxis.labels.show) for (var u = d ? 0 : r; d ? u < d - 1 : u >= 0; d ? u++ : u--) {
      var g = h[u];
      g = l(g, u);
      var f = e.globals.gridWidth + e.globals.padHorizontal - (o - n + e.config.xaxis.labels.offsetX);
      if (c.length) {
        var p = this.axesUtils.getLabel(h, c, f, u, this.drawnLabels);
        f = p.x, g = p.text, this.drawnLabels.push(p.text);
      }
      var x = i.drawText({ x: f, y: this.xAxisoffX + e.config.xaxis.labels.offsetY + 30, text: "", textAnchor: "middle", foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[t2] : this.xaxisForeColors, fontSize: this.xaxisFontSize, fontFamily: this.xaxisFontFamily, cssClass: "apexcharts-xaxis-label " + e.config.xaxis.labels.style.cssClass });
      a.add(x), x.tspan(g);
      var m = document.createElementNS(e.globals.SVGNS, "title");
      m.textContent = g, x.node.appendChild(m), o += n;
    }
    if (void 0 !== e.config.xaxis.title.text) {
      var b = i.group({ class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed" }), v = i.drawText({ x: e.globals.gridWidth / 2, y: this.xAxisoffX + parseInt(this.xaxisFontSize) + parseInt(e.config.xaxis.title.style.fontSize) + 20, text: e.config.xaxis.title.text, textAnchor: "middle", fontSize: e.config.xaxis.title.style.fontSize, fontFamily: e.config.xaxis.title.style.fontFamily, cssClass: "apexcharts-xaxis-title-text " + e.config.xaxis.title.style.cssClass });
      b.add(v), s.add(b);
    }
    var y = e.config.yaxis[t2].axisBorder;
    if (y.show) {
      var w = i.drawLine(e.globals.padHorizontal + y.offsetX, 1 + y.offsetY, e.globals.padHorizontal + y.offsetX, e.globals.gridHeight + y.offsetY, y.color);
      s.add(w);
    }
    return s;
  } }, { key: "yAxisTitleRotate", value: function(t2, e) {
    var i = this.w, s = new Graphics(this.ctx), a = { width: 0, height: 0 }, r = { width: 0, height: 0 }, n = i.globals.dom.baseEl.querySelector(" .apexcharts-yaxis[rel='".concat(t2, "'] .apexcharts-yaxis-texts-g"));
    null !== n && (a = n.getBoundingClientRect());
    var o = i.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t2, "'] .apexcharts-yaxis-title text"));
    if (null !== o && (r = o.getBoundingClientRect()), null !== o) {
      var l = this.xPaddingForYAxisTitle(t2, a, r, e);
      o.setAttribute("x", l.xPos - (e ? 10 : 0));
    }
    if (null !== o) {
      var h = s.rotateAroundCenter(o);
      e ? o.setAttribute("transform", "rotate(".concat(i.config.yaxis[t2].title.rotate, " ").concat(h.x, " ").concat(h.y, ")")) : o.setAttribute("transform", "rotate(-".concat(i.config.yaxis[t2].title.rotate, " ").concat(h.x, " ").concat(h.y, ")"));
    }
  } }, { key: "xPaddingForYAxisTitle", value: function(t2, e, i, s) {
    var a = this.w, r = 0, n = 0, o = 10;
    return void 0 === a.config.yaxis[t2].title.text || t2 < 0 ? { xPos: n, padd: 0 } : (s ? (n = e.width + a.config.yaxis[t2].title.offsetX + i.width / 2 + o / 2, 0 === (r += 1) && (n -= o / 2)) : (n = -1 * e.width + a.config.yaxis[t2].title.offsetX + o / 2 + i.width / 2, a.globals.isBarHorizontal && (o = 25, n = -1 * e.width - a.config.yaxis[t2].title.offsetX - o)), { xPos: n, padd: o });
  } }, { key: "setYAxisXPosition", value: function(t2, e) {
    var i = this.w, s = 0, a = 0, r = 21, n = 1;
    i.config.yaxis.length > 1 && (this.multipleYs = true), i.config.yaxis.map(function(o, l) {
      var h = i.globals.ignoreYAxisIndexes.indexOf(l) > -1 || !o.show || o.floating || 0 === t2[l].width, c = t2[l].width + e[l].width;
      o.opposite ? i.globals.isBarHorizontal ? (a = i.globals.gridWidth + i.globals.translateX - 1, i.globals.translateYAxisX[l] = a - o.labels.offsetX) : (a = i.globals.gridWidth + i.globals.translateX + n, h || (n = n + c + 20), i.globals.translateYAxisX[l] = a - o.labels.offsetX + 20) : (s = i.globals.translateX - r, h || (r = r + c + 20), i.globals.translateYAxisX[l] = s + o.labels.offsetX);
    });
  } }, { key: "setYAxisTextAlignments", value: function() {
    var t2 = this.w, e = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis");
    (e = Utils.listToArray(e)).forEach(function(e2, i) {
      var s = t2.config.yaxis[i];
      if (void 0 !== s.labels.align) {
        var a = t2.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(i, "'] .apexcharts-yaxis-texts-g")), r = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(i, "'] .apexcharts-yaxis-label"));
        r = Utils.listToArray(r);
        var n = a.getBoundingClientRect();
        "left" === s.labels.align ? (r.forEach(function(t3, e3) {
          t3.setAttribute("text-anchor", "start");
        }), s.opposite || a.setAttribute("transform", "translate(-".concat(n.width, ", 0)"))) : "center" === s.labels.align ? (r.forEach(function(t3, e3) {
          t3.setAttribute("text-anchor", "middle");
        }), a.setAttribute("transform", "translate(".concat(n.width / 2 * (s.opposite ? 1 : -1), ", 0)"))) : "right" === s.labels.align && (r.forEach(function(t3, e3) {
          t3.setAttribute("text-anchor", "end");
        }), s.opposite && a.setAttribute("transform", "translate(".concat(n.width, ", 0)")));
      }
    });
  } }]), t;
})();
var Dimensions = (function() {
  function t(e) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.lgRect = {}, this.yAxisWidth = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.xPadRight = 0, this.xPadLeft = 0;
  }
  return _createClass(t, [{ key: "plotCoords", value: function() {
    var t2 = this.w, e = t2.globals, i = this.getLegendsRect();
    e.axisCharts ? this.setGridCoordsForAxisCharts(i) : this.setGridCoordsForNonAxisCharts(i), this.titleSubtitleOffset(), e.gridHeight = e.gridHeight - t2.config.grid.padding.top - t2.config.grid.padding.bottom, e.gridWidth = e.gridWidth - t2.config.grid.padding.left - t2.config.grid.padding.right - this.xPadRight - this.xPadLeft, e.translateX = e.translateX + t2.config.grid.padding.left + this.xPadLeft, e.translateY = e.translateY + t2.config.grid.padding.top;
  } }, { key: "conditionalChecksForAxisCoords", value: function(t2, e) {
    var i = this.w;
    this.xAxisHeight = (t2.height + e.height) * i.globals.LINE_HEIGHT_RATIO + 15, this.xAxisWidth = t2.width, this.xAxisHeight - e.height > i.config.xaxis.labels.maxHeight && (this.xAxisHeight = i.config.xaxis.labels.maxHeight), i.config.xaxis.labels.minHeight && this.xAxisHeight < i.config.xaxis.labels.minHeight && (this.xAxisHeight = i.config.xaxis.labels.minHeight), i.config.xaxis.floating && (this.xAxisHeight = 0), i.globals.isBarHorizontal ? this.yAxisWidth = i.globals.yLabelsCoords[0].width + i.globals.yTitleCoords[0].width + 15 : this.yAxisWidth = this.getTotalYAxisWidth();
    var s = 0, a = 0;
    i.config.yaxis.forEach(function(t3) {
      s += t3.labels.minWidth, a += t3.labels.maxWidth;
    }), this.yAxisWidth < s && (this.yAxisWidth = s), this.yAxisWidth > a && (this.yAxisWidth = a);
  } }, { key: "setGridCoordsForAxisCharts", value: function(t2) {
    var e = this.w, i = e.globals, s = this.getyAxisLabelsCoords(), a = this.getxAxisLabelsCoords(), r = this.getyAxisTitleCoords(), n = this.getxAxisTitleCoords();
    e.globals.yLabelsCoords = [], e.globals.yTitleCoords = [], e.config.yaxis.map(function(t3, i2) {
      e.globals.yLabelsCoords.push({ width: s[i2].width, index: i2 }), e.globals.yTitleCoords.push({ width: r[i2].width, index: i2 });
    }), this.conditionalChecksForAxisCoords(a, n), i.translateXAxisY = e.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, i.translateXAxisX = e.globals.rotateXLabels && e.globals.isXNumeric && e.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, e.globals.isBarHorizontal && (i.rotateXLabels = false, i.translateXAxisY = parseInt(e.config.xaxis.labels.style.fontSize) / 1.5 * -1), i.translateXAxisY = i.translateXAxisY + e.config.xaxis.labels.offsetY, i.translateXAxisX = i.translateXAxisX + e.config.xaxis.labels.offsetX;
    var o = this.yAxisWidth, l = this.xAxisHeight;
    i.xAxisLabelsHeight = this.xAxisHeight, i.xAxisHeight = this.xAxisHeight;
    var h = 10;
    switch (e.config.grid.show && "radar" !== e.config.chart.type || (o = 0, l = 35), this.isSparkline && (t2 = { height: 0, width: 0 }, l = 0, o = 0, h = 0), this.additionalPaddingXLabels(a), e.config.legend.position) {
      case "bottom":
        i.translateY = h, i.translateX = o, i.gridHeight = i.svgHeight - t2.height - l - (this.isSparkline ? 0 : e.globals.rotateXLabels ? 10 : 15), i.gridWidth = i.svgWidth - o;
        break;
      case "top":
        i.translateY = t2.height + h, i.translateX = o, i.gridHeight = i.svgHeight - t2.height - l - (this.isSparkline ? 0 : e.globals.rotateXLabels ? 10 : 15), i.gridWidth = i.svgWidth - o;
        break;
      case "left":
        i.translateY = h, i.translateX = t2.width + o, i.gridHeight = i.svgHeight - l - 12, i.gridWidth = i.svgWidth - t2.width - o;
        break;
      case "right":
        i.translateY = h, i.translateX = o, i.gridHeight = i.svgHeight - l - 12, i.gridWidth = i.svgWidth - t2.width - o - 5;
        break;
      default:
        throw new Error("Legend position not supported");
    }
    this.setGridXPosForDualYAxis(r, s), new YAxis(this.ctx).setYAxisXPosition(s, r);
  } }, { key: "setGridCoordsForNonAxisCharts", value: function(t2) {
    var e = this.w, i = e.globals, s = 0;
    e.config.legend.show && !e.config.legend.floating && (s = 20);
    var a = 10, r = 0;
    if ("pie" === e.config.chart.type || "donut" === e.config.chart.type ? (a += e.config.plotOptions.pie.offsetY, r += e.config.plotOptions.pie.offsetX) : "radialBar" === e.config.chart.type && (a += e.config.plotOptions.radialBar.offsetY, r += e.config.plotOptions.radialBar.offsetX), !e.config.legend.show) return i.gridHeight = i.svgHeight - 35, i.gridWidth = i.gridHeight, i.translateY = a - 10, void (i.translateX = r + (i.svgWidth - i.gridWidth) / 2);
    switch (e.config.legend.position) {
      case "bottom":
        i.gridHeight = i.svgHeight - t2.height - 35, i.gridWidth = i.gridHeight, i.translateY = a - 20, i.translateX = r + (i.svgWidth - i.gridWidth) / 2;
        break;
      case "top":
        i.gridHeight = i.svgHeight - t2.height - 35, i.gridWidth = i.gridHeight, i.translateY = t2.height + a + 10, i.translateX = r + (i.svgWidth - i.gridWidth) / 2;
        break;
      case "left":
        i.gridWidth = i.svgWidth - t2.width - s, i.gridHeight = i.gridWidth, i.translateY = a, i.translateX = r + t2.width + s;
        break;
      case "right":
        i.gridWidth = i.svgWidth - t2.width - s - 5, i.gridHeight = i.gridWidth, i.translateY = a, i.translateX = r + 10;
        break;
      default:
        throw new Error("Legend position not supported");
    }
  } }, { key: "setGridXPosForDualYAxis", value: function(t2, e) {
    var i = this.w;
    i.config.yaxis.map(function(s, a) {
      -1 === i.globals.ignoreYAxisIndexes.indexOf(a) && !i.config.yaxis[a].floating && i.config.yaxis[a].show && s.opposite && (i.globals.translateX = i.globals.translateX - (e[a].width + t2[a].width) - parseInt(i.config.yaxis[a].labels.style.fontSize) / 1.2 - 12);
    });
  } }, { key: "additionalPaddingXLabels", value: function(t2) {
    var e = this, i = this.w;
    if ("category" === i.config.xaxis.type && i.globals.isBarHorizontal || "numeric" === i.config.xaxis.type || "datetime" === i.config.xaxis.type) {
      var s = i.globals.isXNumeric;
      i.config.yaxis.forEach(function(a, r) {
        var n;
        (!a.show || a.floating || -1 !== i.globals.collapsedSeriesIndices.indexOf(r) || s || a.opposite && i.globals.isBarHorizontal) && ((s && i.globals.isMultipleYAxis && -1 !== i.globals.collapsedSeriesIndices.indexOf(r) || i.globals.isBarHorizontal && a.opposite) && (n = t2, i.config.grid.padding.left < n.width && (e.xPadLeft = n.width / 2 + 1)), (!i.globals.isBarHorizontal && a.opposite && -1 !== i.globals.collapsedSeriesIndices.indexOf(r) || s && !i.globals.isMultipleYAxis) && (function(t3) {
          e.timescaleLabels ? e.timescaleLabels[e.timescaleLabels.length - 1].position + t3.width > i.globals.gridWidth ? i.globals.skipLastTimelinelabel = true : i.globals.skipLastTimelinelabel = false : "datetime" === i.config.xaxis.type ? i.config.grid.padding.right < t3.width && (i.globals.skipLastTimelinelabel = true) : "datetime" !== i.config.xaxis.type && i.config.grid.padding.right < t3.width && (e.xPadRight = t3.width / 2 + 1);
        })(t2));
      });
    }
  } }, { key: "titleSubtitleOffset", value: function() {
    var t2 = this.w, e = t2.globals, i = this.isSparkline || !t2.globals.axisCharts ? 0 : 10;
    void 0 !== t2.config.title.text ? i += t2.config.title.margin : i += this.isSparkline || !t2.globals.axisCharts ? 0 : 5, void 0 !== t2.config.subtitle.text ? i += t2.config.subtitle.margin : i += this.isSparkline || !t2.globals.axisCharts ? 0 : 5, t2.config.legend.show && "bottom" === t2.config.legend.position && !t2.config.legend.floating && (t2.config.series.length > 1 || !t2.globals.axisCharts || t2.config.legend.showForSingleSeries) && (i += 10);
    var s = this.getTitleSubtitleCoords("title"), a = this.getTitleSubtitleCoords("subtitle");
    e.gridHeight = e.gridHeight - s.height - a.height - i, e.translateY = e.translateY + s.height + a.height + i;
  } }, { key: "getTotalYAxisWidth", value: function() {
    var t2 = this.w, e = 0, i = 10, s = function(e2) {
      return t2.globals.ignoreYAxisIndexes.indexOf(e2) > -1;
    };
    return t2.globals.yLabelsCoords.map(function(a, r) {
      var n = t2.config.yaxis[r].floating;
      a.width > 0 && !n ? (e = e + a.width + i, s(r) && (e = e - a.width - i)) : e += n || !t2.config.yaxis[r].show ? 0 : 5;
    }), t2.globals.yTitleCoords.map(function(a, r) {
      var n = t2.config.yaxis[r].floating;
      i = parseInt(t2.config.yaxis[r].title.style.fontSize), a.width > 0 && !n ? (e = e + a.width + i, s(r) && (e = e - a.width - i)) : e += n || !t2.config.yaxis[r].show ? 0 : 5;
    }), e;
  } }, { key: "getxAxisTimeScaleLabelsCoords", value: function() {
    var t2, e = this.w;
    this.timescaleLabels = e.globals.timelineLabels.slice(), e.globals.isBarHorizontal && "datetime" === e.config.xaxis.type && (this.timescaleLabels = e.globals.invertedTimelineLabels.slice());
    var i = this.timescaleLabels.map(function(t3) {
      return t3.value;
    }), s = i.reduce(function(t3, e2) {
      return void 0 === t3 ? (console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"), 0) : t3.length > e2.length ? t3 : e2;
    }, 0);
    return 1.05 * (t2 = new Graphics(this.ctx).getTextRects(s, e.config.xaxis.labels.style.fontSize)).width * i.length > e.globals.gridWidth && 0 !== e.config.xaxis.labels.rotate && (e.globals.overlappingXLabels = true), t2;
  } }, { key: "getxAxisLabelsCoords", value: function() {
    var t2, e = this.w, i = e.globals.labels.slice();
    if (e.globals.timelineLabels.length > 0) {
      var s = this.getxAxisTimeScaleLabelsCoords();
      t2 = { width: s.width, height: s.height };
    } else {
      var a = "left" !== e.config.legend.position || "right" !== e.config.legend.position || e.config.legend.floating ? 0 : this.lgRect.width, r = e.globals.xLabelFormatter, n = i.reduce(function(t3, e2) {
        return t3.length > e2.length ? t3 : e2;
      }, 0);
      e.globals.isBarHorizontal && (n = e.globals.yAxisScale[0].result.reduce(function(t3, e2) {
        return t3.length > e2.length ? t3 : e2;
      }, 0));
      var o = n;
      n = new Formatters(this.ctx).xLabelFormat(r, n, o);
      var l = new Graphics(this.ctx), h = l.getTextRects(n, e.config.xaxis.labels.style.fontSize);
      (t2 = { width: h.width, height: h.height }).width * i.length > e.globals.svgWidth - a - this.yAxisWidth && 0 !== e.config.xaxis.labels.rotate ? e.globals.isBarHorizontal || (e.globals.rotateXLabels = true, h = l.getTextRects(n, e.config.xaxis.labels.style.fontSize, e.config.xaxis.labels.style.fontFamily, "rotate(".concat(e.config.xaxis.labels.rotate, " 0 0)"), false), t2.height = h.height / 1.66) : e.globals.rotateXLabels = false;
    }
    return e.config.xaxis.labels.show || (t2 = { width: 0, height: 0 }), { width: t2.width, height: t2.height };
  } }, { key: "getyAxisLabelsCoords", value: function() {
    var t2 = this, e = this.w, i = [], s = 10;
    return e.config.yaxis.map(function(a, r) {
      if (a.show && a.labels.show && e.globals.yAxisScale[r].result.length) {
        var n = e.globals.yLabelFormatters[r], o = n(e.globals.yAxisScale[r].niceMax, -1);
        if (void 0 !== o && 0 !== o.length || (o = e.globals.yAxisScale[r].niceMax), e.globals.isBarHorizontal) s = 0, o = n(o = e.globals.labels.slice().reduce(function(t3, e2) {
          return t3.length > e2.length ? t3 : e2;
        }, 0), -1);
        var l = new Graphics(t2.ctx).getTextRects(o, a.labels.style.fontSize);
        i.push({ width: l.width + s, height: l.height });
      } else i.push({ width: 0, height: 0 });
    }), i;
  } }, { key: "getxAxisTitleCoords", value: function() {
    var t2 = this.w, e = 0, i = 0;
    if (void 0 !== t2.config.xaxis.title.text) {
      var s = new Graphics(this.ctx).getTextRects(t2.config.xaxis.title.text, t2.config.xaxis.title.style.fontSize);
      e = s.width, i = s.height;
    }
    return { width: e, height: i };
  } }, { key: "getyAxisTitleCoords", value: function() {
    var t2 = this, e = this.w, i = [];
    return e.config.yaxis.map(function(e2, s) {
      if (e2.show && void 0 !== e2.title.text) {
        var a = new Graphics(t2.ctx).getTextRects(e2.title.text, e2.title.style.fontSize, e2.title.style.fontFamily, "rotate(-90 0 0)", false);
        i.push({ width: a.width, height: a.height });
      } else i.push({ width: 0, height: 0 });
    }), i;
  } }, { key: "getTitleSubtitleCoords", value: function(t2) {
    var e = this.w, i = 0, s = 0, a = "title" === t2 ? e.config.title.floating : e.config.subtitle.floating, r = e.globals.dom.baseEl.querySelector(".apexcharts-".concat(t2, "-text"));
    if (null !== r && !a) {
      var n = r.getBoundingClientRect();
      i = n.width, s = e.globals.axisCharts ? n.height + 5 : n.height;
    }
    return { width: i, height: s };
  } }, { key: "getLegendsRect", value: function() {
    var t2 = this.w, e = t2.globals.dom.baseEl.querySelector(".apexcharts-legend"), i = Object.assign({}, Utils.getBoundingClientRect(e));
    return null !== e && !t2.config.legend.floating && t2.config.legend.show ? this.lgRect = { x: i.x, y: i.y, height: i.height, width: 0 === i.height ? 0 : i.width } : this.lgRect = { x: 0, y: 0, height: 0, width: 0 }, this.lgRect;
  } }]), t;
})();
var Series = (function() {
  function t(e) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w;
  }
  return _createClass(t, [{ key: "getAllSeriesEls", value: function() {
    return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
  } }, { key: "getSeriesByName", value: function(t2) {
    return this.w.globals.dom.baseEl.querySelector("[seriesName='".concat(Utils.escapeString(t2), "']"));
  } }, { key: "addCollapsedClassToSeries", value: function(t2, e) {
    var i = this.w;
    function s(i2) {
      for (var s2 = 0; s2 < i2.length; s2++) i2[s2].index === e && t2.node.classList.add("apexcharts-series-collapsed");
    }
    s(i.globals.collapsedSeries), s(i.globals.ancillaryCollapsedSeries);
  } }, { key: "resetSeries", value: function() {
    var t2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], e = this.w, i = e.globals.initialSeries.slice();
    e.config.series = i, e.globals.collapsedSeries = [], e.globals.ancillaryCollapsedSeries = [], e.globals.collapsedSeriesIndices = [], e.globals.ancillaryCollapsedSeriesIndices = [], e.globals.previousPaths = [], t2 && this.ctx._updateSeries(i, e.config.chart.animations.dynamicAnimation.enabled);
  } }, { key: "toggleSeriesOnHover", value: function(t2, e) {
    var i = this.w, s = i.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
    if ("mousemove" === t2.type) {
      var a = parseInt(e.getAttribute("rel")) - 1, r = null;
      r = i.globals.axisCharts || "radialBar" === i.config.chart.type ? i.globals.axisCharts ? i.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(a, "']")) : i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(a + 1, "']")) : i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(a + 1, "'] path"));
      for (var n = 0; n < s.length; n++) s[n].classList.add("legend-mouseover-inactive");
      null !== r && (i.globals.axisCharts || r.parentNode.classList.remove("legend-mouseover-inactive"), r.classList.remove("legend-mouseover-inactive"));
    } else if ("mouseout" === t2.type) for (var o = 0; o < s.length; o++) s[o].classList.remove("legend-mouseover-inactive");
  } }, { key: "highlightRangeInSeries", value: function(t2, e) {
    var i = this.w, s = i.globals.dom.baseEl.querySelectorAll(".apexcharts-heatmap-rect"), a = function() {
      for (var t3 = 0; t3 < s.length; t3++) s[t3].classList.remove("legend-mouseover-inactive");
    };
    if ("mousemove" === t2.type) {
      var r = parseInt(e.getAttribute("rel")) - 1;
      a(), (function() {
        for (var t3 = 0; t3 < s.length; t3++) s[t3].classList.add("legend-mouseover-inactive");
      })(), (function(t3) {
        for (var e2 = 0; e2 < s.length; e2++) {
          var i2 = parseInt(s[e2].getAttribute("val"));
          i2 >= t3.from && i2 <= t3.to && s[e2].classList.remove("legend-mouseover-inactive");
        }
      })(i.config.plotOptions.heatmap.colorScale.ranges[r]);
    } else "mouseout" === t2.type && a();
  } }, { key: "getActiveSeriesIndex", value: function() {
    var t2 = this.w, e = 0;
    if (t2.globals.series.length > 1) {
      for (var i = t2.globals.series.map(function(e2, i2) {
        return e2.length > 0 && "bar" !== t2.config.series[i2].type && "column" !== t2.config.series[i2].type ? i2 : -1;
      }), s = 0; s < i.length; s++) if (-1 !== i[s]) {
        e = i[s];
        break;
      }
    }
    return e;
  } }, { key: "getActiveConfigSeriesIndex", value: function() {
    var t2 = this.w, e = 0;
    if (t2.config.series.length > 1) {
      for (var i = t2.config.series.map(function(t3, e2) {
        return t3.data && t3.data.length > 0 ? e2 : -1;
      }), s = 0; s < i.length; s++) if (-1 !== i[s]) {
        e = i[s];
        break;
      }
    }
    return e;
  } }, { key: "getPreviousPaths", value: function() {
    var t2 = this.w;
    function e(e2, i2, s2) {
      for (var a2 = e2[i2].childNodes, r2 = { type: s2, paths: [], realIndex: e2[i2].getAttribute("data:realIndex") }, n2 = 0; n2 < a2.length; n2++) if (a2[n2].hasAttribute("pathTo")) {
        var o2 = a2[n2].getAttribute("pathTo");
        r2.paths.push({ d: o2 });
      }
      t2.globals.previousPaths.push(r2);
    }
    t2.globals.previousPaths = [];
    var i = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-series");
    if (i.length > 0) for (var s = i.length - 1; s >= 0; s--) e(i, s, "line");
    var a = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-area-series .apexcharts-series");
    if (a.length > 0) for (var r = a.length - 1; r >= 0; r--) e(a, r, "area");
    var n = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series .apexcharts-series");
    if (n.length > 0) for (var o = 0; o < n.length; o++) e(n, o, "bar");
    var l = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-candlestick-series .apexcharts-series");
    if (l.length > 0) for (var h = 0; h < l.length; h++) e(l, h, "candlestick");
    var c = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-radar-series .apexcharts-series");
    if (c.length > 0) for (var d = 0; d < c.length; d++) e(c, d, "radar");
    var u = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-bubble-series .apexcharts-series");
    if (u.length > 0) for (var g = 0; g < u.length; g++) {
      for (var f = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-bubble-series .apexcharts-series[data\\:realIndex='".concat(g, "'] circle")), p = [], x = 0; x < f.length; x++) p.push({ x: f[x].getAttribute("cx"), y: f[x].getAttribute("cy"), r: f[x].getAttribute("r") });
      t2.globals.previousPaths.push(p);
    }
    var m = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-scatter-series .apexcharts-series");
    if (m.length > 0) for (var b = 0; b < m.length; b++) {
      for (var v = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-scatter-series .apexcharts-series[data\\:realIndex='".concat(b, "'] circle")), y = [], w = 0; w < v.length; w++) y.push({ x: v[w].getAttribute("cx"), y: v[w].getAttribute("cy"), r: v[w].getAttribute("r") });
      t2.globals.previousPaths.push(y);
    }
    var k = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-heatmap .apexcharts-series");
    if (k.length > 0) for (var A = 0; A < k.length; A++) {
      for (var S = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-heatmap .apexcharts-series[data\\:realIndex='".concat(A, "'] rect")), C = [], L = 0; L < S.length; L++) C.push({ color: S[L].getAttribute("color") });
      t2.globals.previousPaths.push(C);
    }
    t2.globals.axisCharts || (t2.globals.previousPaths = t2.globals.series);
  } }, { key: "handleNoData", value: function() {
    var t2 = this.w, e = t2.config.noData, i = new Graphics(this.ctx), s = t2.globals.svgWidth / 2, a = t2.globals.svgHeight / 2, r = "middle";
    if (t2.globals.noData = true, t2.globals.animationEnded = true, "left" === e.align ? (s = 10, r = "start") : "right" === e.align && (s = t2.globals.svgWidth - 10, r = "end"), "top" === e.verticalAlign ? a = 50 : "bottom" === e.verticalAlign && (a = t2.globals.svgHeight - 50), s += e.offsetX, a = a + parseInt(e.style.fontSize) + 2, void 0 !== e.text && "" !== e.text) {
      var n = i.drawText({ x: s, y: a, text: e.text, textAnchor: r, fontSize: e.style.fontSize, fontFamily: e.style.fontFamily, foreColor: e.style.color, opacity: 1, class: "apexcharts-text-nodata" });
      n.node.setAttribute("class", "apexcharts-title-text"), t2.globals.dom.Paper.add(n);
    }
  } }, { key: "setNullSeriesToZeroValues", value: function(t2) {
    for (var e = this.w, i = 0; i < t2.length; i++) if (0 === t2[i].length) for (var s = 0; s < t2[e.globals.maxValsInArrayIndex].length; s++) t2[i].push(0);
    return t2;
  } }, { key: "hasAllSeriesEqualX", value: function() {
    for (var t2 = true, e = this.w, i = this.filteredSeriesX(), s = 0; s < i.length - 1; s++) if (i[s][0] !== i[s + 1][0]) {
      t2 = false;
      break;
    }
    return e.globals.allSeriesHasEqualX = t2, t2;
  } }, { key: "filteredSeriesX", value: function() {
    var t2 = this.w.globals.seriesX.map(function(t3, e) {
      return t3.length > 0 ? t3 : [];
    });
    return t2;
  } }]), t;
})();
var Legend = (function() {
  function t(e, i) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this);
  }
  return _createClass(t, [{ key: "init", value: function() {
    var t2 = this.w, e = t2.globals, i = t2.config;
    if ((i.legend.showForSingleSeries && 1 === e.series.length || e.series.length > 1 || !e.axisCharts) && i.legend.show) {
      for (; e.dom.elLegendWrap.firstChild; ) e.dom.elLegendWrap.removeChild(e.dom.elLegendWrap.firstChild);
      this.drawLegends(), Utils.isIE11() ? document.getElementsByTagName("head")[0].appendChild(this.getLegendStyles()) : this.appendToForeignObject(), "bottom" === i.legend.position || "top" === i.legend.position ? this.legendAlignHorizontal() : "right" !== i.legend.position && "left" !== i.legend.position || this.legendAlignVertical();
    }
  } }, { key: "appendToForeignObject", value: function() {
    var t2 = this.w.globals;
    t2.dom.elLegendForeign = document.createElementNS(t2.SVGNS, "foreignObject");
    var e = t2.dom.elLegendForeign;
    e.setAttribute("x", 0), e.setAttribute("y", 0), e.setAttribute("width", t2.svgWidth), e.setAttribute("height", t2.svgHeight), t2.dom.elLegendWrap.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), e.appendChild(t2.dom.elLegendWrap), e.appendChild(this.getLegendStyles()), t2.dom.Paper.node.insertBefore(e, t2.dom.elGraphical.node);
  } }, { key: "drawLegends", value: function() {
    var t2 = this.w, e = t2.config.legend.fontFamily, i = t2.globals.seriesNames, s = t2.globals.colors.slice();
    if ("heatmap" === t2.config.chart.type) {
      var a = t2.config.plotOptions.heatmap.colorScale.ranges;
      i = a.map(function(t3) {
        return t3.name ? t3.name : t3.from + " - " + t3.to;
      }), s = a.map(function(t3) {
        return t3.color;
      });
    }
    for (var r = t2.globals.legendFormatter, n = t2.config.legend.inverseOrder, o = n ? i.length - 1 : 0; n ? o >= 0 : o <= i.length - 1; n ? o-- : o++) {
      var l = r(i[o], { seriesIndex: o, w: t2 }), h = false, c = false;
      if (t2.globals.collapsedSeries.length > 0) for (var d = 0; d < t2.globals.collapsedSeries.length; d++) t2.globals.collapsedSeries[d].index === o && (h = true);
      if (t2.globals.ancillaryCollapsedSeriesIndices.length > 0) for (var u = 0; u < t2.globals.ancillaryCollapsedSeriesIndices.length; u++) t2.globals.ancillaryCollapsedSeriesIndices[u] === o && (c = true);
      var g = document.createElement("span");
      g.classList.add("apexcharts-legend-marker");
      var f = t2.config.legend.markers.offsetX, p = t2.config.legend.markers.offsetY, x = t2.config.legend.markers.height, m = t2.config.legend.markers.width, b = t2.config.legend.markers.strokeWidth, v = t2.config.legend.markers.strokeColor, y = t2.config.legend.markers.radius, w = g.style;
      w.background = s[o], w.color = s[o], w.height = Array.isArray(x) ? parseFloat(x[o]) + "px" : parseFloat(x) + "px", w.width = Array.isArray(m) ? parseFloat(m[o]) + "px" : parseFloat(m) + "px", w.left = Array.isArray(f) ? f[o] : f, w.top = Array.isArray(p) ? p[o] : p, w.borderWidth = Array.isArray(b) ? b[o] : b, w.borderColor = Array.isArray(v) ? v[o] : v, w.borderRadius = Array.isArray(y) ? parseFloat(y[o]) + "px" : parseFloat(y) + "px", t2.config.legend.markers.customHTML && (Array.isArray(t2.config.legend.markers.customHTML) ? g.innerHTML = t2.config.legend.markers.customHTML[o]() : g.innerHTML = t2.config.legend.markers.customHTML()), Graphics.setAttrs(g, { rel: o + 1, "data:collapsed": h || c }), (h || c) && g.classList.add("inactive-legend");
      var k = document.createElement("div"), A = document.createElement("span");
      A.classList.add("apexcharts-legend-text"), A.innerHTML = l;
      var S = t2.config.legend.labels.useSeriesColors ? t2.globals.colors[o] : t2.config.legend.labels.colors;
      S || (S = t2.config.chart.foreColor), A.style.color = S, A.style.fontSize = parseFloat(t2.config.legend.fontSize) + "px", A.style.fontFamily = e || t2.config.chart.fontFamily, Graphics.setAttrs(A, { rel: o + 1, i: o, "data:default-text": l, "data:collapsed": h || c }), k.appendChild(g), k.appendChild(A);
      var C = new CoreUtils(this.ctx);
      if (!t2.config.legend.showForZeroSeries) 0 === C.getSeriesTotalByIndex(o) && C.seriesHaveSameValues(o) && !C.isSeriesNull(o) && -1 === t2.globals.collapsedSeriesIndices.indexOf(o) && -1 === t2.globals.ancillaryCollapsedSeriesIndices.indexOf(o) && k.classList.add("apexcharts-hidden-zero-series");
      t2.config.legend.showForNullSeries || C.isSeriesNull(o) && -1 === t2.globals.collapsedSeriesIndices.indexOf(o) && -1 === t2.globals.ancillaryCollapsedSeriesIndices.indexOf(o) && k.classList.add("apexcharts-hidden-null-series"), t2.globals.dom.elLegendWrap.appendChild(k), t2.globals.dom.elLegendWrap.classList.add(t2.config.legend.horizontalAlign), t2.globals.dom.elLegendWrap.classList.add("position-" + t2.config.legend.position), k.classList.add("apexcharts-legend-series"), k.style.margin = "".concat(t2.config.legend.itemMargin.horizontal, "px ").concat(t2.config.legend.itemMargin.vertical, "px"), t2.globals.dom.elLegendWrap.style.width = t2.config.legend.width ? t2.config.legend.width + "px" : "", t2.globals.dom.elLegendWrap.style.height = t2.config.legend.height ? t2.config.legend.height + "px" : "", Graphics.setAttrs(k, { rel: o + 1, "data:collapsed": h || c }), (h || c) && k.classList.add("inactive-legend"), t2.config.legend.onItemClick.toggleDataSeries || k.classList.add("no-click");
    }
    "heatmap" !== t2.config.chart.type && t2.config.legend.onItemClick.toggleDataSeries && t2.globals.dom.elWrap.addEventListener("click", this.onLegendClick, true), t2.config.legend.onItemHover.highlightDataSeries && (t2.globals.dom.elWrap.addEventListener("mousemove", this.onLegendHovered, true), t2.globals.dom.elWrap.addEventListener("mouseout", this.onLegendHovered, true));
  } }, { key: "getLegendBBox", value: function() {
    var t2 = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect(), e = t2.width;
    return { clwh: t2.height, clww: e };
  } }, { key: "setLegendWrapXY", value: function(t2, e) {
    var i = this.w, s = i.globals.dom.baseEl.querySelector(".apexcharts-legend"), a = s.getBoundingClientRect(), r = 0, n = 0;
    if ("bottom" === i.config.legend.position) n += i.globals.svgHeight - a.height / 2;
    else if ("top" === i.config.legend.position) {
      var o = new Dimensions(this.ctx), l = o.getTitleSubtitleCoords("title").height, h = o.getTitleSubtitleCoords("subtitle").height;
      n = n + (l > 0 ? l - 10 : 0) + (h > 0 ? h - 10 : 0);
    }
    s.style.position = "absolute", r = r + t2 + i.config.legend.offsetX, n = n + e + i.config.legend.offsetY, s.style.left = r + "px", s.style.top = n + "px", "bottom" === i.config.legend.position ? (s.style.top = "auto", s.style.bottom = 10 + i.config.legend.offsetY + "px") : "right" === i.config.legend.position && (s.style.left = "auto", s.style.right = 25 + i.config.legend.offsetX + "px"), s.style.width && (s.style.width = parseInt(i.config.legend.width) + "px"), s.style.height && (s.style.height = parseInt(i.config.legend.height) + "px");
  } }, { key: "legendAlignHorizontal", value: function() {
    var t2 = this.w;
    t2.globals.dom.baseEl.querySelector(".apexcharts-legend").style.right = 0;
    var e = this.getLegendBBox(), i = new Dimensions(this.ctx), s = i.getTitleSubtitleCoords("title"), a = i.getTitleSubtitleCoords("subtitle"), r = 0;
    "bottom" === t2.config.legend.position ? r = -e.clwh / 1.8 : "top" === t2.config.legend.position && (r = s.height + a.height + t2.config.title.margin + t2.config.subtitle.margin - 15), this.setLegendWrapXY(20, r);
  } }, { key: "legendAlignVertical", value: function() {
    var t2 = this.w, e = this.getLegendBBox(), i = 0;
    "left" === t2.config.legend.position && (i = 20), "right" === t2.config.legend.position && (i = t2.globals.svgWidth - e.clww - 10), this.setLegendWrapXY(i, 20);
  } }, { key: "onLegendHovered", value: function(t2) {
    var e = this.w, i = t2.target.classList.contains("apexcharts-legend-text") || t2.target.classList.contains("apexcharts-legend-marker");
    if ("heatmap" !== e.config.chart.type) !t2.target.classList.contains("inactive-legend") && i && new Series(this.ctx).toggleSeriesOnHover(t2, t2.target);
    else if (i) {
      var s = parseInt(t2.target.getAttribute("rel")) - 1;
      this.ctx.fireEvent("legendHover", [this.ctx, s, this.w]), new Series(this.ctx).highlightRangeInSeries(t2, t2.target);
    }
  } }, { key: "onLegendClick", value: function(t2) {
    if (t2.target.classList.contains("apexcharts-legend-text") || t2.target.classList.contains("apexcharts-legend-marker")) {
      var e = parseInt(t2.target.getAttribute("rel")) - 1, i = "true" === t2.target.getAttribute("data:collapsed"), s = this.w.config.chart.events.legendClick;
      "function" == typeof s && s(this.ctx, e, this.w), this.ctx.fireEvent("legendClick", [this.ctx, e, this.w]);
      var a = this.w.config.legend.markers.onClick;
      "function" == typeof a && t2.target.classList.contains("apexcharts-legend-marker") && (a(this.ctx, e, this.w), this.ctx.fireEvent("legendMarkerClick", [this.ctx, e, this.w])), this.toggleDataSeries(e, i);
    }
  } }, { key: "getLegendStyles", value: function() {
    var t2 = document.createElement("style");
    t2.setAttribute("type", "text/css");
    var e = document.createTextNode("\n    \n      .apexcharts-legend {\n        display: flex;\n        overflow: auto;\n        padding: 0 10px;\n      }\n\n      .apexcharts-legend.position-bottom, .apexcharts-legend.position-top {\n        flex-wrap: wrap\n      }\n      .apexcharts-legend.position-right, .apexcharts-legend.position-left {\n        flex-direction: column;\n        bottom: 0;\n      }\n\n      .apexcharts-legend.position-bottom.left, .apexcharts-legend.position-top.left, .apexcharts-legend.position-right, .apexcharts-legend.position-left {\n        justify-content: flex-start;\n      }\n\n      .apexcharts-legend.position-bottom.center, .apexcharts-legend.position-top.center {\n        justify-content: center;  \n      }\n\n      .apexcharts-legend.position-bottom.right, .apexcharts-legend.position-top.right {\n        justify-content: flex-end;\n      }\n\n      .apexcharts-legend-series {\n        cursor: pointer;\n        line-height: normal;\n      }\n\n      .apexcharts-legend.position-bottom .apexcharts-legend-series, .apexcharts-legend.position-top .apexcharts-legend-series{\n        display: flex;\n        align-items: center;\n      }\n\n      .apexcharts-legend-text {\n        position: relative;\n        font-size: 14px;\n      }\n\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\n        pointer-events: none;\n      }\n\n      .apexcharts-legend-marker {\n        position: relative;\n        display: inline-block;\n        cursor: pointer;\n        margin-right: 3px;\n      }\n      \n      .apexcharts-legend.right .apexcharts-legend-series, .apexcharts-legend.left .apexcharts-legend-series{\n        display: inline-block;\n      }\n\n      .apexcharts-legend-series.no-click {\n        cursor: auto;\n      }\n\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\n        display: none !important;\n      }\n\n      .inactive-legend {\n        opacity: 0.45;\n      }");
    return t2.appendChild(e), t2;
  } }, { key: "toggleDataSeries", value: function(t2, e) {
    var i = this.w;
    if (i.globals.axisCharts || "radialBar" === i.config.chart.type) {
      i.globals.resized = true;
      var s = null, a = null;
      if (i.globals.risingSeries = [], i.globals.axisCharts ? (s = i.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t2, "']")), a = parseInt(s.getAttribute("data:realIndex"))) : (s = i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(t2 + 1, "']")), a = parseInt(s.getAttribute("rel")) - 1), e) this.riseCollapsedSeries(i.globals.collapsedSeries, i.globals.collapsedSeriesIndices, a), this.riseCollapsedSeries(i.globals.ancillaryCollapsedSeries, i.globals.ancillaryCollapsedSeriesIndices, a);
      else {
        if (i.globals.axisCharts) {
          var r = false;
          if (i.config.yaxis[a] && i.config.yaxis[a].show && i.config.yaxis[a].showAlways && (r = true, i.globals.ancillaryCollapsedSeriesIndices.indexOf(a) < 0 && (i.globals.ancillaryCollapsedSeries.push({ index: a, data: i.config.series[a].data.slice(), type: s.parentNode.className.baseVal.split("-")[1] }), i.globals.ancillaryCollapsedSeriesIndices.push(a))), !r) {
            i.globals.collapsedSeries.push({ index: a, data: i.config.series[a].data.slice(), type: s.parentNode.className.baseVal.split("-")[1] }), i.globals.collapsedSeriesIndices.push(a);
            var n = i.globals.risingSeries.indexOf(a);
            i.globals.risingSeries.splice(n, 1);
          }
          i.config.series[a].data = [];
        } else i.globals.collapsedSeries.push({ index: a, data: i.config.series[a] }), i.globals.collapsedSeriesIndices.push(a), i.config.series[a] = 0;
        for (var o = s.childNodes, l = 0; l < o.length; l++) o[l].classList.contains("apexcharts-series-markers-wrap") && (o[l].classList.contains("apexcharts-hide") ? o[l].classList.remove("apexcharts-hide") : o[l].classList.add("apexcharts-hide"));
        i.globals.allSeriesCollapsed = i.globals.collapsedSeries.length === i.globals.series.length, this.ctx._updateSeries(i.config.series, i.config.chart.animations.dynamicAnimation.enabled);
      }
    } else {
      var h = i.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(t2 + 1, "'] path")), c = i.config.chart.type;
      if ("pie" === c || "donut" === c) {
        var d = i.config.plotOptions.pie.donut.labels, u = new Graphics(this.ctx), g = new Pie(this.ctx);
        u.pathMouseDown(h.members[0], null), g.printDataLabelsInner(h.members[0].node, d);
      }
      h.fire("click");
    }
  } }, { key: "riseCollapsedSeries", value: function(t2, e, i) {
    var s = this.w;
    if (t2.length > 0) for (var a = 0; a < t2.length; a++) t2[a].index === i && (s.globals.axisCharts ? (s.config.series[i].data = t2[a].data.slice(), t2.splice(a, 1), e.splice(a, 1), s.globals.risingSeries.push(i)) : (s.config.series[i] = t2[a].data, t2.splice(a, 1), e.splice(a, 1), s.globals.risingSeries.push(i)), this.ctx._updateSeries(s.config.series, s.config.chart.animations.dynamicAnimation.enabled));
  } }]), t;
})();
var Line = (function() {
  function t(e, i, s) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.xyRatios = i, this.pointsChart = !("bubble" !== this.w.config.chart.type && "scatter" !== this.w.config.chart.type) || s, this.scatter = new Scatter(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.yaxisIndex = 0;
  }
  return _createClass(t, [{ key: "draw", value: function(t2, e, i) {
    var s = this.w, a = new Graphics(this.ctx), r = new Fill(this.ctx), n = s.globals.comboCharts ? e : s.config.chart.type, o = a.group({ class: "apexcharts-".concat(n, "-series apexcharts-plot-series") }), l = new CoreUtils(this.ctx, s);
    t2 = l.getLogSeries(t2);
    var h = this.xyRatios.yRatio;
    h = l.getLogYRatios(h);
    for (var c = this.xyRatios.zRatio, d = this.xyRatios.xRatio, u = this.xyRatios.baseLineY, g = [], f = [], p = 0, x = 0; x < t2.length; x++) {
      if ("line" === n && ("gradient" === s.config.fill.type || "gradient" === s.config.fill.type[x]) && l.seriesHaveSameValues(x)) {
        var m = t2[x].slice();
        m[m.length - 1] = m[m.length - 1] + 1e-6, t2[x] = m;
      }
      var b = s.globals.gridWidth / s.globals.dataPoints, v = s.globals.comboCharts ? i[x] : x;
      h.length > 1 && (this.yaxisIndex = v), this.isReversed = s.config.yaxis[this.yaxisIndex] && s.config.yaxis[this.yaxisIndex].reversed;
      var y = [], w = [], k = s.globals.gridHeight - u[this.yaxisIndex] - (this.isReversed ? s.globals.gridHeight : 0) + (this.isReversed ? 2 * u[this.yaxisIndex] : 0), A = k;
      k > s.globals.gridHeight && (A = s.globals.gridHeight), p = b / 2;
      var S = s.globals.padHorizontal + p, C = 1;
      s.globals.isXNumeric && s.globals.seriesX.length > 0 && (S = (s.globals.seriesX[v][0] - s.globals.minX) / d), w.push(S);
      var L = void 0, P = void 0, z = void 0, T = void 0, M = [], E = [], X = a.group({ class: "apexcharts-series", seriesName: Utils.escapeString(s.globals.seriesNames[v]) }), I = a.group({ class: "apexcharts-series-markers-wrap" }), Y = a.group({ class: "apexcharts-datalabels" });
      this.ctx.series.addCollapsedClassToSeries(X, v);
      var F = t2[x].length === s.globals.dataPoints;
      X.attr({ "data:longestSeries": F, rel: x + 1, "data:realIndex": v }), this.appendPathFrom = true;
      var R = S, D = void 0, O = R, N = k, _ = 0;
      if (N = this.determineFirstPrevY({ i: x, series: t2, yRatio: h[this.yaxisIndex], zeroY: k, prevY: N, prevSeriesY: f, lineYPosition: _ }).prevY, y.push(N), D = N, null === t2[x][0]) {
        for (var H = 0; H < t2[x].length; H++) if (null !== t2[x][H]) {
          O = b * H, N = k - t2[x][H] / h[this.yaxisIndex], L = a.move(O, N), P = a.move(O, A);
          break;
        }
      } else L = a.move(O, N), P = a.move(O, A) + a.line(O, N);
      if (z = a.move(-1, k) + a.line(-1, k), T = a.move(-1, k) + a.line(-1, k), s.globals.previousPaths.length > 0) {
        var W = this.checkPreviousPaths({ pathFromLine: z, pathFromArea: T, realIndex: v });
        z = W.pathFromLine, T = W.pathFromArea;
      }
      for (var G = s.globals.dataPoints > 1 ? s.globals.dataPoints - 1 : s.globals.dataPoints, B = 0; B < G; B++) {
        if (s.globals.isXNumeric) {
          var V = s.globals.seriesX[v][B + 1];
          void 0 === s.globals.seriesX[v][B + 1] && (V = s.globals.seriesX[v][G - 1]), S = (V - s.globals.minX) / d;
        } else S += b;
        var U = Utils.isNumber(s.globals.minYArr[v]) ? s.globals.minYArr[v] : s.globals.minY;
        s.config.chart.stacked ? (_ = x > 0 && s.globals.collapsedSeries.length < s.config.series.length - 1 ? f[x - 1][B + 1] : k, C = void 0 === t2[x][B + 1] || null === t2[x][B + 1] ? _ - U / h[this.yaxisIndex] + 2 * (this.isReversed ? U / h[this.yaxisIndex] : 0) : _ - t2[x][B + 1] / h[this.yaxisIndex] + 2 * (this.isReversed ? t2[x][B + 1] / h[this.yaxisIndex] : 0)) : C = void 0 === t2[x][B + 1] || null === t2[x][B + 1] ? k - U / h[this.yaxisIndex] + 2 * (this.isReversed ? U / h[this.yaxisIndex] : 0) : k - t2[x][B + 1] / h[this.yaxisIndex] + 2 * (this.isReversed ? t2[x][B + 1] / h[this.yaxisIndex] : 0), w.push(S), y.push(C);
        var j = this.createPaths({ series: t2, i: x, j: B, x: S, y: C, xDivision: b, pX: R, pY: D, areaBottomY: A, linePath: L, areaPath: P, linePaths: M, areaPaths: E, seriesIndex: i });
        E = j.areaPaths, M = j.linePaths, R = j.pX, D = j.pY, P = j.areaPath, L = j.linePath, this.appendPathFrom && (z += a.line(S, k), T += a.line(S, k));
        var q = this.calculatePoints({ series: t2, x: S, y: C, realIndex: v, i: x, j: B, prevY: N, categoryAxisCorrection: p, xRatio: d });
        if (this.pointsChart) this.scatter.draw(X, B, { realIndex: v, pointsPos: q, zRatio: c, elParent: I });
        else {
          var Z = new Markers(this.ctx);
          s.globals.dataPoints > 1 && I.node.classList.add("hidden");
          var $ = Z.plotChartMarkers(q, v, B + 1);
          null !== $ && I.add($);
        }
        var J = !t2[x][B + 1] || t2[x][B + 1] > t2[x][B] ? "top" : "bottom", Q = new DataLabels(this.ctx).drawDataLabel(q, v, B + 1, null, J);
        null !== Q && Y.add(Q);
      }
      f.push(y), s.globals.seriesXvalues[v] = w, s.globals.seriesYvalues[v] = y, this.pointsChart || s.globals.delayedElements.push({ el: I.node, index: v });
      var K = { i: x, realIndex: v, animationDelay: x, initialSpeed: s.config.chart.animations.speed, dataChangeSpeed: s.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(n) };
      if ("area" === n) for (var tt = r.fillPath({ seriesNumber: v }), et = 0; et < E.length; et++) {
        var it = a.renderPaths(_objectSpread({}, K, { pathFrom: T, pathTo: E[et], stroke: "none", strokeWidth: 0, strokeLineCap: null, fill: tt }));
        X.add(it);
      }
      if (s.config.stroke.show && !this.pointsChart) {
        var st = null;
        st = "line" === n ? r.fillPath({ seriesNumber: v, i: x }) : s.globals.stroke.colors[v];
        for (var at = 0; at < M.length; at++) {
          var rt = a.renderPaths(_objectSpread({}, K, { pathFrom: z, pathTo: M[at], stroke: st, strokeWidth: Array.isArray(s.config.stroke.width) ? s.config.stroke.width[v] : s.config.stroke.width, strokeLineCap: s.config.stroke.lineCap, fill: "none" }));
          X.add(rt);
        }
      }
      X.add(I), X.add(Y), g.push(X);
    }
    for (var nt = g.length; nt > 0; nt--) o.add(g[nt - 1]);
    return o;
  } }, { key: "createPaths", value: function(t2) {
    var e = t2.series, i = t2.i, s = t2.j, a = t2.x, r = t2.y, n = t2.pX, o = t2.pY, l = t2.xDivision, h = t2.areaBottomY, c = t2.linePath, d = t2.areaPath, u = t2.linePaths, g = t2.areaPaths, f = t2.seriesIndex, p = this.w, x = new Graphics(this.ctx), m = p.config.stroke.curve;
    if (Array.isArray(p.config.stroke.curve) && (m = Array.isArray(f) ? p.config.stroke.curve[f[i]] : p.config.stroke.curve[i]), "smooth" === m) {
      var b = 0.35 * (a - n);
      p.globals.hasNullValues ? (null !== e[i][s] && (null !== e[i][s + 1] ? (c = x.move(n, o) + x.curve(n + b, o, a - b, r, a + 1, r), d = x.move(n + 1, o) + x.curve(n + b, o, a - b, r, a + 1, r) + x.line(a, h) + x.line(n, h) + "z") : (c = x.move(n, o), d = x.move(n, o) + "z")), u.push(c), g.push(d)) : (c += x.curve(n + b, o, a - b, r, a, r), d += x.curve(n + b, o, a - b, r, a, r)), n = a, o = r, s === e[i].length - 2 && (d = d + x.curve(n, o, a, r, a, h) + x.move(a, r) + "z", p.globals.hasNullValues || (u.push(c), g.push(d)));
    } else null === e[i][s + 1] && (c += x.move(a, r), d = d + x.line(a - l, h) + x.move(a, r)), null === e[i][s] && (c += x.move(a, r), d += x.move(a, h)), "stepline" === m ? (c = c + x.line(a, null, "H") + x.line(null, r, "V"), d = d + x.line(a, null, "H") + x.line(null, r, "V")) : "straight" === m && (c += x.line(a, r), d += x.line(a, r)), s === e[i].length - 2 && (d = d + x.line(a, h) + x.move(a, r) + "z", u.push(c), g.push(d));
    return { linePaths: u, areaPaths: g, pX: n, pY: o, linePath: c, areaPath: d };
  } }, { key: "calculatePoints", value: function(t2) {
    var e = t2.series, i = t2.realIndex, s = t2.x, a = t2.y, r = t2.i, n = t2.j, o = t2.prevY, l = t2.categoryAxisCorrection, h = t2.xRatio, c = this.w, d = [], u = [];
    if (0 === n) {
      var g = l + c.config.markers.offsetX;
      c.globals.isXNumeric && (g = (c.globals.seriesX[i][0] - c.globals.minX) / h + c.config.markers.offsetX), d.push(g), u.push(Utils.isNumber(e[r][0]) ? o + c.config.markers.offsetY : null), d.push(s + c.config.markers.offsetX), u.push(Utils.isNumber(e[r][n + 1]) ? a + c.config.markers.offsetY : null);
    } else d.push(s + c.config.markers.offsetX), u.push(Utils.isNumber(e[r][n + 1]) ? a + c.config.markers.offsetY : null);
    return { x: d, y: u };
  } }, { key: "checkPreviousPaths", value: function(t2) {
    for (var e = t2.pathFromLine, i = t2.pathFromArea, s = t2.realIndex, a = this.w, r = 0; r < a.globals.previousPaths.length; r++) {
      var n = a.globals.previousPaths[r];
      ("line" === n.type || "area" === n.type) && n.paths.length > 0 && parseInt(n.realIndex) === parseInt(s) && ("line" === n.type ? (this.appendPathFrom = false, e = a.globals.previousPaths[r].paths[0].d) : "area" === n.type && (this.appendPathFrom = false, i = a.globals.previousPaths[r].paths[0].d, a.config.stroke.show && (e = a.globals.previousPaths[r].paths[1].d)));
    }
    return { pathFromLine: e, pathFromArea: i };
  } }, { key: "determineFirstPrevY", value: function(t2) {
    var e = t2.i, i = t2.series, s = t2.yRatio, a = t2.zeroY, r = t2.prevY, n = t2.prevSeriesY, o = t2.lineYPosition, l = this.w;
    if (void 0 !== i[e][0]) r = l.config.chart.stacked ? (o = e > 0 ? n[e - 1][0] : a) - i[e][0] / s + 2 * (this.isReversed ? i[e][0] / s : 0) : a - i[e][0] / s + 2 * (this.isReversed ? i[e][0] / s : 0);
    else if (l.config.chart.stacked && e > 0 && void 0 === i[e][0]) {
      for (var h = e - 1; h >= 0; h--) if (null !== i[h][0] && void 0 !== i[h][0]) {
        r = o = n[h][0];
        break;
      }
    }
    return { prevY: r, lineYPosition: o };
  } }]), t;
})();
var XAxis = (function() {
  function t(e) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w;
    var i = this.w;
    this.xaxisLabels = i.globals.labels.slice(), i.globals.timelineLabels.length > 0 && (this.xaxisLabels = i.globals.timelineLabels.slice()), this.drawnLabels = [], "top" === i.config.xaxis.position ? this.offY = 0 : this.offY = i.globals.gridHeight + 1, this.offY = this.offY + i.config.xaxis.axisBorder.offsetY, this.xaxisFontSize = i.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = i.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = i.config.xaxis.labels.style.colors, this.xaxisBorderWidth = i.config.xaxis.axisBorder.width, this.xaxisBorderWidth.indexOf("%") > -1 ? this.xaxisBorderWidth = i.globals.gridWidth * parseInt(this.xaxisBorderWidth) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth), this.xaxisBorderHeight = i.config.xaxis.axisBorder.height, this.yaxis = i.config.yaxis[0], this.axesUtils = new AxesUtils(e);
  }
  return _createClass(t, [{ key: "drawXaxis", value: function() {
    var t2, e = this.w, i = new Graphics(this.ctx), s = i.group({ class: "apexcharts-xaxis", transform: "translate(".concat(e.config.xaxis.offsetX, ", ").concat(e.config.xaxis.offsetY, ")") }), a = i.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(e.globals.translateXAxisX, ", ").concat(e.globals.translateXAxisY, ")") });
    s.add(a);
    for (var r = e.globals.padHorizontal, n = [], o = 0; o < this.xaxisLabels.length; o++) n.push(this.xaxisLabels[o]);
    r = e.globals.isXNumeric ? r + (t2 = e.globals.gridWidth / (n.length - 1)) / 2 + e.config.xaxis.labels.offsetX : r + (t2 = e.globals.gridWidth / n.length) + e.config.xaxis.labels.offsetX;
    var l = n.length;
    if (e.config.xaxis.labels.show) for (var h = 0; h <= l - 1; h++) {
      var c = r - t2 / 2 + e.config.xaxis.labels.offsetX, d = this.axesUtils.getLabel(n, e.globals.timelineLabels, c, h, this.drawnLabels);
      this.drawnLabels.push(d.text);
      var u = 28;
      e.globals.rotateXLabels && (u = 22);
      var g = i.drawText({ x: d.x, y: this.offY + e.config.xaxis.labels.offsetY + u, text: "", textAnchor: "middle", fontWeight: d.isBold ? 600 : 400, fontSize: this.xaxisFontSize, fontFamily: this.xaxisFontFamily, foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[h] : this.xaxisForeColors, cssClass: "apexcharts-xaxis-label " + e.config.xaxis.labels.style.cssClass });
      h === l - 1 && e.globals.skipLastTimelinelabel && (d.text = ""), a.add(g), i.addTspan(g, d.text, this.xaxisFontFamily);
      var f = document.createElementNS(e.globals.SVGNS, "title");
      f.textContent = d.text, g.node.appendChild(f), r += t2;
    }
    if (void 0 !== e.config.xaxis.title.text) {
      var p = i.group({ class: "apexcharts-xaxis-title" }), x = i.drawText({ x: e.globals.gridWidth / 2 + e.config.xaxis.title.offsetX, y: this.offY - parseInt(this.xaxisFontSize) + e.globals.xAxisLabelsHeight + e.config.xaxis.title.offsetY, text: e.config.xaxis.title.text, textAnchor: "middle", fontSize: e.config.xaxis.title.style.fontSize, fontFamily: e.config.xaxis.title.style.fontFamily, foreColor: e.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text " + e.config.xaxis.title.style.cssClass });
      p.add(x), s.add(p);
    }
    if (e.config.xaxis.axisBorder.show) {
      var m = 0;
      "bar" === e.config.chart.type && e.globals.isXNumeric && (m -= 15);
      var b = i.drawLine(e.globals.padHorizontal + m + e.config.xaxis.axisBorder.offsetX, this.offY, this.xaxisBorderWidth, this.offY, e.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
      s.add(b);
    }
    return s;
  } }, { key: "drawXaxisInversed", value: function(t2) {
    var e, i, s = this.w, a = new Graphics(this.ctx), r = s.config.yaxis[0].opposite ? s.globals.translateYAxisX[t2] : 0, n = a.group({ class: "apexcharts-yaxis apexcharts-xaxis-inversed", rel: t2 }), o = a.group({ class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g", transform: "translate(" + r + ", 0)" });
    n.add(o);
    for (var l = [], h = 0; h < this.xaxisLabels.length; h++) l.push(this.xaxisLabels[h]);
    i = -(e = s.globals.gridHeight / l.length) / 2.2;
    var c = s.globals.yLabelFormatters[0], d = s.config.yaxis[0].labels;
    if (d.show) for (var u = 0; u <= l.length - 1; u++) {
      var g = void 0 === l[u] ? "" : l[u];
      g = c(g);
      var f = a.drawText({ x: d.offsetX - 15, y: i + e + d.offsetY, text: g, textAnchor: this.yaxis.opposite ? "start" : "end", foreColor: d.style.color ? d.style.color : d.style.colors[u], fontSize: d.style.fontSize, fontFamily: d.style.fontFamily, cssClass: "apexcharts-yaxis-label " + d.style.cssClass });
      if (o.add(f), 0 !== s.config.yaxis[t2].labels.rotate) {
        var p = a.rotateAroundCenter(f.node);
        f.node.setAttribute("transform", "rotate(".concat(s.config.yaxis[t2].labels.rotate, " ").concat(p.x, " ").concat(p.y, ")"));
      }
      i += e;
    }
    if (void 0 !== s.config.yaxis[0].title.text) {
      var x = a.group({ class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed", transform: "translate(" + r + ", 0)" }), m = a.drawText({ x: 0, y: s.globals.gridHeight / 2, text: s.config.yaxis[0].title.text, textAnchor: "middle", foreColor: s.config.yaxis[0].title.style.color, fontSize: s.config.yaxis[0].title.style.fontSize, fontFamily: s.config.yaxis[0].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text " + s.config.yaxis[0].title.style.cssClass });
      x.add(m), n.add(x);
    }
    if (s.config.xaxis.axisBorder.show) {
      var b = a.drawLine(s.globals.padHorizontal + s.config.xaxis.axisBorder.offsetX, this.offY, this.xaxisBorderWidth, this.offY, this.yaxis.axisBorder.color, 0, this.xaxisBorderHeight);
      n.add(b), this.axesUtils.drawYAxisTicks(0, l.length, s.config.yaxis[0].axisBorder, s.config.yaxis[0].axisTicks, 0, e, n);
    }
    return n;
  } }, { key: "drawXaxisTicks", value: function(t2, e) {
    var i = this.w, s = t2;
    if (!(t2 < 0 || t2 > i.globals.gridWidth)) {
      var a = this.offY + i.config.xaxis.axisTicks.offsetY, r = a + i.config.xaxis.axisTicks.height;
      if (i.config.xaxis.axisTicks.show) {
        var n = new Graphics(this.ctx).drawLine(t2 + i.config.xaxis.axisTicks.offsetX, a + i.config.xaxis.offsetY, s + i.config.xaxis.axisTicks.offsetX, r + i.config.xaxis.offsetY, i.config.xaxis.axisTicks.color);
        e.add(n), n.node.classList.add("apexcharts-xaxis-tick");
      }
    }
  } }, { key: "getXAxisTicksPositions", value: function() {
    var t2 = this.w, e = [], i = this.xaxisLabels.length, s = t2.globals.padHorizontal;
    if (t2.globals.timelineLabels.length > 0) for (var a = 0; a < i; a++) s = this.xaxisLabels[a].position, e.push(s);
    else for (var r = i, n = 0; n < r; n++) {
      var o = r;
      t2.globals.isXNumeric && "bar" !== t2.config.chart.type && (o -= 1), s += t2.globals.gridWidth / o, e.push(s);
    }
    return e;
  } }, { key: "xAxisLabelCorrections", value: function() {
    var t2 = this.w, e = new Graphics(this.ctx), i = t2.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"), s = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text"), a = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"), r = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text");
    if (t2.globals.rotateXLabels || t2.config.xaxis.labels.rotateAlways) for (var n = 0; n < s.length; n++) {
      var o = e.rotateAroundCenter(s[n]);
      o.y = o.y - 1, o.x = o.x + 1, s[n].setAttribute("transform", "rotate(".concat(t2.config.xaxis.labels.rotate, " ").concat(o.x, " ").concat(o.y, ")")), s[n].setAttribute("text-anchor", "end");
      i.setAttribute("transform", "translate(0, ".concat(-10, ")"));
      var l = s[n].childNodes;
      t2.config.xaxis.labels.trim && e.placeTextWithEllipsis(l[0], l[0].textContent, t2.config.xaxis.labels.maxHeight - 40);
    }
    else for (var h = t2.globals.gridWidth / t2.globals.labels.length, c = 0; c < s.length; c++) {
      var d = s[c].childNodes;
      t2.config.xaxis.labels.trim && "datetime" !== t2.config.xaxis.type && e.placeTextWithEllipsis(d[0], d[0].textContent, h);
    }
    if (a.length > 0) {
      var u = a[a.length - 1].getBBox(), g = a[0].getBBox();
      u.x < -20 && a[a.length - 1].parentNode.removeChild(a[a.length - 1]), g.x + g.width > t2.globals.gridWidth && a[0].parentNode.removeChild(a[0]);
      for (var f = 0; f < r.length; f++) e.placeTextWithEllipsis(r[f], r[f].textContent, t2.config.yaxis[0].labels.maxWidth - 2 * parseInt(t2.config.yaxis[0].title.style.fontSize) - 20);
    }
  } }]), t;
})();
var Range = (function() {
  function t(e) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w;
  }
  return _createClass(t, [{ key: "niceScale", value: function(t2, e, i) {
    var s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 10, r = this.w, n = void 0 === this.w.config.yaxis[s].max && void 0 === this.w.config.yaxis[s].min || this.w.config.yaxis[s].forceNiceScale;
    if (t2 === Number.MIN_VALUE && 0 === e || !Utils.isNumber(t2) && !Utils.isNumber(e) || t2 === Number.MIN_VALUE && e === -Number.MAX_VALUE) return t2 = 0, e = a, this.linearScale(t2, e, a);
    t2 > e ? (console.warn("yaxis.min cannot be greater than yaxis.max"), e = t2 + 0.1) : t2 === e && (t2 = 0 === t2 ? 0 : t2 - 0.5, e = 0 === e ? 2 : e + 0.5);
    var o = [], l = Math.abs(e - t2);
    l < 1 && n && ("candlestick" === r.config.chart.type || "candlestick" === r.config.series[s].type || r.globals.isRangeData) && (e *= 1.01);
    var h = a + 1;
    h < 2 ? h = 2 : h > 2 && (h -= 2);
    var c = l / h, d = Math.floor(Utils.log10(c)), u = Math.pow(10, d), g = Math.round(c / u);
    g < 1 && (g = 1);
    var f = g * u, p = f * Math.floor(t2 / f), x = f * Math.ceil(e / f), m = p;
    if (n && l > 2) {
      for (; o.push(m), !((m += f) > x); ) ;
      return { result: o, niceMin: o[0], niceMax: o[o.length - 1] };
    }
    var b = t2;
    (o = []).push(b);
    for (var v = Math.abs(e - t2) / a, y = 0; y <= a; y++) b += v, o.push(b);
    return o[o.length - 2] >= e && o.pop(), { result: o, niceMin: o[0], niceMax: o[o.length - 1] };
  } }, { key: "linearScale", value: function(t2, e) {
    var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10, s = Math.abs(e - t2) / i;
    i === Number.MAX_VALUE && (i = 10, s = 1);
    for (var a = [], r = t2; i >= 0; ) a.push(r), r += s, i -= 1;
    return { result: a, niceMin: a[0], niceMax: a[a.length - 1] };
  } }, { key: "logarithmicScale", value: function(t2, e, i, s) {
    (e < 0 || e === Number.MIN_VALUE) && (e = 0.01);
    for (var a = Math.log(e) / Math.log(10), r = Math.log(i) / Math.log(10), n = Math.abs(i - e) / s, o = [], l = e; s >= 0; ) o.push(l), l += n, s -= 1;
    var h = o.map(function(t3, s2) {
      t3 <= 0 && (t3 = 0.01);
      var n2 = (r - a) / (i - e), o2 = Math.pow(10, a + n2 * (t3 - a));
      return Math.round(o2 / Utils.roundToBase(o2, 10)) * Utils.roundToBase(o2, 10);
    });
    return 0 === h[0] && (h[0] = 1), { result: h, niceMin: h[0], niceMax: h[h.length - 1] };
  } }, { key: "setYScaleForIndex", value: function(t2, e, i) {
    var s = this.w.globals, a = this.w.config, r = s.isBarHorizontal ? a.xaxis : a.yaxis[t2];
    if (void 0 === s.yAxisScale[t2] && (s.yAxisScale[t2] = []), r.logarithmic) s.allSeriesCollapsed = false, s.yAxisScale[t2] = this.logarithmicScale(t2, e, i, r.tickAmount ? r.tickAmount : Math.floor(Math.log10(i)));
    else if (i !== -Number.MAX_VALUE && Utils.isNumber(i)) if (s.allSeriesCollapsed = false, void 0 === r.min && void 0 === r.max || r.forceNiceScale) {
      var n = Math.abs(i - e);
      s.yAxisScale[t2] = this.niceScale(e, i, n, t2, r.tickAmount ? r.tickAmount : n < 5 && n > 1 ? n + 1 : 5);
    } else s.yAxisScale[t2] = this.linearScale(e, i, r.tickAmount);
    else s.yAxisScale[t2] = this.linearScale(0, 5, 5);
  } }, { key: "setMultipleYScales", value: function() {
    var t2 = this, e = this.w.globals, i = this.w.config, s = e.minYArr.concat([]), a = e.maxYArr.concat([]), r = [];
    i.yaxis.forEach(function(n, o) {
      var l = o;
      i.series.forEach(function(t3, i2) {
        t3.name === n.seriesName && -1 === e.collapsedSeriesIndices.indexOf(i2) && (l = i2, o !== i2 ? r.push({ index: i2, similarIndex: o, alreadyExists: true }) : r.push({ index: i2 }));
      });
      var h = s[l], c = a[l];
      t2.setYScaleForIndex(o, h, c);
    }), this.sameScaleInMultipleAxes(s, a, r);
  } }, { key: "sameScaleInMultipleAxes", value: function(t2, e, i) {
    var s = this, a = this.w.config, r = this.w.globals, n = [];
    i.forEach(function(t3) {
      t3.alreadyExists && (void 0 === n[t3.index] && (n[t3.index] = []), n[t3.index].push(t3.index), n[t3.index].push(t3.similarIndex));
    }), r.yAxisSameScaleIndices = n, n.forEach(function(t3, e2) {
      n.forEach(function(i2, s2) {
        var a2, r2;
        e2 !== s2 && (a2 = t3, r2 = i2, a2.filter(function(t4) {
          return -1 !== r2.indexOf(t4);
        })).length > 0 && (n[e2] = n[e2].concat(n[s2]));
      });
    });
    var o = n.map(function(t3) {
      return t3.filter(function(e2, i2) {
        return t3.indexOf(e2) === i2;
      });
    }).map(function(t3) {
      return t3.sort();
    });
    n = n.filter(function(t3) {
      return !!t3;
    });
    var l = o.slice(), h = l.map(function(t3) {
      return JSON.stringify(t3);
    });
    l = l.filter(function(t3, e2) {
      return h.indexOf(JSON.stringify(t3)) === e2;
    });
    var c = [], d = [];
    t2.forEach(function(t3, i2) {
      l.forEach(function(s2, a2) {
        s2.indexOf(i2) > -1 && (void 0 === c[a2] && (c[a2] = [], d[a2] = []), c[a2].push({ key: i2, value: t3 }), d[a2].push({ key: i2, value: e[i2] }));
      });
    });
    var u = Array.apply(null, Array(l.length)).map(Number.prototype.valueOf, Number.MIN_VALUE), g = Array.apply(null, Array(l.length)).map(Number.prototype.valueOf, -Number.MAX_VALUE);
    c.forEach(function(t3, e2) {
      t3.forEach(function(t4, i2) {
        u[e2] = Math.min(t4.value, u[e2]);
      });
    }), d.forEach(function(t3, e2) {
      t3.forEach(function(t4, i2) {
        g[e2] = Math.max(t4.value, g[e2]);
      });
    }), t2.forEach(function(t3, e2) {
      d.forEach(function(t4, i2) {
        var n2 = u[i2], o2 = g[i2];
        a.chart.stacked && (o2 = 0, t4.forEach(function(t5, e3) {
          o2 += t5.value, n2 !== Number.MIN_VALUE && (n2 += c[i2][e3].value);
        })), t4.forEach(function(i3, l2) {
          t4[l2].key === e2 && (void 0 !== a.yaxis[e2].min && (n2 = "function" == typeof a.yaxis[e2].min ? a.yaxis[e2].min(r.minY) : a.yaxis[e2].min), void 0 !== a.yaxis[e2].max && (o2 = "function" == typeof a.yaxis[e2].max ? a.yaxis[e2].max(r.maxY) : a.yaxis[e2].max), s.setYScaleForIndex(e2, n2, o2));
        });
      });
    });
  } }, { key: "autoScaleY", value: function(t2, e, i) {
    t2 || (t2 = this);
    var s = t2.w;
    if (s.globals.isMultipleYAxis || s.globals.collapsedSeries.length) return e;
    var a = s.globals.seriesX[0], r = s.config.chart.stacked;
    return e.forEach(function(t3, n) {
      for (var o = 0, l = 0; l < a.length; l++) if (a[l] >= i.xaxis.min) {
        o = l;
        break;
      }
      var h, c, d = s.globals.minYArr[n], u = s.globals.maxYArr[n], g = s.globals.stackedSeriesTotals;
      s.globals.series.forEach(function(n2, l2) {
        var f = n2[o];
        r ? (f = g[o], h = c = f, g.forEach(function(t4, e2) {
          a[e2] <= i.xaxis.max && a[e2] >= i.xaxis.min && (t4 > c && null !== t4 && (c = t4), n2[e2] < h && null !== n2[e2] && (h = n2[e2]));
        })) : (h = c = f, n2.forEach(function(t4, e2) {
          if (a[e2] <= i.xaxis.max && a[e2] >= i.xaxis.min) {
            var r2 = t4, n3 = t4;
            s.globals.series.forEach(function(i2, s2) {
              null !== t4 && (r2 = Math.min(i2[e2], r2), n3 = Math.max(i2[e2], n3));
            }), n3 > c && null !== n3 && (c = n3), r2 < h && null !== r2 && (h = r2);
          }
        })), void 0 === h && void 0 === c && (h = d, c = u), (c *= c < 0 ? 0.9 : 1.1) < 0 && c < u && (c = u), (h *= h < 0 ? 1.1 : 0.9) < 0 && h > d && (h = d), e.length > 1 ? (e[l2].min = void 0 === t3.min ? h : t3.min, e[l2].max = void 0 === t3.max ? c : t3.max) : (e[0].min = void 0 === t3.min ? h : t3.min, e[0].max = void 0 === t3.max ? c : t3.max);
      });
    }), e;
  } }]), t;
})();
var Range$1 = (function() {
  function t(e) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.scales = new Range(e);
  }
  return _createClass(t, [{ key: "init", value: function() {
    this.setYRange(), this.setXRange(), this.setZRange();
  } }, { key: "getMinYMaxY", value: function(t2) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -Number.MAX_VALUE, s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, a = this.w.globals, r = -Number.MAX_VALUE, n = Number.MIN_VALUE;
    null === s && (s = t2 + 1);
    var o = a.series, l = o, h = o;
    "candlestick" === this.w.config.chart.type ? (l = a.seriesCandleL, h = a.seriesCandleH) : a.isRangeData && (l = a.seriesRangeStart, h = a.seriesRangeEnd);
    for (var c = t2; c < s; c++) {
      a.dataPoints = Math.max(a.dataPoints, o[c].length);
      for (var d = 0; d < a.series[c].length; d++) {
        var u = o[c][d];
        null !== u && Utils.isNumber(u) ? (r = Math.max(r, h[c][d]), e = Math.min(e, l[c][d]), i = Math.max(i, l[c][d]), "candlestick" === this.w.config.chart.type && (r = Math.max(r, a.seriesCandleO[c][d]), r = Math.max(r, a.seriesCandleH[c][d]), r = Math.max(r, a.seriesCandleL[c][d]), i = r = Math.max(r, a.seriesCandleC[c][d])), Utils.isFloat(u) && (u = Utils.noExponents(u), a.yValueDecimal = Math.max(a.yValueDecimal, u.toString().split(".")[1].length)), n > l[c][d] && l[c][d] < 0 && (n = l[c][d])) : a.hasNullValues = true;
      }
    }
    return { minY: n, maxY: r, lowestY: e, highestY: i };
  } }, { key: "setYRange", value: function() {
    var t2 = this.w.globals, e = this.w.config;
    t2.maxY = -Number.MAX_VALUE, t2.minY = Number.MIN_VALUE;
    var i = Number.MAX_VALUE;
    if (t2.isMultipleYAxis) for (var s = 0; s < t2.series.length; s++) {
      var a = this.getMinYMaxY(s, i, null, s + 1);
      t2.minYArr.push(a.minY), t2.maxYArr.push(a.maxY), i = a.lowestY;
    }
    var r = this.getMinYMaxY(0, i, null, t2.series.length);
    if (t2.minY = r.minY, t2.maxY = r.maxY, i = r.lowestY, e.chart.stacked) {
      var n = [], o = [];
      if (t2.series.length) for (var l = 0; l < t2.series[t2.maxValsInArrayIndex].length; l++) for (var h = 0, c = 0, d = 0; d < t2.series.length; d++) null !== t2.series[d][l] && Utils.isNumber(t2.series[d][l]) && (t2.series[d][l] > 0 ? h = h + parseFloat(t2.series[d][l]) + 1e-4 : c += parseFloat(t2.series[d][l])), d === t2.series.length - 1 && (n.push(h), o.push(c));
      for (var u = 0; u < n.length; u++) t2.maxY = Math.max(t2.maxY, n[u]), t2.minY = Math.min(t2.minY, o[u]);
    }
    if (("line" === e.chart.type || "area" === e.chart.type || "candlestick" === e.chart.type) && t2.minY === Number.MIN_VALUE && i !== -Number.MAX_VALUE && i !== t2.maxY) {
      var g = t2.maxY - i;
      i >= 0 && i <= 10 && (g = 0), t2.minY = i - 5 * g / 100, t2.maxY = t2.maxY + 5 * g / 100;
    }
    return e.yaxis.map(function(e2, i2) {
      void 0 !== e2.max && ("number" == typeof e2.max ? t2.maxYArr[i2] = e2.max : "function" == typeof e2.max && (t2.maxYArr[i2] = e2.max(t2.maxY)), t2.maxY = t2.maxYArr[i2]), void 0 !== e2.min && ("number" == typeof e2.min ? t2.minYArr[i2] = e2.min : "function" == typeof e2.min && (t2.minYArr[i2] = e2.min(t2.minY)), t2.minY = t2.minYArr[i2]);
    }), t2.isBarHorizontal && (void 0 !== e.xaxis.min && "number" == typeof e.xaxis.min && (t2.minY = e.xaxis.min), void 0 !== e.xaxis.max && "number" == typeof e.xaxis.max && (t2.maxY = e.xaxis.max)), t2.isMultipleYAxis ? (this.scales.setMultipleYScales(), t2.minY = i, t2.yAxisScale.forEach(function(e2, i2) {
      t2.minYArr[i2] = e2.niceMin, t2.maxYArr[i2] = e2.niceMax;
    })) : (this.scales.setYScaleForIndex(0, t2.minY, t2.maxY), t2.minY = t2.yAxisScale[0].niceMin, t2.maxY = t2.yAxisScale[0].niceMax, t2.minYArr[0] = t2.yAxisScale[0].niceMin, t2.maxYArr[0] = t2.yAxisScale[0].niceMax), { minY: t2.minY, maxY: t2.maxY, minYArr: t2.minYArr, maxYArr: t2.maxYArr };
  } }, { key: "setXRange", value: function() {
    var t2, e = this.w.globals, i = this.w.config, s = "numeric" === i.xaxis.type || "datetime" === i.xaxis.type || "category" === i.xaxis.type && !e.noLabelsProvided || e.noLabelsProvided || e.isXNumeric;
    if (e.isXNumeric) {
      for (var a = 0; a < e.series.length; a++) if (e.labels[a]) for (var r = 0; r < e.labels[a].length; r++) null !== e.labels[a][r] && Utils.isNumber(e.labels[a][r]) && (e.maxX = Math.max(e.maxX, e.labels[a][r]), e.initialmaxX = Math.max(e.maxX, e.labels[a][r]), e.minX = Math.min(e.minX, e.labels[a][r]), e.initialminX = Math.min(e.minX, e.labels[a][r]));
    }
    if (e.noLabelsProvided && 0 === i.xaxis.categories.length && (e.maxX = e.labels[e.labels.length - 1], e.initialmaxX = e.labels[e.labels.length - 1], e.minX = 1, e.initialminX = 1), (e.comboChartsHasBars || "candlestick" === i.chart.type || "bar" === i.chart.type && e.isXNumeric) && ("category" !== i.xaxis.type || e.isXNumeric)) {
      var n = e.svgWidth / e.dataPoints * (Math.abs(e.maxX - e.minX) / e.svgWidth), o = e.minX - n / 2;
      e.minX = o, e.initialminX = o;
      var l = e.maxX + n / ((e.series.length + 1) / e.series.length);
      e.maxX = l, e.initialmaxX = l;
    }
    !e.isXNumeric && !e.noLabelsProvided || i.xaxis.convertedCatToNumeric && !e.dataFormatXNumeric || (void 0 === i.xaxis.tickAmount ? (t2 = Math.round(e.svgWidth / 150), "numeric" === i.xaxis.type && e.dataPoints < 20 && (t2 = e.dataPoints - 1), t2 > e.dataPoints && 0 !== e.dataPoints && (t2 = e.dataPoints - 1)) : t2 = "dataPoints" === i.xaxis.tickAmount ? e.series[e.maxValsInArrayIndex].length - 1 : i.xaxis.tickAmount, void 0 !== i.xaxis.max && "number" == typeof i.xaxis.max && (e.maxX = i.xaxis.max), void 0 !== i.xaxis.min && "number" == typeof i.xaxis.min && (e.minX = i.xaxis.min), void 0 !== i.xaxis.range && (e.minX = e.maxX - i.xaxis.range), e.minX !== Number.MAX_VALUE && e.maxX !== -Number.MAX_VALUE ? e.xAxisScale = this.scales.linearScale(e.minX, e.maxX, t2) : (e.xAxisScale = this.scales.linearScale(1, t2, t2), e.noLabelsProvided && e.labels.length > 0 && (e.xAxisScale = this.scales.linearScale(1, e.labels.length, t2 - 1), e.seriesX = e.labels.slice())), s && (e.labels = e.xAxisScale.result.slice()));
    if (e.minX === e.maxX) if ("datetime" === i.xaxis.type) {
      var h = new Date(e.minX);
      h.setDate(h.getDate() - 2), e.minX = new Date(h).getTime();
      var c = new Date(e.maxX);
      c.setDate(c.getDate() + 2), e.maxX = new Date(c).getTime();
    } else ("numeric" === i.xaxis.type || "category" === i.xaxis.type && !e.noLabelsProvided) && (e.minX = e.minX - 2, e.maxX = e.maxX + 2);
    return e.isXNumeric && (e.seriesX.forEach(function(t3, i2) {
      1 === t3.length && t3.push(e.seriesX[e.maxValsInArrayIndex][e.seriesX[e.maxValsInArrayIndex].length - 1]), t3.forEach(function(t4, s2) {
        if (s2 > 0) {
          var a2 = t4 - e.seriesX[i2][s2 - 1];
          e.minXDiff = Math.min(a2, e.minXDiff);
        }
      });
    }), this.calcMinXDiffForTinySeries()), { minX: e.minX, maxX: e.maxX };
  } }, { key: "calcMinXDiffForTinySeries", value: function() {
    var t2 = this.w, e = t2.globals.labels.length;
    return 1 === t2.globals.labels.length ? t2.globals.minXDiff = (t2.globals.maxX - t2.globals.minX) / e / 3 : t2.globals.minXDiff === Number.MAX_VALUE && (t2.globals.timelineLabels.length > 0 && (e = t2.globals.timelineLabels.length), e < 3 && (e = 3), t2.globals.minXDiff = (t2.globals.maxX - t2.globals.minX) / e), t2.globals.minXDiff;
  } }, { key: "setZRange", value: function() {
    var t2 = this.w.globals;
    if (t2.isDataXYZ) {
      for (var e = 0; e < t2.series.length; e++) if (void 0 !== t2.seriesZ[e]) for (var i = 0; i < t2.seriesZ[e].length; i++) null !== t2.seriesZ[e][i] && Utils.isNumber(t2.seriesZ[e][i]) && (t2.maxZ = Math.max(t2.maxZ, t2.seriesZ[e][i]), t2.minZ = Math.min(t2.minZ, t2.seriesZ[e][i]));
    }
  } }]), t;
})();
var TimeScale = (function() {
  function t(e) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.timeScaleArray = [];
  }
  return _createClass(t, [{ key: "calculateTimeScaleTicks", value: function(t2, e) {
    var i = this, s = this.w;
    if (s.globals.allSeriesCollapsed) return s.globals.labels = [], s.globals.timelineLabels = [], [];
    var a = new DateTime(this.ctx), r = (e - t2) / 864e5;
    this.determineInterval(r), s.globals.disableZoomIn = false, s.globals.disableZoomOut = false, r < 5e-3 ? s.globals.disableZoomIn = true : r > 5e4 && (s.globals.disableZoomOut = true);
    var n = a.getTimeUnitsfromTimestamp(t2, e), o = s.globals.gridWidth / r, l = o / 24, h = l / 60, c = Math.floor(24 * r), d = Math.floor(24 * r * 60), u = Math.floor(r), g = Math.floor(r / 30), f = Math.floor(r / 365), p = { minMinute: n.minMinute, minHour: n.minHour, minDate: n.minDate, minMonth: n.minMonth, minYear: n.minYear }, x = { firstVal: p, currentMinute: p.minMinute, currentHour: p.minHour, currentMonthDate: p.minDate, currentDate: p.minDate, currentMonth: p.minMonth, currentYear: p.minYear, daysWidthOnXAxis: o, hoursWidthOnXAxis: l, minutesWidthOnXAxis: h, numberOfMinutes: d, numberOfHours: c, numberOfDays: u, numberOfMonths: g, numberOfYears: f };
    switch (this.tickInterval) {
      case "years":
        this.generateYearScale(x);
        break;
      case "months":
      case "half_year":
        this.generateMonthScale(x);
        break;
      case "months_days":
      case "months_fortnight":
      case "days":
      case "week_days":
        this.generateDayScale(x);
        break;
      case "hours":
        this.generateHourScale(x);
        break;
      case "minutes":
        this.generateMinuteScale(x);
    }
    var m = this.timeScaleArray.map(function(t3) {
      var e2 = { position: t3.position, unit: t3.unit, year: t3.year, day: t3.day ? t3.day : 1, hour: t3.hour ? t3.hour : 0, month: t3.month + 1 };
      return "month" === t3.unit ? _objectSpread({}, e2, { day: 1, value: t3.value + 1 }) : "day" === t3.unit || "hour" === t3.unit ? _objectSpread({}, e2, { value: t3.value }) : "minute" === t3.unit ? _objectSpread({}, e2, { value: t3.value, minute: t3.value }) : t3;
    });
    return m.filter(function(t3) {
      var e2 = 1, a2 = Math.ceil(s.globals.gridWidth / 120), r2 = t3.value;
      void 0 !== s.config.xaxis.tickAmount && (a2 = s.config.xaxis.tickAmount), m.length > a2 && (e2 = Math.floor(m.length / a2));
      var n2 = false, o2 = false;
      switch (i.tickInterval) {
        case "half_year":
          e2 = 7, "year" === t3.unit && (n2 = true);
          break;
        case "months":
          e2 = 1, "year" === t3.unit && (n2 = true);
          break;
        case "months_fortnight":
          e2 = 15, "year" !== t3.unit && "month" !== t3.unit || (n2 = true), 30 === r2 && (o2 = true);
          break;
        case "months_days":
          e2 = 10, "month" === t3.unit && (n2 = true), 30 === r2 && (o2 = true);
          break;
        case "week_days":
          e2 = 8, "month" === t3.unit && (n2 = true);
          break;
        case "days":
          e2 = 1, "month" === t3.unit && (n2 = true);
          break;
        case "hours":
          "day" === t3.unit && (n2 = true);
          break;
        case "minutes":
          r2 % 5 != 0 && (o2 = true);
      }
      if ("minutes" === i.tickInterval || "hours" === i.tickInterval) {
        if (!o2) return true;
      } else if ((r2 % e2 == 0 || n2) && !o2) return true;
    });
  } }, { key: "recalcDimensionsBasedOnFormat", value: function(t2, e) {
    var i = this.w, s = this.formatDates(t2), a = this.removeOverlappingTS(s);
    e ? i.globals.invertedTimelineLabels = a.slice() : i.globals.timelineLabels = a.slice(), new Dimensions(this.ctx).plotCoords();
  } }, { key: "determineInterval", value: function(t2) {
    switch (true) {
      case t2 > 1825:
        this.tickInterval = "years";
        break;
      case (t2 > 800 && t2 <= 1825):
        this.tickInterval = "half_year";
        break;
      case (t2 > 180 && t2 <= 800):
        this.tickInterval = "months";
        break;
      case (t2 > 90 && t2 <= 180):
        this.tickInterval = "months_fortnight";
        break;
      case (t2 > 60 && t2 <= 90):
        this.tickInterval = "months_days";
        break;
      case (t2 > 30 && t2 <= 60):
        this.tickInterval = "week_days";
        break;
      case (t2 > 2 && t2 <= 30):
        this.tickInterval = "days";
        break;
      case (t2 > 0.1 && t2 <= 2):
        this.tickInterval = "hours";
        break;
      case t2 < 0.1:
        this.tickInterval = "minutes";
        break;
      default:
        this.tickInterval = "days";
    }
  } }, { key: "generateYearScale", value: function(t2) {
    var e = t2.firstVal, i = t2.currentMonth, s = t2.currentYear, a = t2.daysWidthOnXAxis, r = t2.numberOfYears, n = e.minYear, o = 0, l = new DateTime(this.ctx);
    if (e.minDate > 1 && e.minMonth > 0) {
      var h = l.determineRemainingDaysOfYear(e.minYear, e.minMonth, e.minDate);
      o = (l.determineDaysOfYear(e.minYear) - h + 1) * a, n = e.minYear + 1, this.timeScaleArray.push({ position: o, value: n, unit: "year", year: n, month: Utils.monthMod(i + 1) });
    } else 1 === e.minDate && 0 === e.minMonth && this.timeScaleArray.push({ position: o, value: n, unit: "year", year: s, month: Utils.monthMod(i + 1) });
    for (var c = n, d = o, u = 0; u < r; u++) c++, d = l.determineDaysOfYear(c - 1) * a + d, this.timeScaleArray.push({ position: d, value: c, unit: "year", year: c, month: 1 });
  } }, { key: "generateMonthScale", value: function(t2) {
    var e = t2.firstVal, i = t2.currentMonthDate, s = t2.currentMonth, a = t2.currentYear, r = t2.daysWidthOnXAxis, n = t2.numberOfMonths, o = s, l = 0, h = new DateTime(this.ctx), c = "month", d = 0;
    if (e.minDate > 1) {
      l = (h.determineDaysOfMonths(s + 1, e.minYear) - i + 1) * r, o = Utils.monthMod(s + 1);
      var u = a + d, g = Utils.monthMod(o), f = o;
      0 === o && (c = "year", f = u, g = 1, u += d += 1), this.timeScaleArray.push({ position: l, value: f, unit: c, year: u, month: g });
    } else this.timeScaleArray.push({ position: l, value: o, unit: c, year: a, month: Utils.monthMod(s) });
    for (var p = o + 1, x = l, m = 0, b = 1; m < n; m++, b++) {
      0 === (p = Utils.monthMod(p)) ? (c = "year", d += 1) : c = "month";
      var v = a + Math.floor(p / 12) + d;
      x = h.determineDaysOfMonths(p, v) * r + x;
      var y = 0 === p ? v : p;
      this.timeScaleArray.push({ position: x, value: y, unit: c, year: v, month: 0 === p ? 1 : p }), p++;
    }
  } }, { key: "generateDayScale", value: function(t2) {
    var e = t2.firstVal, i = t2.currentMonth, s = t2.currentYear, a = t2.hoursWidthOnXAxis, r = t2.numberOfDays, n = new DateTime(this.ctx), o = "day", l = (24 - e.minHour) * a, h = e.minDate + 1, c = h, d = function(t3, e2, i2) {
      return t3 > n.determineDaysOfMonths(e2 + 1, i2) ? (u = 1, o = "month", c = e2 += 1, e2) : e2;
    }, u = h, g = d(u, i, s);
    this.timeScaleArray.push({ position: l, value: c, unit: o, year: s, month: Utils.monthMod(g), day: u });
    for (var f = l, p = 0; p < r; p++) {
      o = "day", g = d(u += 1, g, s + Math.floor(g / 12) + 0);
      var x = s + Math.floor(g / 12) + 0;
      f = 24 * a + f;
      var m = 1 === u ? Utils.monthMod(g) : u;
      this.timeScaleArray.push({ position: f, value: m, unit: o, year: x, month: Utils.monthMod(g), day: m });
    }
  } }, { key: "generateHourScale", value: function(t2) {
    var e = t2.firstVal, i = t2.currentDate, s = t2.currentMonth, a = t2.currentYear, r = t2.minutesWidthOnXAxis, n = t2.numberOfHours, o = new DateTime(this.ctx), l = "hour", h = function(t3, e2) {
      return t3 > o.determineDaysOfMonths(e2 + 1, a) && (p = 1, e2 += 1), { month: e2, date: p };
    }, c = function(t3, e2) {
      return t3 > o.determineDaysOfMonths(e2 + 1, a) ? e2 += 1 : e2;
    }, d = 60 - e.minMinute, u = d * r, g = e.minHour + 1, f = g + 1;
    60 === d && (u = 0, f = (g = e.minHour) + 1);
    var p = i, x = c(p, s);
    this.timeScaleArray.push({ position: u, value: g, unit: l, day: p, hour: f, year: a, month: Utils.monthMod(x) });
    for (var m = u, b = 0; b < n; b++) {
      if (l = "hour", f >= 24) f = 0, l = "day", x = h(p += 1, x).month, x = c(p, x);
      var v = a + Math.floor(x / 12) + 0;
      m = 0 === f && 0 === b ? d * r : 60 * r + m;
      var y = 0 === f ? p : f;
      this.timeScaleArray.push({ position: m, value: y, unit: l, hour: f, day: p, year: v, month: Utils.monthMod(x) }), f++;
    }
  } }, { key: "generateMinuteScale", value: function(t2) {
    var e = t2.firstVal, i = t2.currentMinute, s = t2.currentHour, a = t2.currentDate, r = t2.currentMonth, n = t2.currentYear, o = t2.minutesWidthOnXAxis, l = t2.numberOfMinutes, h = o - (i - e.minMinute), c = e.minMinute + 1, d = c + 1, u = a, g = r, f = n, p = s;
    this.timeScaleArray.push({ position: h, value: c, unit: "minute", day: u, hour: p, minute: d, year: f, month: Utils.monthMod(g) });
    for (var x = h, m = 0; m < l; m++) {
      d >= 60 && (d = 0, 24 === (p += 1) && (p = 0));
      var b = n + Math.floor(g / 12) + 0;
      x = o + x;
      var v = d;
      this.timeScaleArray.push({ position: x, value: v, unit: "minute", hour: p, minute: d, day: u, year: b, month: Utils.monthMod(g) }), d++;
    }
  } }, { key: "createRawDateString", value: function(t2, e) {
    var i = t2.year;
    return i += "-" + ("0" + t2.month.toString()).slice(-2), "day" === t2.unit ? i += "day" === t2.unit ? "-" + ("0" + e).slice(-2) : "-01" : i += "-" + ("0" + (t2.day ? t2.day : "1")).slice(-2), "hour" === t2.unit ? i += "hour" === t2.unit ? "T" + ("0" + e).slice(-2) : "T00" : i += "T" + ("0" + (t2.hour ? t2.hour : "0")).slice(-2), i += "minute" === t2.unit ? ":" + ("0" + e).slice(-2) + ":00.000Z" : ":00:00.000Z";
  } }, { key: "formatDates", value: function(t2) {
    var e = this, i = this.w;
    return t2.map(function(t3) {
      var s = t3.value.toString(), a = new DateTime(e.ctx), r = e.createRawDateString(t3, s), n = new Date(Date.parse(r));
      if (void 0 === i.config.xaxis.labels.format) {
        var o = "dd MMM", l = i.config.xaxis.labels.datetimeFormatter;
        "year" === t3.unit && (o = l.year), "month" === t3.unit && (o = l.month), "day" === t3.unit && (o = l.day), "hour" === t3.unit && (o = l.hour), "minute" === t3.unit && (o = l.minute), s = a.formatDate(n, o, true, false);
      } else s = a.formatDate(n, i.config.xaxis.labels.format);
      return { dateString: r, position: t3.position, value: s, unit: t3.unit, year: t3.year, month: t3.month };
    });
  } }, { key: "removeOverlappingTS", value: function(t2) {
    var e = this, i = new Graphics(this.ctx), s = 0, a = t2.map(function(a2, r) {
      if (r > 0 && e.w.config.xaxis.labels.hideOverlappingLabels) {
        var n = i.getTextRects(t2[s].value).width, o = t2[s].position;
        return a2.position > o + n + 10 ? (s = r, a2) : null;
      }
      return a2;
    });
    return a = a.filter(function(t3) {
      return null !== t3;
    });
  } }]), t;
})();
var Core = (function() {
  function t(e, i) {
    _classCallCheck(this, t), this.ctx = i, this.w = i.w, this.el = e, this.coreUtils = new CoreUtils(this.ctx), this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [];
  }
  return _createClass(t, [{ key: "setupElements", value: function() {
    var t2 = this.w.globals, e = this.w.config, i = e.chart.type;
    t2.axisCharts = ["line", "area", "bar", "rangeBar", "candlestick", "radar", "scatter", "bubble", "heatmap"].indexOf(i) > -1, t2.xyCharts = ["line", "area", "bar", "rangeBar", "candlestick", "scatter", "bubble"].indexOf(i) > -1, t2.isBarHorizontal = ("bar" === e.chart.type || "rangeBar" === e.chart.type) && e.plotOptions.bar.horizontal, t2.chartClass = ".apexcharts" + t2.cuid, t2.dom.baseEl = this.el, t2.dom.elWrap = document.createElement("div"), Graphics.setAttrs(t2.dom.elWrap, { id: t2.chartClass.substring(1), class: "apexcharts-canvas " + t2.chartClass.substring(1) }), this.el.appendChild(t2.dom.elWrap), t2.dom.Paper = new window.SVG.Doc(t2.dom.elWrap), t2.dom.Paper.attr({ class: "apexcharts-svg", "xmlns:data": "ApexChartsNS", transform: "translate(".concat(e.chart.offsetX, ", ").concat(e.chart.offsetY, ")") }), t2.dom.Paper.node.style.background = e.chart.background, this.setSVGDimensions(), t2.dom.elGraphical = t2.dom.Paper.group().attr({ class: "apexcharts-inner apexcharts-graphical" }), t2.dom.elDefs = t2.dom.Paper.defs(), t2.dom.elLegendWrap = document.createElement("div"), t2.dom.elLegendWrap.classList.add("apexcharts-legend"), t2.dom.elWrap.appendChild(t2.dom.elLegendWrap), t2.dom.Paper.add(t2.dom.elGraphical), t2.dom.elGraphical.add(t2.dom.elDefs);
  } }, { key: "plotChartType", value: function(t2, e) {
    var i = this.w, s = i.config, a = i.globals, r = { series: [], i: [] }, n = { series: [], i: [] }, o = { series: [], i: [] }, l = { series: [], i: [] }, h = { series: [], i: [] };
    a.series.map(function(e2, s2) {
      void 0 !== t2[s2].type ? ("column" === t2[s2].type || "bar" === t2[s2].type ? (i.config.plotOptions.bar.horizontal = false, l.series.push(e2), l.i.push(s2)) : "area" === t2[s2].type ? (n.series.push(e2), n.i.push(s2)) : "line" === t2[s2].type ? (r.series.push(e2), r.i.push(s2)) : "scatter" === t2[s2].type ? (o.series.push(e2), o.i.push(s2)) : "bubble" === t2[s2].type || ("candlestick" === t2[s2].type ? (h.series.push(e2), h.i.push(s2)) : console.warn("You have specified an unrecognized chart type. Available types for this propery are line/area/column/bar/scatter/bubble")), a.comboCharts = true) : (r.series.push(e2), r.i.push(s2));
    });
    var c = new Line(this.ctx, e), d = new CandleStick(this.ctx, e), u = new Pie(this.ctx), g = new Radial(this.ctx), f = new RangeBar(this.ctx, e), p = new Radar(this.ctx), x = [];
    if (a.comboCharts) {
      if (n.series.length > 0 && x.push(c.draw(n.series, "area", n.i)), l.series.length > 0) if (i.config.chart.stacked) {
        var m = new BarStacked(this.ctx, e);
        x.push(m.draw(l.series, l.i));
      } else {
        var b = new Bar(this.ctx, e);
        x.push(b.draw(l.series, l.i));
      }
      if (r.series.length > 0 && x.push(c.draw(r.series, "line", r.i)), h.series.length > 0 && x.push(d.draw(h.series, h.i)), o.series.length > 0) {
        var v = new Line(this.ctx, e, true);
        x.push(v.draw(o.series, "scatter", o.i));
      }
    } else switch (s.chart.type) {
      case "line":
        x = c.draw(a.series, "line");
        break;
      case "area":
        x = c.draw(a.series, "area");
        break;
      case "bar":
        if (s.chart.stacked) x = new BarStacked(this.ctx, e).draw(a.series);
        else x = new Bar(this.ctx, e).draw(a.series);
        break;
      case "candlestick":
        x = new CandleStick(this.ctx, e).draw(a.series);
        break;
      case "rangeBar":
        x = f.draw(a.series);
        break;
      case "heatmap":
        x = new HeatMap(this.ctx, e).draw(a.series);
        break;
      case "pie":
      case "donut":
        x = u.draw(a.series);
        break;
      case "radialBar":
        x = g.draw(a.series);
        break;
      case "radar":
        x = p.draw(a.series);
        break;
      default:
        x = c.draw(a.series);
    }
    return x;
  } }, { key: "setSVGDimensions", value: function() {
    var t2 = this.w.globals, e = this.w.config;
    t2.svgWidth = e.chart.width, t2.svgHeight = e.chart.height;
    var i = Utils.getDimensions(this.el), s = e.chart.width.toString().split(/[0-9]+/g).pop();
    if ("%" === s ? Utils.isNumber(i[0]) && (0 === i[0].width && (i = Utils.getDimensions(this.el.parentNode)), t2.svgWidth = i[0] * parseInt(e.chart.width) / 100) : "px" !== s && "" !== s || (t2.svgWidth = parseInt(e.chart.width)), "auto" !== t2.svgHeight && "" !== t2.svgHeight) if ("%" === e.chart.height.toString().split(/[0-9]+/g).pop()) {
      var a = Utils.getDimensions(this.el.parentNode);
      t2.svgHeight = a[1] * parseInt(e.chart.height) / 100;
    } else t2.svgHeight = parseInt(e.chart.height);
    else t2.axisCharts ? t2.svgHeight = t2.svgWidth / 1.61 : t2.svgHeight = t2.svgWidth;
    t2.svgWidth < 0 && (t2.svgWidth = 0), t2.svgHeight < 0 && (t2.svgHeight = 0), Graphics.setAttrs(t2.dom.Paper.node, { width: t2.svgWidth, height: t2.svgHeight });
    var r = e.chart.sparkline.enabled ? 0 : t2.axisCharts ? e.chart.parentHeightOffset : 0;
    t2.dom.Paper.node.parentNode.parentNode.style.minHeight = t2.svgHeight + r + "px", t2.dom.elWrap.style.width = t2.svgWidth + "px", t2.dom.elWrap.style.height = t2.svgHeight + "px";
  } }, { key: "shiftGraphPosition", value: function() {
    var t2 = this.w.globals, e = t2.translateY, i = { transform: "translate(" + t2.translateX + ", " + e + ")" };
    Graphics.setAttrs(t2.dom.elGraphical.node, i);
  } }, { key: "resizeNonAxisCharts", value: function() {
    var t2 = this.w, e = t2.globals, i = 0;
    "top" !== t2.config.legend.position && "bottom" !== t2.config.legend.position || (i = new Legend(this.ctx).getLegendBBox().clwh + 10);
    var s = t2.globals.dom.baseEl.querySelector(".apexcharts-radialbar"), a = 2 * t2.globals.radialSize;
    s && -90 !== t2.config.plotOptions.radialBar.startAngle && (a = Utils.getBoundingClientRect(s).height);
    var r = Math.max(a, 2 * t2.globals.radialSize) + e.translateY + i + 20;
    e.dom.elLegendForeign && e.dom.elLegendForeign.setAttribute("height", r), e.dom.elWrap.style.height = r + "px", Graphics.setAttrs(e.dom.Paper.node, { height: r }), e.dom.Paper.node.parentNode.parentNode.style.minHeight = r + "px";
  } }, { key: "coreCalculations", value: function() {
    new Range$1(this.ctx).init();
  } }, { key: "resetGlobals", value: function() {
    var t2 = this, e = this.w.globals;
    e.series = [], e.seriesCandleO = [], e.seriesCandleH = [], e.seriesCandleL = [], e.seriesCandleC = [], e.seriesRangeStart = [], e.seriesRangeEnd = [], e.seriesPercent = [], e.seriesX = [], e.seriesZ = [], e.seriesNames = [], e.seriesTotals = [], e.stackedSeriesTotals = [], e.labels = [], e.timelineLabels = [], e.noLabelsProvided = false, e.timescaleTicks = [], e.resizeTimer = null, e.selectionResizeTimer = null, e.seriesXvalues = t2.w.config.series.map(function(t3) {
      return [];
    }), e.seriesYvalues = t2.w.config.series.map(function(t3) {
      return [];
    }), e.delayedElements = [], e.pointsArray = [], e.dataLabelsRects = [], e.isXNumeric = false, e.isDataXYZ = false, e.maxY = -Number.MAX_VALUE, e.minY = Number.MIN_VALUE, e.minYArr = [], e.maxYArr = [], e.maxX = -Number.MAX_VALUE, e.minX = Number.MAX_VALUE, e.initialmaxX = -Number.MAX_VALUE, e.initialminX = Number.MAX_VALUE, e.maxDate = 0, e.minDate = Number.MAX_VALUE, e.minZ = Number.MAX_VALUE, e.maxZ = -Number.MAX_VALUE, e.minXDiff = Number.MAX_VALUE, e.yAxisScale = [], e.xAxisScale = null, e.xAxisTicksPositions = [], e.yLabelsCoords = [], e.yTitleCoords = [], e.xRange = 0, e.yRange = [], e.zRange = 0, e.dataPoints = 0;
  } }, { key: "isMultipleY", value: function() {
    if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1) return this.w.globals.isMultipleYAxis = true, true;
  } }, { key: "excludeCollapsedSeriesInYAxis", value: function() {
    var t2 = this, e = this.w;
    e.globals.ignoreYAxisIndexes = e.globals.collapsedSeries.map(function(e2, i) {
      if (t2.w.globals.isMultipleYAxis) return e2.index;
    });
  } }, { key: "isMultiFormat", value: function() {
    return this.isFormatXY() || this.isFormat2DArray();
  } }, { key: "isFormatXY", value: function() {
    var t2 = this.w.config.series.slice(), e = new Series(this.ctx);
    if (this.activeSeriesIndex = e.getActiveConfigSeriesIndex(), void 0 !== t2[this.activeSeriesIndex].data && t2[this.activeSeriesIndex].data.length > 0 && null !== t2[this.activeSeriesIndex].data[0] && void 0 !== t2[this.activeSeriesIndex].data[0].x && null !== t2[this.activeSeriesIndex].data[0]) return true;
  } }, { key: "isFormat2DArray", value: function() {
    var t2 = this.w.config.series.slice(), e = new Series(this.ctx);
    if (this.activeSeriesIndex = e.getActiveConfigSeriesIndex(), void 0 !== t2[this.activeSeriesIndex].data && t2[this.activeSeriesIndex].data.length > 0 && void 0 !== t2[this.activeSeriesIndex].data[0] && null !== t2[this.activeSeriesIndex].data[0] && t2[this.activeSeriesIndex].data[0].constructor === Array) return true;
  } }, { key: "handleFormat2DArray", value: function(t2, e) {
    for (var i = this.w.config, s = this.w.globals, a = 0; a < t2[e].data.length; a++) if (void 0 !== t2[e].data[a][1] && (Array.isArray(t2[e].data[a][1]) && 4 === t2[e].data[a][1].length ? this.twoDSeries.push(Utils.parseNumber(t2[e].data[a][1][3])) : this.twoDSeries.push(Utils.parseNumber(t2[e].data[a][1])), s.dataFormatXNumeric = true), "datetime" === i.xaxis.type) {
      var r = new Date(t2[e].data[a][0]);
      r = new Date(r).getTime(), this.twoDSeriesX.push(r);
    } else this.twoDSeriesX.push(t2[e].data[a][0]);
    for (var n = 0; n < t2[e].data.length; n++) void 0 !== t2[e].data[n][2] && (this.threeDSeries.push(t2[e].data[n][2]), s.isDataXYZ = true);
  } }, { key: "handleFormatXY", value: function(t2, e) {
    var i = this.w.config, s = this.w.globals, a = new DateTime(this.ctx), r = e;
    s.collapsedSeriesIndices.indexOf(e) > -1 && (r = this.activeSeriesIndex);
    for (var n = 0; n < t2[e].data.length; n++) void 0 !== t2[e].data[n].y && (Array.isArray(t2[e].data[n].y) ? this.twoDSeries.push(Utils.parseNumber(t2[e].data[n].y[t2[e].data[n].y.length - 1])) : this.twoDSeries.push(Utils.parseNumber(t2[e].data[n].y)));
    for (var o = 0; o < t2[r].data.length; o++) {
      var l = "string" == typeof t2[r].data[o].x, h = !!a.isValidDate(t2[r].data[o].x.toString());
      l || h ? l ? "datetime" !== i.xaxis.type || s.isRangeData ? (this.fallbackToCategory = true, this.twoDSeriesX.push(t2[r].data[o].x)) : this.twoDSeriesX.push(a.parseDate(t2[r].data[o].x)) : "datetime" === i.xaxis.type ? this.twoDSeriesX.push(a.parseDate(t2[r].data[o].x.toString())) : (s.dataFormatXNumeric = true, s.isXNumeric = true, this.twoDSeriesX.push(parseFloat(t2[r].data[o].x))) : (s.isXNumeric = true, s.dataFormatXNumeric = true, this.twoDSeriesX.push(t2[r].data[o].x));
    }
    if (t2[e].data[0] && void 0 !== t2[e].data[0].z) {
      for (var c = 0; c < t2[e].data.length; c++) this.threeDSeries.push(t2[e].data[c].z);
      s.isDataXYZ = true;
    }
  } }, { key: "handleRangeData", value: function(t2, e) {
    var i = this.w.globals, s = {};
    return this.isFormat2DArray() ? s = this.handleRangeDataFormat("array", t2, e) : this.isFormatXY() && (s = this.handleRangeDataFormat("xy", t2, e)), i.seriesRangeStart.push(s.start), i.seriesRangeEnd.push(s.end), s;
  } }, { key: "handleCandleStickData", value: function(t2, e) {
    var i = this.w.globals, s = {};
    return this.isFormat2DArray() ? s = this.handleCandleStickDataFormat("array", t2, e) : this.isFormatXY() && (s = this.handleCandleStickDataFormat("xy", t2, e)), i.seriesCandleO.push(s.o), i.seriesCandleH.push(s.h), i.seriesCandleL.push(s.l), i.seriesCandleC.push(s.c), s;
  } }, { key: "handleRangeDataFormat", value: function(t2, e, i) {
    var s = [], a = [], r = "Please provide [Start, End] values in valid format. Read more https://apexcharts.com/docs/series/#rangecharts", n = new Series(this.ctx).getActiveConfigSeriesIndex();
    if ("array" === t2) {
      if (2 !== e[n].data[0][1].length) throw new Error(r);
      for (var o = 0; o < e[i].data.length; o++) s.push(e[i].data[o][1][0]), a.push(e[i].data[o][1][1]);
    } else if ("xy" === t2) {
      if (2 !== e[n].data[0].y.length) throw new Error(r);
      for (var l = 0; l < e[i].data.length; l++) s.push(e[i].data[l].y[0]), a.push(e[i].data[l].y[1]);
    }
    return { start: s, end: a };
  } }, { key: "handleCandleStickDataFormat", value: function(t2, e, i) {
    var s = [], a = [], r = [], n = [], o = "Please provide [Open, High, Low and Close] values in valid format. Read more https://apexcharts.com/docs/series/#candlestick";
    if ("array" === t2) {
      if (4 !== e[i].data[0][1].length) throw new Error(o);
      for (var l = 0; l < e[i].data.length; l++) s.push(e[i].data[l][1][0]), a.push(e[i].data[l][1][1]), r.push(e[i].data[l][1][2]), n.push(e[i].data[l][1][3]);
    } else if ("xy" === t2) {
      if (4 !== e[i].data[0].y.length) throw new Error(o);
      for (var h = 0; h < e[i].data.length; h++) s.push(e[i].data[h].y[0]), a.push(e[i].data[h].y[1]), r.push(e[i].data[h].y[2]), n.push(e[i].data[h].y[3]);
    }
    return { o: s, h: a, l: r, c: n };
  } }, { key: "parseDataAxisCharts", value: function(t2) {
    for (var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.ctx, i = this.w.config, s = this.w.globals, a = new DateTime(e), r = 0; r < t2.length; r++) {
      if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], void 0 === t2[r].data) return void console.error("It is a possibility that you may have not included 'data' property in series.");
      if ("rangeBar" !== i.chart.type && "rangeArea" !== i.chart.type && "rangeBar" !== t2[r].type && "rangeArea" !== t2[r].type || (s.isRangeData = true, this.handleRangeData(t2, r)), this.isMultiFormat()) this.isFormat2DArray() ? this.handleFormat2DArray(t2, r) : this.isFormatXY() && this.handleFormatXY(t2, r), "candlestick" !== i.chart.type && "candlestick" !== t2[r].type || this.handleCandleStickData(t2, r), s.series.push(this.twoDSeries), s.labels.push(this.twoDSeriesX), s.seriesX.push(this.twoDSeriesX), this.fallbackToCategory || (s.isXNumeric = true);
      else {
        if ("datetime" === i.xaxis.type) {
          s.isXNumeric = true;
          for (var n = i.labels.length > 0 ? i.labels.slice() : i.xaxis.categories.slice(), o = 0; o < n.length; o++) if ("string" == typeof n[o]) {
            if (!a.isValidDate(n[o])) throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
            this.twoDSeriesX.push(a.parseDate(n[o]));
          } else {
            if (13 !== String(n[o]).length) throw new Error("Please provide a valid JavaScript timestamp");
            this.twoDSeriesX.push(n[o]);
          }
          s.seriesX.push(this.twoDSeriesX);
        } else if ("numeric" === i.xaxis.type) {
          s.isXNumeric = true;
          var l = i.labels.length > 0 ? i.labels.slice() : i.xaxis.categories.slice();
          l.length > 0 && (this.twoDSeriesX = l, s.seriesX.push(this.twoDSeriesX));
        }
        s.labels.push(this.twoDSeriesX);
        var h = t2[r].data.map(function(t3) {
          return Utils.parseNumber(t3);
        });
        s.series.push(h);
      }
      s.seriesZ.push(this.threeDSeries), void 0 !== t2[r].name ? s.seriesNames.push(t2[r].name) : s.seriesNames.push("series-" + parseInt(r + 1));
    }
    return this.w;
  } }, { key: "parseDataNonAxisCharts", value: function(t2) {
    var e = this.w.globals, i = this.w.config;
    e.series = t2.slice(), e.seriesNames = i.labels.slice();
    for (var s = 0; s < e.series.length; s++) void 0 === e.seriesNames[s] && e.seriesNames.push("series-" + (s + 1));
    return this.w;
  } }, { key: "handleExternalLabelsData", value: function(t2) {
    var e = this.w.config, i = this.w.globals;
    if (e.xaxis.categories.length > 0) i.labels = e.xaxis.categories;
    else if (e.labels.length > 0) i.labels = e.labels.slice();
    else if (this.fallbackToCategory) i.labels = i.labels[0];
    else {
      var s = [];
      if (i.axisCharts) {
        if (i.series.length > 0) for (var a = 0; a < i.series[i.maxValsInArrayIndex].length; a++) s.push(a + 1);
        for (var r = 0; r < t2.length; r++) i.seriesX.push(s);
        i.isXNumeric = true;
      }
      if (0 === s.length) {
        s = [0, 10];
        for (var n = 0; n < t2.length; n++) i.seriesX.push(s);
      }
      i.labels = s, i.noLabelsProvided = true;
    }
  } }, { key: "parseData", value: function(t2) {
    var e = this.w, i = e.config, s = e.globals;
    if (this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = false, this.resetGlobals(), this.isMultipleY(), s.axisCharts ? this.parseDataAxisCharts(t2) : this.parseDataNonAxisCharts(t2), this.coreUtils.getLargestSeries(), "bar" === i.chart.type && i.chart.stacked) {
      var a = new Series(this.ctx);
      s.series = a.setNullSeriesToZeroValues(s.series);
    }
    this.coreUtils.getSeriesTotals(), s.axisCharts && this.coreUtils.getStackedSeriesTotals(), this.coreUtils.getPercentSeries(), s.dataFormatXNumeric || s.isXNumeric && ("numeric" !== i.xaxis.type || 0 !== i.labels.length || 0 !== i.xaxis.categories.length) || this.handleExternalLabelsData(t2);
  } }, { key: "xySettings", value: function() {
    var t2 = null, e = this.w;
    if (e.globals.axisCharts) {
      if ("back" === e.config.xaxis.crosshairs.position) new Crosshairs(this.ctx).drawXCrosshairs();
      if ("back" === e.config.yaxis[0].crosshairs.position) new Crosshairs(this.ctx).drawYCrosshairs();
      if (t2 = this.coreUtils.getCalculatedRatios(), "datetime" === e.config.xaxis.type && void 0 === e.config.xaxis.labels.formatter) {
        var i, s = new TimeScale(this.ctx);
        isFinite(e.globals.minX) && isFinite(e.globals.maxX) && !e.globals.isBarHorizontal ? (i = s.calculateTimeScaleTicks(e.globals.minX, e.globals.maxX), s.recalcDimensionsBasedOnFormat(i, false)) : e.globals.isBarHorizontal && (i = s.calculateTimeScaleTicks(e.globals.minY, e.globals.maxY), s.recalcDimensionsBasedOnFormat(i, true));
      }
    }
    return t2;
  } }, { key: "drawAxis", value: function(t2, e) {
    var i, s, a = this.w.globals, r = this.w.config, n = new XAxis(this.ctx), o = new YAxis(this.ctx);
    a.axisCharts && "radar" !== t2 && (a.isBarHorizontal ? (s = o.drawYaxisInversed(0), i = n.drawXaxisInversed(0), a.dom.elGraphical.add(i), a.dom.elGraphical.add(s)) : (i = n.drawXaxis(), a.dom.elGraphical.add(i), r.yaxis.map(function(t3, e2) {
      -1 === a.ignoreYAxisIndexes.indexOf(e2) && (s = o.drawYaxis(e2), a.dom.Paper.add(s));
    })));
    r.yaxis.map(function(t3, e2) {
      -1 === a.ignoreYAxisIndexes.indexOf(e2) && o.yAxisTitleRotate(e2, t3.opposite);
    });
  } }, { key: "setupBrushHandler", value: function() {
    var t2 = this, e = this.w;
    if (e.config.chart.brush.enabled && "function" != typeof e.config.chart.events.selection) {
      var i = e.config.chart.brush.targets || [e.config.chart.brush.target];
      i.forEach(function(e2) {
        var i2 = ApexCharts.getChartByID(e2);
        i2.w.globals.brushSource = t2.ctx;
        var s = function() {
          t2.ctx._updateOptions({ chart: { selection: { xaxis: { min: i2.w.globals.minX, max: i2.w.globals.maxX } } } }, false, false);
        };
        "function" != typeof i2.w.config.chart.events.zoomed && (i2.w.config.chart.events.zoomed = function() {
          s();
        }), "function" != typeof i2.w.config.chart.events.scrolled && (i2.w.config.chart.events.scrolled = function() {
          s();
        });
      }), e.config.chart.events.selection = function(t3, s) {
        i.forEach(function(t4) {
          var i2 = ApexCharts.getChartByID(t4), a = Utils.clone(e.config.yaxis);
          e.config.chart.brush.autoScaleYaxis && (a = new Range(i2).autoScaleY(i2, a, s));
          i2._updateOptions({ xaxis: { min: s.xaxis.min, max: s.xaxis.max }, yaxis: a }, false, false, false, false);
        });
      };
    }
  } }]), t;
})();
function finallyConstructor(t) {
  var e = this.constructor;
  return this.then(function(i) {
    return e.resolve(t()).then(function() {
      return i;
    });
  }, function(i) {
    return e.resolve(t()).then(function() {
      return e.reject(i);
    });
  });
}
var setTimeoutFunc = setTimeout;
function noop() {
}
function bind(t, e) {
  return function() {
    t.apply(e, arguments);
  };
}
function Promise$1(t) {
  if (!(this instanceof Promise$1)) throw new TypeError("Promises must be constructed via new");
  if ("function" != typeof t) throw new TypeError("not a function");
  this._state = 0, this._handled = false, this._value = void 0, this._deferreds = [], doResolve(t, this);
}
function handle(t, e) {
  for (; 3 === t._state; ) t = t._value;
  0 !== t._state ? (t._handled = true, Promise$1._immediateFn(function() {
    var i = 1 === t._state ? e.onFulfilled : e.onRejected;
    if (null !== i) {
      var s;
      try {
        s = i(t._value);
      } catch (t2) {
        return void reject(e.promise, t2);
      }
      resolve(e.promise, s);
    } else (1 === t._state ? resolve : reject)(e.promise, t._value);
  })) : t._deferreds.push(e);
}
function resolve(t, e) {
  try {
    if (e === t) throw new TypeError("A promise cannot be resolved with itself.");
    if (e && ("object" == typeof e || "function" == typeof e)) {
      var i = e.then;
      if (e instanceof Promise$1) return t._state = 3, t._value = e, void finale(t);
      if ("function" == typeof i) return void doResolve(bind(i, e), t);
    }
    t._state = 1, t._value = e, finale(t);
  } catch (e2) {
    reject(t, e2);
  }
}
function reject(t, e) {
  t._state = 2, t._value = e, finale(t);
}
function finale(t) {
  2 === t._state && 0 === t._deferreds.length && Promise$1._immediateFn(function() {
    t._handled || Promise$1._unhandledRejectionFn(t._value);
  });
  for (var e = 0, i = t._deferreds.length; e < i; e++) handle(t, t._deferreds[e]);
  t._deferreds = null;
}
function Handler(t, e, i) {
  this.onFulfilled = "function" == typeof t ? t : null, this.onRejected = "function" == typeof e ? e : null, this.promise = i;
}
function doResolve(t, e) {
  var i = false;
  try {
    t(function(t2) {
      i || (i = true, resolve(e, t2));
    }, function(t2) {
      i || (i = true, reject(e, t2));
    });
  } catch (t2) {
    if (i) return;
    i = true, reject(e, t2);
  }
}
Promise$1.prototype.catch = function(t) {
  return this.then(null, t);
}, Promise$1.prototype.then = function(t, e) {
  var i = new this.constructor(noop);
  return handle(this, new Handler(t, e, i)), i;
}, Promise$1.prototype.finally = finallyConstructor, Promise$1.all = function(t) {
  return new Promise$1(function(e, i) {
    if (!t || void 0 === t.length) throw new TypeError("Promise.all accepts an array");
    var s = Array.prototype.slice.call(t);
    if (0 === s.length) return e([]);
    var a = s.length;
    function r(t2, n2) {
      try {
        if (n2 && ("object" == typeof n2 || "function" == typeof n2)) {
          var o = n2.then;
          if ("function" == typeof o) return void o.call(n2, function(e2) {
            r(t2, e2);
          }, i);
        }
        s[t2] = n2, 0 == --a && e(s);
      } catch (t3) {
        i(t3);
      }
    }
    for (var n = 0; n < s.length; n++) r(n, s[n]);
  });
}, Promise$1.resolve = function(t) {
  return t && "object" == typeof t && t.constructor === Promise$1 ? t : new Promise$1(function(e) {
    e(t);
  });
}, Promise$1.reject = function(t) {
  return new Promise$1(function(e, i) {
    i(t);
  });
}, Promise$1.race = function(t) {
  return new Promise$1(function(e, i) {
    for (var s = 0, a = t.length; s < a; s++) t[s].then(e, i);
  });
}, Promise$1._immediateFn = "function" == typeof setImmediate && function(t) {
  setImmediate(t);
} || function(t) {
  setTimeoutFunc(t, 0);
}, Promise$1._unhandledRejectionFn = function(t) {
  "undefined" != typeof console && console && console.warn("Possible Unhandled Promise Rejection:", t);
};
var Exports = (function() {
  function t(e) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w;
  }
  return _createClass(t, [{ key: "getSvgString", value: function() {
    return this.w.globals.dom.Paper.svg();
  } }, { key: "cleanup", value: function() {
    var t2 = this.w, e = t2.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs"), i = t2.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs");
    e && e.setAttribute("x", -500), i && (i.setAttribute("y1", -100), i.setAttribute("y2", -100));
  } }, { key: "svgUrl", value: function() {
    this.cleanup();
    var t2 = this.getSvgString(), e = new Blob([t2], { type: "image/svg+xml;charset=utf-8" });
    return URL.createObjectURL(e);
  } }, { key: "dataURI", value: function() {
    var t2 = this;
    return new Promise$1(function(e) {
      var i = t2.w;
      t2.cleanup();
      var s = document.createElement("canvas");
      s.width = i.globals.svgWidth, s.height = parseInt(i.globals.dom.elWrap.style.height);
      var a = "transparent" === i.config.chart.background ? "#fff" : i.config.chart.background, r = s.getContext("2d");
      r.fillStyle = a, r.fillRect(0, 0, s.width, s.height);
      var n = window.URL || window.webkitURL || window, o = new Image();
      o.crossOrigin = "anonymous";
      var l = t2.getSvgString(), h = "data:image/svg+xml," + encodeURIComponent(l);
      o.onload = function() {
        r.drawImage(o, 0, 0), n.revokeObjectURL(h);
        var t3 = s.toDataURL("image/png");
        e(t3);
      }, o.src = h;
    });
  } }, { key: "exportToSVG", value: function() {
    this.triggerDownload(this.svgUrl(), ".svg");
  } }, { key: "exportToPng", value: function() {
    var t2 = this;
    this.dataURI().then(function(e) {
      t2.triggerDownload(e, ".png");
    });
  } }, { key: "triggerDownload", value: function(t2, e) {
    var i = document.createElement("a");
    i.href = t2, i.download = this.w.globals.chartID + e, document.body.appendChild(i), i.click(), document.body.removeChild(i);
  } }]), t;
})();
var Grid = (function() {
  function t(e) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w;
    var i = this.w;
    this.anim = new Animations(this.ctx), this.xaxisLabels = i.globals.labels.slice(), this.animX = i.config.grid.xaxis.lines.animate && i.config.chart.animations.enabled, this.animY = i.config.grid.yaxis.lines.animate && i.config.chart.animations.enabled, i.globals.timelineLabels.length > 0 && (this.xaxisLabels = i.globals.timelineLabels.slice());
  }
  return _createClass(t, [{ key: "drawGridArea", value: function() {
    var t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, e = this.w, i = new Graphics(this.ctx);
    null === t2 && (t2 = i.group({ class: "apexcharts-grid" }));
    var s = i.drawLine(e.globals.padHorizontal, 1, e.globals.padHorizontal, e.globals.gridHeight, "transparent"), a = i.drawLine(e.globals.padHorizontal, e.globals.gridHeight, e.globals.gridWidth, e.globals.gridHeight, "transparent");
    return t2.add(a), t2.add(s), t2;
  } }, { key: "drawGrid", value: function() {
    var t2 = this.w, e = new XAxis(this.ctx), i = new YAxis(this.ctx), s = this.w.globals, a = null;
    if (s.axisCharts) {
      if (t2.config.grid.show) a = this.renderGrid(), s.dom.elGraphical.add(a.el), this.drawGridArea(a.el);
      else {
        var r = this.drawGridArea();
        s.dom.elGraphical.add(r);
      }
      null !== a && e.xAxisLabelCorrections(a.xAxisTickWidth), i.setYAxisTextAlignments();
    }
  } }, { key: "createGridMask", value: function() {
    var t2 = this.w, e = t2.globals, i = new Graphics(this.ctx), s = Array.isArray(t2.config.stroke.width) ? 0 : t2.config.stroke.width;
    if (Array.isArray(t2.config.stroke.width)) {
      var a = 0;
      t2.config.stroke.width.forEach(function(t3) {
        a = Math.max(a, t3);
      }), s = a;
    }
    e.dom.elGridRectMask = document.createElementNS(e.SVGNS, "clipPath"), e.dom.elGridRectMask.setAttribute("id", "gridRectMask".concat(e.cuid)), e.dom.elGridRectMarkerMask = document.createElementNS(e.SVGNS, "clipPath"), e.dom.elGridRectMarkerMask.setAttribute("id", "gridRectMarkerMask".concat(e.cuid)), e.dom.elGridRect = i.drawRect(-s / 2, -s / 2, e.gridWidth + s, e.gridHeight + s, 0, "#fff"), new CoreUtils(this).getLargestMarkerSize();
    var r = t2.globals.markers.largestSize + 1;
    e.dom.elGridRectMarker = i.drawRect(-r, -r, e.gridWidth + 2 * r, e.gridHeight + 2 * r, 0, "#fff"), e.dom.elGridRectMask.appendChild(e.dom.elGridRect.node), e.dom.elGridRectMarkerMask.appendChild(e.dom.elGridRectMarker.node);
    var n = e.dom.baseEl.querySelector("defs");
    n.appendChild(e.dom.elGridRectMask), n.appendChild(e.dom.elGridRectMarkerMask);
  } }, { key: "renderGrid", value: function() {
    var t2 = this.w, e = new Graphics(this.ctx), i = t2.config.grid.strokeDashArray, s = e.group({ class: "apexcharts-grid" }), a = e.group({ class: "apexcharts-gridlines-horizontal" }), r = e.group({ class: "apexcharts-gridlines-vertical" });
    s.add(a), s.add(r);
    for (var n, o = 8, l = 0; l < t2.globals.series.length && (void 0 !== t2.globals.yAxisScale[l] && (o = t2.globals.yAxisScale[l].result.length - 1), !(o > 2)); l++) ;
    if (t2.globals.isBarHorizontal) {
      if (n = o, t2.config.grid.xaxis.lines.show || t2.config.xaxis.axisTicks.show) for (var h, c = t2.globals.padHorizontal, d = t2.globals.gridHeight, u = 0; u < n + 1 && (h = c = c + t2.globals.gridWidth / n + 0.3, u !== n - 1); u++) {
        if (t2.config.grid.xaxis.lines.show) {
          var g = e.drawLine(c, 0, h, d, t2.config.grid.borderColor, i);
          g.node.classList.add("apexcharts-gridline"), r.add(g), this.animX && this.animateLine(g, { x1: 0, x2: 0 }, { x1: c, x2: h });
        }
        new XAxis(this.ctx).drawXaxisTicks(c, s);
      }
      if (t2.config.grid.yaxis.lines.show) for (var f = 0, p = 0, x = t2.globals.gridWidth, m = 0; m < t2.globals.dataPoints + 1; m++) {
        var b = e.drawLine(0, f, x, p, t2.config.grid.borderColor, i);
        a.add(b), b.node.classList.add("apexcharts-gridline"), this.animY && this.animateLine(b, { y1: f + 20, y2: p + 20 }, { y1: f, y2: p }), p = f += t2.globals.gridHeight / t2.globals.dataPoints;
      }
    } else {
      if (n = this.xaxisLabels.length, t2.config.grid.xaxis.lines.show || t2.config.xaxis.axisTicks.show) {
        var v, y = t2.globals.padHorizontal, w = t2.globals.gridHeight;
        if (t2.globals.timelineLabels.length > 0) for (var k = 0; k < n; k++) {
          if (y = this.xaxisLabels[k].position, v = this.xaxisLabels[k].position, t2.config.grid.xaxis.lines.show && y > 0 && y < t2.globals.gridWidth) {
            var A = e.drawLine(y, 0, v, w, t2.config.grid.borderColor, i);
            A.node.classList.add("apexcharts-gridline"), r.add(A), this.animX && this.animateLine(A, { x1: 0, x2: 0 }, { x1: y, x2: v });
          }
          var S = new XAxis(this.ctx);
          k === n - 1 && t2.globals.skipLastTimelinelabel || S.drawXaxisTicks(y, s);
        }
        else for (var C = n, L = 0; L < C; L++) {
          var P = C;
          if (t2.globals.isXNumeric && "bar" !== t2.config.chart.type && (P -= 1), v = y += t2.globals.gridWidth / P, L === P - 1) break;
          if (t2.config.grid.xaxis.lines.show) {
            var z = e.drawLine(y, 0, v, w, t2.config.grid.borderColor, i);
            z.node.classList.add("apexcharts-gridline"), r.add(z), this.animX && this.animateLine(z, { x1: 0, x2: 0 }, { x1: y, x2: v });
          }
          new XAxis(this.ctx).drawXaxisTicks(y, s);
        }
      }
      if (t2.config.grid.yaxis.lines.show) for (var T = 0, M = 0, E = t2.globals.gridWidth, X = 0; X < o + 1; X++) {
        var I = e.drawLine(0, T, E, M, t2.config.grid.borderColor, i);
        a.add(I), I.node.classList.add("apexcharts-gridline"), this.animY && this.animateLine(I, { y1: T + 20, y2: M + 20 }, { y1: T, y2: M }), M = T += t2.globals.gridHeight / o;
      }
    }
    return this.drawGridBands(s, n, o), { el: s, xAxisTickWidth: t2.globals.gridWidth / n };
  } }, { key: "drawGridBands", value: function(t2, e, i) {
    var s = this.w, a = new Graphics(this.ctx);
    if (void 0 !== s.config.grid.row.colors && s.config.grid.row.colors.length > 0) for (var r = 0, n = s.globals.gridHeight / i, o = s.globals.gridWidth, l = 0, h = 0; l < i; l++, h++) {
      h >= s.config.grid.row.colors.length && (h = 0);
      var c = s.config.grid.row.colors[h], d = a.drawRect(0, r, o, n, 0, c, s.config.grid.row.opacity);
      t2.add(d), d.node.classList.add("apexcharts-gridRow"), r += s.globals.gridHeight / i;
    }
    if (void 0 !== s.config.grid.column.colors && s.config.grid.column.colors.length > 0) for (var u = s.globals.padHorizontal, g = s.globals.padHorizontal + s.globals.gridWidth / e, f = s.globals.gridHeight, p = 0, x = 0; p < e; p++, x++) {
      x >= s.config.grid.column.colors.length && (x = 0);
      var m = s.config.grid.column.colors[x], b = a.drawRect(u, 0, g, f, 0, m, s.config.grid.column.opacity);
      b.node.classList.add("apexcharts-gridColumn"), t2.add(b), u += s.globals.gridWidth / e;
    }
  } }, { key: "animateLine", value: function(t2, e, i) {
    var s = this.w, a = s.config.chart.animations;
    if (a && !s.globals.resized && !s.globals.dataChanged) {
      var r = a.speed;
      this.anim.animateLine(t2, e, i, r);
    }
  } }]), t;
})();
var Responsive = (function() {
  function t(e) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w;
  }
  return _createClass(t, [{ key: "checkResponsiveConfig", value: function(t2) {
    var e = this, i = this.w, s = i.config;
    if (0 !== s.responsive.length) {
      var a = s.responsive.slice();
      a.sort(function(t3, e2) {
        return t3.breakpoint > e2.breakpoint ? 1 : e2.breakpoint > t3.breakpoint ? -1 : 0;
      }).reverse();
      var r = new Config({}), n = function() {
        var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, s2 = a[0].breakpoint, n2 = window.innerWidth > 0 ? window.innerWidth : screen.width;
        if (n2 > s2) {
          var o2 = CoreUtils.extendArrayProps(r, i.globals.initialConfig);
          t3 = Utils.extend(o2, t3), t3 = Utils.extend(i.config, t3), e.overrideResponsiveOptions(t3);
        } else for (var l = 0; l < a.length; l++) n2 < a[l].breakpoint && (t3 = CoreUtils.extendArrayProps(r, a[l].options), t3 = Utils.extend(i.config, t3), e.overrideResponsiveOptions(t3));
      };
      if (t2) {
        var o = CoreUtils.extendArrayProps(r, t2);
        o = Utils.extend(i.config, o), n(o = Utils.extend(o, t2));
      } else n({});
    }
  } }, { key: "overrideResponsiveOptions", value: function(t2) {
    var e = new Config(t2).init();
    this.w.config = e;
  } }]), t;
})();
var Theme = (function() {
  function t(e) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.colors = [];
  }
  return _createClass(t, [{ key: "init", value: function() {
    this.setDefaultColors();
  } }, { key: "setDefaultColors", value: function() {
    var t2 = this.w, e = new Utils();
    if (t2.globals.dom.elWrap.classList.add(t2.config.theme.mode), void 0 === t2.config.colors ? t2.globals.colors = this.predefined() : t2.globals.colors = t2.config.colors, t2.config.theme.monochrome.enabled) {
      var i = [], s = t2.globals.series.length;
      t2.config.plotOptions.bar.distributed && "bar" === t2.config.chart.type && (s = t2.globals.series[0].length * t2.globals.series.length);
      for (var a = t2.config.theme.monochrome.color, r = 1 / (s / t2.config.theme.monochrome.shadeIntensity), n = t2.config.theme.monochrome.shadeTo, o = 0, l = 0; l < s; l++) {
        var h = void 0;
        "dark" === n ? (h = e.shadeColor(-1 * o, a), o += r) : (h = e.shadeColor(o, a), o += r), i.push(h);
      }
      t2.globals.colors = i.slice();
    }
    var c = t2.globals.colors.slice();
    this.pushExtraColors(t2.globals.colors), void 0 === t2.config.stroke.colors ? t2.globals.stroke.colors = c : t2.globals.stroke.colors = t2.config.stroke.colors, this.pushExtraColors(t2.globals.stroke.colors), void 0 === t2.config.fill.colors ? t2.globals.fill.colors = c : t2.globals.fill.colors = t2.config.fill.colors, this.pushExtraColors(t2.globals.fill.colors), void 0 === t2.config.dataLabels.style.colors ? t2.globals.dataLabels.style.colors = c : t2.globals.dataLabels.style.colors = t2.config.dataLabels.style.colors, this.pushExtraColors(t2.globals.dataLabels.style.colors, 50), void 0 === t2.config.plotOptions.radar.polygons.fill.colors ? t2.globals.radarPolygons.fill.colors = ["dark" === t2.config.theme.mode ? "#202D48" : "#fff"] : t2.globals.radarPolygons.fill.colors = t2.config.plotOptions.radar.polygons.fill.colors, this.pushExtraColors(t2.globals.radarPolygons.fill.colors, 20), void 0 === t2.config.markers.colors ? t2.globals.markers.colors = c : t2.globals.markers.colors = t2.config.markers.colors, this.pushExtraColors(t2.globals.markers.colors);
  } }, { key: "pushExtraColors", value: function(t2, e) {
    var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s = this.w, a = e || s.globals.series.length;
    if (null === i && (i = "bar" === s.config.chart.type && s.config.plotOptions.bar.distributed || "heatmap" === s.config.chart.type && s.config.plotOptions.heatmap.colorScale.inverse), i && (a = s.globals.series[0].length * s.globals.series.length), t2.length < a) for (var r = a - t2.length, n = 0; n < r; n++) t2.push(t2[n]);
  } }, { key: "updateThemeOptions", value: function(t2) {
    t2.chart = t2.chart || {}, t2.tooltip = t2.tooltip || {};
    var e = t2.theme.mode || "light", i = t2.theme.palette ? t2.theme.palette : "dark" === e ? "palette4" : "palette1", s = t2.chart.foreColor ? t2.chart.foreColor : "dark" === e ? "#f6f7f8" : "#373d3f";
    return t2.tooltip.theme = e, t2.chart.foreColor = s, t2.theme.palette = i, t2;
  } }, { key: "predefined", value: function() {
    switch (this.w.config.theme.palette) {
      case "palette1":
        this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"];
        break;
      case "palette2":
        this.colors = ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"];
        break;
      case "palette3":
        this.colors = ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"];
        break;
      case "palette4":
        this.colors = ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"];
        break;
      case "palette5":
        this.colors = ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"];
        break;
      case "palette6":
        this.colors = ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"];
        break;
      case "palette7":
        this.colors = ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"];
        break;
      case "palette8":
        this.colors = ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"];
        break;
      case "palette9":
        this.colors = ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"];
        break;
      case "palette10":
        this.colors = ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"];
        break;
      default:
        this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"];
    }
    return this.colors;
  } }]), t;
})();
var Utils$1 = (function() {
  function t(e) {
    _classCallCheck(this, t), this.w = e.w, this.ttCtx = e, this.ctx = e.ctx;
  }
  return _createClass(t, [{ key: "getNearestValues", value: function(t2) {
    var e = t2.hoverArea, i = t2.elGrid, s = t2.clientX, a = t2.clientY, r = t2.hasBars, n = this.w, o = n.globals.gridWidth, l = o / (n.globals.dataPoints - 1), h = i.getBoundingClientRect();
    (r && n.globals.comboCharts || r) && (l = o / n.globals.dataPoints);
    var c = s - h.left, d = a - h.top;
    c < 0 || d < 0 || c > n.globals.gridWidth || d > n.globals.gridHeight ? (e.classList.remove("hovering-zoom"), e.classList.remove("hovering-pan")) : n.globals.zoomEnabled ? (e.classList.remove("hovering-pan"), e.classList.add("hovering-zoom")) : n.globals.panEnabled && (e.classList.remove("hovering-zoom"), e.classList.add("hovering-pan"));
    var u = Math.round(c / l);
    r && (u = Math.ceil(c / l), u -= 1);
    for (var g, f = null, p = null, x = [], m = 0; m < n.globals.seriesXvalues.length; m++) x.push([n.globals.seriesXvalues[m][0] - 1e-6].concat(n.globals.seriesXvalues[m]));
    return x = x.map(function(t3) {
      return t3.filter(function(t4) {
        return t4;
      });
    }), g = n.globals.seriesYvalues.map(function(t3) {
      return t3.filter(function(t4) {
        return t4;
      });
    }), n.globals.isXNumeric && (f = (p = this.closestInMultiArray(c, d, x, g)).index, u = p.j, null !== f && (x = n.globals.seriesXvalues[f], u = (p = this.closestInArray(c, x)).index)), n.globals.capturedSeriesIndex = null === f ? -1 : f, n.globals.capturedDataPointIndex = null === u ? -1 : u, (!u || u < 1) && (u = 0), { capturedSeries: f, j: u, hoverX: c, hoverY: d };
  } }, { key: "closestInMultiArray", value: function(t2, e, i, s) {
    var a = this.w, r = 0, n = null, o = -1;
    a.globals.series.length > 1 ? r = this.getFirstActiveXArray(i) : n = 0;
    var l = s[r][0], h = i[r][0], c = Math.abs(t2 - h), d = Math.abs(e - l), u = d + c;
    return s.map(function(a2, r2) {
      a2.map(function(a3, l2) {
        var h2 = Math.abs(e - s[r2][l2]), g = Math.abs(t2 - i[r2][l2]), f = g + h2;
        f < u && (u = f, c = g, d = h2, n = r2, o = l2);
      });
    }), { index: n, j: o };
  } }, { key: "getFirstActiveXArray", value: function(t2) {
    for (var e = 0, i = new CoreUtils(this.ctx), s = t2.map(function(t3, e2) {
      return t3.length > 0 ? e2 : -1;
    }), a = 0; a < s.length; a++) {
      var r = i.getSeriesTotalByIndex(a);
      if (-1 !== s[a] && 0 !== r && !i.seriesHaveSameValues(a)) {
        e = s[a];
        break;
      }
    }
    return e;
  } }, { key: "closestInArray", value: function(t2, e) {
    for (var i = e[0], s = null, a = Math.abs(t2 - i), r = 0; r < e.length; r++) {
      var n = Math.abs(t2 - e[r]);
      n < a && (a = n, s = r);
    }
    return { index: s };
  } }, { key: "isXoverlap", value: function(t2) {
    var e = [], i = this.w.globals.seriesX.filter(function(t3) {
      return void 0 !== t3[0];
    });
    if (i.length > 0) for (var s = 0; s < i.length - 1; s++) void 0 !== i[s][t2] && void 0 !== i[s + 1][t2] && i[s][t2] !== i[s + 1][t2] && e.push("unEqual");
    return 0 === e.length;
  } }, { key: "isInitialSeriesSameLen", value: function() {
    for (var t2 = true, e = this.w.globals.initialSeries, i = 0; i < e.length - 1; i++) if (e[i].data.length !== e[i + 1].data.length) {
      t2 = false;
      break;
    }
    return t2;
  } }, { key: "getBarsHeight", value: function(t2) {
    return _toConsumableArray(t2).reduce(function(t3, e) {
      return t3 + e.getBBox().height;
    }, 0);
  } }, { key: "toggleAllTooltipSeriesGroups", value: function(t2) {
    var e = this.w, i = this.ttCtx;
    0 === i.allTooltipSeriesGroups.length && (i.allTooltipSeriesGroups = e.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));
    for (var s = i.allTooltipSeriesGroups, a = 0; a < s.length; a++) "enable" === t2 ? (s[a].classList.add("active"), s[a].style.display = e.config.tooltip.items.display) : (s[a].classList.remove("active"), s[a].style.display = "none");
  } }]), t;
})();
var Labels = (function() {
  function t(e) {
    _classCallCheck(this, t), this.w = e.w, this.ctx = e.ctx, this.ttCtx = e, this.tooltipUtil = new Utils$1(e);
  }
  return _createClass(t, [{ key: "drawSeriesTexts", value: function(t2) {
    var e = t2.shared, i = void 0 === e || e, s = t2.ttItems, a = t2.i, r = void 0 === a ? 0 : a, n = t2.j, o = void 0 === n ? null : n;
    void 0 !== this.w.config.tooltip.custom ? this.handleCustomTooltip({ i: r, j: o }) : this.toggleActiveInactiveSeries(i);
    var l = this.getValuesToPrint({ i: r, j: o });
    this.printLabels({ i: r, j: o, values: l, ttItems: s, shared: i });
    var h = this.ttCtx.getElTooltip();
    this.ttCtx.tooltipRect.ttWidth = h.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = h.getBoundingClientRect().height;
  } }, { key: "printLabels", value: function(t2) {
    var e, i = t2.i, s = t2.j, a = t2.values, r = t2.ttItems, n = t2.shared, o = this.w, l = a.xVal, h = a.zVal, c = a.xAxisTTVal, d = "", u = o.globals.colors[i];
    null !== s && o.config.plotOptions.bar.distributed && (u = o.globals.colors[s]);
    for (var g = 0, f = o.globals.series.length - 1; g < o.globals.series.length; g++, f--) {
      var p = this.getFormatters(i);
      if (d = this.getSeriesName({ fn: p.yLbTitleFormatter, index: i, seriesIndex: i, j: s }), n) {
        var x = o.config.tooltip.inverseOrder ? f : g;
        p = this.getFormatters(x), d = this.getSeriesName({ fn: p.yLbTitleFormatter, index: x, seriesIndex: i, j: s }), u = o.globals.colors[x], e = p.yLbFormatter(o.globals.series[x][s], { series: o.globals.series, seriesIndex: x, dataPointIndex: s, w: o }), (this.ttCtx.hasBars() && o.config.chart.stacked && 0 === o.globals.series[x][s] || void 0 === o.globals.series[x][s]) && (e = void 0);
      } else e = p.yLbFormatter(o.globals.series[i][s], { series: o.globals.series, seriesIndex: i, dataPointIndex: s, w: o });
      null === s && (e = p.yLbFormatter(o.globals.series[i], o)), this.DOMHandling({ t: g, ttItems: r, values: { val: e, xVal: l, xAxisTTVal: c, zVal: h }, seriesName: d, shared: n, pColor: u });
    }
  } }, { key: "getFormatters", value: function(t2) {
    var e, i = this.w, s = i.globals.yLabelFormatters[t2];
    return void 0 !== i.globals.ttVal ? Array.isArray(i.globals.ttVal) ? (s = i.globals.ttVal[t2] && i.globals.ttVal[t2].formatter, e = i.globals.ttVal[t2] && i.globals.ttVal[t2].title && i.globals.ttVal[t2].title.formatter) : (s = i.globals.ttVal.formatter, "function" == typeof i.globals.ttVal.title.formatter && (e = i.globals.ttVal.title.formatter)) : e = i.config.tooltip.y.title.formatter, "function" != typeof s && (s = i.globals.yLabelFormatters[0] ? i.globals.yLabelFormatters[0] : function(t3) {
      return t3;
    }), "function" != typeof e && (e = function(t3) {
      return t3;
    }), { yLbFormatter: s, yLbTitleFormatter: e };
  } }, { key: "getSeriesName", value: function(t2) {
    var e = t2.fn, i = t2.index, s = t2.seriesIndex, a = t2.j, r = this.w;
    return e(String(r.globals.seriesNames[i]), { series: r.globals.series, seriesIndex: s, dataPointIndex: a, w: r });
  } }, { key: "DOMHandling", value: function(t2) {
    var e = t2.t, i = t2.ttItems, s = t2.values, a = t2.seriesName, r = t2.shared, n = t2.pColor, o = this.w, l = this.ttCtx, h = s.val, c = s.xVal, d = s.xAxisTTVal, u = s.zVal, g = null;
    g = i[e].children, o.config.tooltip.fillSeriesColor && (i[e].style.backgroundColor = n, g[0].style.display = "none"), l.showTooltipTitle && (null === l.tooltipTitle && (l.tooltipTitle = o.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")), l.tooltipTitle.innerHTML = c), l.blxaxisTooltip && (l.xaxisTooltipText.innerHTML = "" !== d ? d : c);
    var f = i[e].querySelector(".apexcharts-tooltip-text-label");
    f && (f.innerHTML = a ? a + ": " : "");
    var p = i[e].querySelector(".apexcharts-tooltip-text-value");
    (p && (p.innerHTML = h), g[0] && g[0].classList.contains("apexcharts-tooltip-marker") && (g[0].style.backgroundColor = n), o.config.tooltip.marker.show || (g[0].style.display = "none"), null !== u) && (i[e].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = o.config.tooltip.z.title, i[e].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = u);
    r && g[0] && (null == h || o.globals.collapsedSeriesIndices.indexOf(e) > -1 ? g[0].parentNode.style.display = "none" : g[0].parentNode.style.display = o.config.tooltip.items.display);
  } }, { key: "toggleActiveInactiveSeries", value: function(t2) {
    var e = this.w;
    if (t2) this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");
    else {
      this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
      var i = e.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group");
      i && (i.classList.add("active"), i.style.display = e.config.tooltip.items.display);
    }
  } }, { key: "getValuesToPrint", value: function(t2) {
    var e = t2.i, i = t2.j, s = this.w, a = this.ctx.series.filteredSeriesX(), r = "", n = null, o = null, l = { series: s.globals.series, seriesIndex: e, dataPointIndex: i, w: s }, h = s.globals.ttZFormatter;
    null === i ? o = s.globals.series[e] : s.globals.isXNumeric ? (r = a[e][i], 0 === a[e].length && (r = a[this.tooltipUtil.getFirstActiveXArray(a)][i])) : r = void 0 !== s.globals.labels[i] ? s.globals.labels[i] : "";
    var c = r;
    s.globals.isXNumeric && "datetime" === s.config.xaxis.type ? r = new Formatters(this.ctx).xLabelFormat(s.globals.ttKeyFormatter, c, c) : s.globals.isBarHorizontal || (r = s.globals.xLabelFormatter(c, l));
    return void 0 !== s.config.tooltip.x.formatter && (r = s.globals.ttKeyFormatter(c, l)), s.globals.seriesZ.length > 0 && s.globals.seriesZ[0].length > 0 && (n = h(s.globals.seriesZ[e][i], s)), { val: o, xVal: r, xAxisTTVal: "function" == typeof s.config.xaxis.tooltip.formatter ? s.globals.xaxisTooltipFormatter(c, l) : r, zVal: n };
  } }, { key: "handleCustomTooltip", value: function(t2) {
    var e = t2.i, i = t2.j, s = this.w;
    this.ttCtx.getElTooltip().innerHTML = s.config.tooltip.custom({ ctx: this.ctx, series: s.globals.series, seriesIndex: e, dataPointIndex: i, w: s });
  } }]), t;
})();
var Position = (function() {
  function t(e) {
    _classCallCheck(this, t), this.ttCtx = e, this.ctx = e.ctx, this.w = e.w;
  }
  return _createClass(t, [{ key: "moveXCrosshairs", value: function(t2) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i = this.ttCtx, s = this.w, a = i.getElXCrosshairs(), r = t2 - i.xcrosshairsWidth / 2, n = s.globals.labels.slice().length;
    if (null !== e && (r = s.globals.gridWidth / n * e), "tickWidth" === s.config.xaxis.crosshairs.width || "barWidth" === s.config.xaxis.crosshairs.width ? r + i.xcrosshairsWidth > s.globals.gridWidth && (r = s.globals.gridWidth - i.xcrosshairsWidth) : null !== e && (r += s.globals.gridWidth / n / 2), r < 0 && (r = 0), r > s.globals.gridWidth && (r = s.globals.gridWidth), null !== a && (a.setAttribute("x", r), a.setAttribute("x1", r), a.setAttribute("x2", r), a.setAttribute("y2", s.globals.gridHeight), a.classList.add("active")), i.blxaxisTooltip) {
      var o = r;
      "tickWidth" !== s.config.xaxis.crosshairs.width && "barWidth" !== s.config.xaxis.crosshairs.width || (o = r + i.xcrosshairsWidth / 2), this.moveXAxisTooltip(o);
    }
  } }, { key: "moveYCrosshairs", value: function(t2) {
    var e = this.ttCtx;
    null !== e.ycrosshairs && (Graphics.setAttrs(e.ycrosshairs, { y1: t2, y2: t2 }), Graphics.setAttrs(e.ycrosshairsHidden, { y1: t2, y2: t2 }));
  } }, { key: "moveXAxisTooltip", value: function(t2) {
    var e = this.w, i = this.ttCtx;
    if (null !== i.xaxisTooltip) {
      i.xaxisTooltip.classList.add("active");
      var s = i.xaxisOffY + e.config.xaxis.tooltip.offsetY + e.globals.translateY + 1 + e.config.xaxis.offsetY;
      if (t2 -= i.xaxisTooltip.getBoundingClientRect().width / 2, !isNaN(t2)) {
        t2 += e.globals.translateX;
        var a;
        a = new Graphics(this.ctx).getTextRects(i.xaxisTooltipText.innerHTML), i.xaxisTooltipText.style.minWidth = a.width + "px", i.xaxisTooltip.style.left = t2 + "px", i.xaxisTooltip.style.top = s + "px";
      }
    }
  } }, { key: "moveYAxisTooltip", value: function(t2) {
    var e = this.w, i = this.ttCtx;
    null === i.yaxisTTEls && (i.yaxisTTEls = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
    var s = parseInt(i.ycrosshairsHidden.getAttribute("y1")), a = e.globals.translateY + s, r = i.yaxisTTEls[t2].getBoundingClientRect().height, n = e.globals.translateYAxisX[t2] - 2;
    e.config.yaxis[t2].opposite && (n -= 26), a -= r / 2, -1 === e.globals.ignoreYAxisIndexes.indexOf(t2) ? (i.yaxisTTEls[t2].classList.add("active"), i.yaxisTTEls[t2].style.top = a + "px", i.yaxisTTEls[t2].style.left = n + e.config.yaxis[t2].tooltip.offsetX + "px") : i.yaxisTTEls[t2].classList.remove("active");
  } }, { key: "moveTooltip", value: function(t2, e) {
    var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s = this.w, a = this.ttCtx, r = a.getElTooltip(), n = a.tooltipRect, o = null !== i ? parseInt(i) : 1, l = parseInt(t2) + o + 5, h = parseInt(e) + o / 2;
    if (l > s.globals.gridWidth / 2 && (l = l - n.ttWidth - o - 15), l > s.globals.gridWidth - n.ttWidth - 10 && (l = s.globals.gridWidth - n.ttWidth), l < -20 && (l = -20), s.config.tooltip.followCursor) {
      var c = a.getElGrid().getBoundingClientRect();
      h = a.e.clientY + s.globals.translateY - c.top - n.ttHeight / 2;
    }
    var d = this.positionChecks(n, l, h);
    l = d.x, h = d.y, isNaN(l) || (l += s.globals.translateX, r.style.left = l + "px", r.style.top = h + "px");
  } }, { key: "positionChecks", value: function(t2, e, i) {
    var s = this.w;
    return t2.ttHeight + i > s.globals.gridHeight && (i = s.globals.gridHeight - t2.ttHeight + s.globals.translateY), i < 0 && (i = 0), { x: e, y: i };
  } }, { key: "moveMarkers", value: function(t2, e) {
    var i = this.w, s = this.ttCtx;
    if (i.globals.markers.size[t2] > 0) for (var a = i.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(t2, "'] .apexcharts-marker")), r = 0; r < a.length; r++) parseInt(a[r].getAttribute("rel")) === e && (s.marker.resetPointsSize(), s.marker.enlargeCurrentPoint(e, a[r]));
    else s.marker.resetPointsSize(), this.moveDynamicPointOnHover(e, t2);
  } }, { key: "moveDynamicPointOnHover", value: function(t2, e) {
    var i, s, a = this.w, r = this.ttCtx, n = a.globals.pointsArray, o = a.config.markers.hover.size;
    if (void 0 === o && (o = a.globals.markers.size[e] + a.config.markers.hover.sizeOffset), !a.config.series[e].type || "column" !== a.config.series[e].type) {
      i = n[e][t2][0], s = n[e][t2][1] ? n[e][t2][1] : 0;
      var l = a.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e, "'] .apexcharts-series-markers circle"));
      l && (l.setAttribute("r", o), l.setAttribute("cx", i), l.setAttribute("cy", s)), this.moveXCrosshairs(i), r.fixedTooltip || this.moveTooltip(i, s, o);
    }
  } }, { key: "moveDynamicPointsOnHover", value: function(t2) {
    var e, i = this.ttCtx, s = i.w, a = 0, r = 0, n = s.globals.pointsArray;
    e = new Series(this.ctx).getActiveSeriesIndex();
    var o = s.config.markers.hover.size;
    void 0 === o && (o = s.globals.markers.size[e] + s.config.markers.hover.sizeOffset), n[e] && (a = n[e][t2][0], r = n[e][t2][1]);
    var l = null, h = i.getAllMarkers();
    if (null !== (l = null !== h ? h : s.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers circle"))) for (var c = 0; c < l.length; c++) {
      var d = n[c];
      if (d && d.length) {
        var u = n[c][t2][1];
        l[c].setAttribute("cx", a);
        var g = parseInt(l[c].parentNode.parentNode.parentNode.getAttribute("data:realIndex"));
        null !== u ? (l[g] && l[g].setAttribute("r", o), l[g] && l[g].setAttribute("cy", u)) : l[g] && l[g].setAttribute("r", 0);
      }
    }
    if (this.moveXCrosshairs(a), !i.fixedTooltip) {
      var f = r || s.globals.gridHeight;
      this.moveTooltip(a, f, o);
    }
  } }, { key: "moveStickyTooltipOverBars", value: function(t2) {
    var e, i = this.w, s = this.ttCtx, a = i.globals.maxValsInArrayIndex + 1, r = i.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(a, "'] path[j='").concat(t2, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(a, "'] path[j='").concat(t2, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(a, "'] path[j='").concat(t2, "']")), n = r ? parseFloat(r.getAttribute("cx")) : 0, o = r ? parseFloat(r.getAttribute("barWidth")) : 0;
    i.globals.isXNumeric ? n -= o / 2 : (n = s.xAxisTicksPositions[t2 - 1] + s.dataPointsDividedWidth / 2, isNaN(n) && (n = s.xAxisTicksPositions[t2] - s.dataPointsDividedWidth / 2));
    var l = s.getElGrid().getBoundingClientRect();
    if (e = s.e.clientY - l.top - s.tooltipRect.ttHeight / 2, this.moveXCrosshairs(n), !s.fixedTooltip) {
      var h = e || i.globals.gridHeight;
      this.moveTooltip(n, h);
    }
  } }]), t;
})();
var Marker = (function() {
  function t(e) {
    _classCallCheck(this, t), this.w = e.w, this.ttCtx = e, this.ctx = e.ctx, this.tooltipPosition = new Position(e);
  }
  return _createClass(t, [{ key: "drawDynamicPoints", value: function() {
    for (var t2 = this.w, e = new Graphics(this.ctx), i = new Markers(this.ctx), s = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-series"), a = 0; a < s.length; a++) {
      var r = parseInt(s[a].getAttribute("data:realIndex")), n = t2.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(r, "'] .apexcharts-series-markers-wrap"));
      if (null !== n) {
        var o = void 0, l = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
        "line" !== t2.config.chart.type && "area" !== t2.config.chart.type || t2.globals.comboCharts || t2.config.tooltip.intersect || (l += " no-pointer-events");
        var h = i.getMarkerConfig(l, r);
        (o = e.drawMarker(0, 0, h)).node.setAttribute("default-marker-size", 0);
        var c = document.createElementNS(t2.globals.SVGNS, "g");
        c.classList.add("apexcharts-series-markers"), c.appendChild(o.node), n.appendChild(c);
      }
    }
  } }, { key: "enlargeCurrentPoint", value: function(t2, e) {
    var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, a = this.w;
    "bubble" !== a.config.chart.type && this.newPointSize(t2, e);
    var r = e.getAttribute("cx"), n = e.getAttribute("cy");
    if (null !== i && null !== s && (r = i, n = s), this.tooltipPosition.moveXCrosshairs(r), !this.fixedTooltip) {
      if ("radar" === a.config.chart.type) {
        var o = this.ttCtx.getElGrid().getBoundingClientRect();
        r = this.ttCtx.e.clientX - o.left;
      }
      this.tooltipPosition.moveTooltip(r, n, a.config.markers.hover.size);
    }
  } }, { key: "enlargePoints", value: function(t2) {
    for (var e = this.w, i = this.ttCtx, s = t2, a = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), r = e.config.markers.hover.size, n = 0; n < a.length; n++) {
      var o = a[n].getAttribute("rel"), l = a[n].getAttribute("index");
      if (void 0 === r && (r = e.globals.markers.size[l] + e.config.markers.hover.sizeOffset), s === parseInt(o)) {
        this.newPointSize(s, a[n]);
        var h = a[n].getAttribute("cx"), c = a[n].getAttribute("cy");
        this.tooltipPosition.moveXCrosshairs(h), i.fixedTooltip || this.tooltipPosition.moveTooltip(h, c, r);
      } else this.oldPointSize(a[n]);
    }
  } }, { key: "newPointSize", value: function(t2, e) {
    var i = this.w, s = i.config.markers.hover.size, a = null;
    a = 0 === t2 ? e.parentNode.firstChild : e.parentNode.lastChild;
    var r = parseInt(a.getAttribute("index"));
    void 0 === s && (s = i.globals.markers.size[r] + i.config.markers.hover.sizeOffset), a.setAttribute("r", s);
  } }, { key: "oldPointSize", value: function(t2) {
    var e = parseInt(t2.getAttribute("default-marker-size"));
    t2.setAttribute("r", e);
  } }, { key: "resetPointsSize", value: function() {
    for (var t2 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), e = 0; e < t2.length; e++) {
      var i = parseInt(t2[e].getAttribute("default-marker-size"));
      Utils.isNumber(i) ? t2[e].setAttribute("r", i) : t2[e].setAttribute("r", 0);
    }
  } }]), t;
})();
var Intersect = (function() {
  function t(e) {
    _classCallCheck(this, t), this.w = e.w, this.ttCtx = e;
  }
  return _createClass(t, [{ key: "getAttr", value: function(t2, e) {
    return parseFloat(t2.target.getAttribute(e));
  } }, { key: "handleHeatTooltip", value: function(t2) {
    var e = t2.e, i = t2.opt, s = t2.x, a = t2.y, r = this.ttCtx, n = this.w;
    if (e.target.classList.contains("apexcharts-heatmap-rect")) {
      var o = this.getAttr(e, "i"), l = this.getAttr(e, "j"), h = this.getAttr(e, "cx"), c = this.getAttr(e, "cy"), d = this.getAttr(e, "width"), u = this.getAttr(e, "height");
      if (r.tooltipLabels.drawSeriesTexts({ ttItems: i.ttItems, i: o, j: l, shared: false }), n.globals.capturedSeriesIndex = o, n.globals.capturedDataPointIndex = l, s = h + r.tooltipRect.ttWidth / 2 + d, a = c + r.tooltipRect.ttHeight / 2 - u / 2, r.tooltipPosition.moveXCrosshairs(h + d / 2), s > n.globals.gridWidth / 2 && (s = h - r.tooltipRect.ttWidth / 2 + d), r.w.config.tooltip.followCursor) {
        var g = r.getElGrid().getBoundingClientRect();
        a = r.e.clientY - g.top + n.globals.translateY / 2 - 10;
      }
    }
    return { x: s, y: a };
  } }, { key: "handleMarkerTooltip", value: function(t2) {
    var e, i, s = t2.e, a = t2.opt, r = t2.x, n = t2.y, o = this.w, l = this.ttCtx;
    if (s.target.classList.contains("apexcharts-marker")) {
      var h = parseInt(a.paths.getAttribute("cx")), c = parseInt(a.paths.getAttribute("cy")), d = parseFloat(a.paths.getAttribute("val"));
      if (i = parseInt(a.paths.getAttribute("rel")), e = parseInt(a.paths.parentNode.parentNode.parentNode.getAttribute("rel")) - 1, l.intersect) {
        var u = Utils.findAncestor(a.paths, "apexcharts-series");
        u && (e = parseInt(u.getAttribute("data:realIndex")));
      }
      if (l.tooltipLabels.drawSeriesTexts({ ttItems: a.ttItems, i: e, j: i, shared: !l.showOnIntersect && o.config.tooltip.shared }), "mouseup" === s.type && l.markerClick(s, e, i), o.globals.capturedSeriesIndex = e, o.globals.capturedDataPointIndex = i, r = h, n = c + o.globals.translateY - 1.4 * l.tooltipRect.ttHeight, l.w.config.tooltip.followCursor) {
        var g = l.getElGrid().getBoundingClientRect();
        n = l.e.clientY + o.globals.translateY - g.top;
      }
      d < 0 && (n = c), l.marker.enlargeCurrentPoint(i, a.paths, r, n);
    }
    return { x: r, y: n };
  } }, { key: "handleBarTooltip", value: function(t2) {
    var e, i, s = t2.e, a = t2.opt, r = this.w, n = this.ttCtx, o = n.getElTooltip(), l = 0, h = 0, c = 0, d = this.getBarTooltipXY({ e: s, opt: a });
    e = d.i;
    var u = d.barHeight, g = d.j;
    if (r.globals.capturedSeriesIndex = e, r.globals.capturedDataPointIndex = g, r.globals.isBarHorizontal && n.hasBars() || !r.config.tooltip.shared ? (h = d.x, c = d.y, i = Array.isArray(r.config.stroke.width) ? r.config.stroke.width[e] : r.config.stroke.width, l = h) : r.globals.comboCharts || r.config.tooltip.shared || (l /= 2), isNaN(c) && (c = r.globals.svgHeight - n.tooltipRect.ttHeight), h + n.tooltipRect.ttWidth > r.globals.gridWidth ? h -= n.tooltipRect.ttWidth : h < 0 && (h += n.tooltipRect.ttWidth), n.w.config.tooltip.followCursor) {
      var f = n.getElGrid().getBoundingClientRect();
      c = n.e.clientY - f.top;
    }
    if (null === n.tooltip && (n.tooltip = r.globals.dom.baseEl.querySelector(".apexcharts-tooltip")), r.config.tooltip.shared || (r.globals.comboChartsHasBars ? n.tooltipPosition.moveXCrosshairs(l + i / 2) : n.tooltipPosition.moveXCrosshairs(l)), !n.fixedTooltip && (!r.config.tooltip.shared || r.globals.isBarHorizontal && n.hasBars())) {
      x && (h = r.globals.gridWidth - h), o.style.left = h + r.globals.translateX + "px";
      var p = parseInt(a.paths.parentNode.getAttribute("data:realIndex")), x = r.globals.isMultipleYAxis ? r.config.yaxis[p] && r.config.yaxis[p].reversed : r.config.yaxis[0].reversed;
      !x || r.globals.isBarHorizontal && n.hasBars() || (c = c + u - 2 * (r.globals.series[e][g] < 0 ? u : 0)), n.tooltipRect.ttHeight + c > r.globals.gridHeight ? (c = r.globals.gridHeight - n.tooltipRect.ttHeight + r.globals.translateY, o.style.top = c + "px") : o.style.top = c + r.globals.translateY - n.tooltipRect.ttHeight / 2 + "px";
    }
  } }, { key: "getBarTooltipXY", value: function(t2) {
    var e = t2.e, i = t2.opt, s = this.w, a = null, r = this.ttCtx, n = 0, o = 0, l = 0, h = 0, c = 0, d = e.target.classList;
    if (d.contains("apexcharts-bar-area") || d.contains("apexcharts-candlestick-area") || d.contains("apexcharts-rangebar-area")) {
      var u = e.target, g = u.getBoundingClientRect(), f = i.elGrid.getBoundingClientRect(), p = g.height;
      c = g.height;
      var x = g.width, m = parseInt(u.getAttribute("cx")), b = parseInt(u.getAttribute("cy"));
      h = parseFloat(u.getAttribute("barWidth"));
      var v = "touchmove" === e.type ? e.touches[0].clientX : e.clientX;
      a = parseInt(u.getAttribute("j")), n = parseInt(u.parentNode.getAttribute("rel")) - 1, s.globals.comboCharts && (n = parseInt(u.parentNode.getAttribute("data:realIndex"))), r.tooltipLabels.drawSeriesTexts({ ttItems: i.ttItems, i: n, j: a, shared: !r.showOnIntersect && s.config.tooltip.shared }), s.config.tooltip.followCursor ? s.globals.isBarHorizontal ? (o = v - f.left + 15, l = b - r.dataPointsDividedHeight + p / 2 - r.tooltipRect.ttHeight / 2) : (o = s.globals.isXNumeric ? m - x / 2 : m - r.dataPointsDividedWidth + x / 2, l = e.clientY - f.top - r.tooltipRect.ttHeight / 2 - 15) : s.globals.isBarHorizontal ? ((o = m) < r.xyRatios.baseLineInvertedY && (o = m - r.tooltipRect.ttWidth), l = b - r.dataPointsDividedHeight + p / 2 - r.tooltipRect.ttHeight / 2) : (o = s.globals.isXNumeric ? m - x / 2 : m - r.dataPointsDividedWidth + x / 2, l = b);
    }
    return { x: o, y: l, barHeight: c, barWidth: h, i: n, j: a };
  } }]), t;
})();
var AxesTooltip = (function() {
  function t(e) {
    _classCallCheck(this, t), this.w = e.w, this.ttCtx = e;
  }
  return _createClass(t, [{ key: "drawXaxisTooltip", value: function() {
    var t2 = this.w, e = this.ttCtx, i = "bottom" === t2.config.xaxis.position;
    e.xaxisOffY = i ? t2.globals.gridHeight + 1 : 1;
    var s = i ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top", a = t2.globals.dom.elWrap;
    e.blxaxisTooltip && (null === t2.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") && (e.xaxisTooltip = document.createElement("div"), e.xaxisTooltip.setAttribute("class", s + " " + t2.config.tooltip.theme), a.appendChild(e.xaxisTooltip), e.xaxisTooltipText = document.createElement("div"), e.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"), e.xaxisTooltipText.style.fontFamily = t2.config.xaxis.tooltip.style.fontFamily || t2.config.chart.fontFamily, e.xaxisTooltipText.style.fontSize = t2.config.xaxis.tooltip.style.fontSize, e.xaxisTooltip.appendChild(e.xaxisTooltipText)));
  } }, { key: "drawYaxisTooltip", value: function() {
    for (var t2 = this.w, e = this.ttCtx, i = function(i2) {
      var s2 = t2.config.yaxis[i2].opposite || t2.config.yaxis[i2].crosshairs.opposite;
      e.yaxisOffX = s2 ? t2.globals.gridWidth + 1 : 1;
      var a = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i2, s2 ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left");
      t2.globals.yAxisSameScaleIndices.map(function(e2, s3) {
        e2.map(function(e3, s4) {
          s4 === i2 && (a += t2.config.yaxis[s4].show ? " " : " apexcharts-yaxistooltip-hidden");
        });
      });
      var r = t2.globals.dom.elWrap;
      e.blyaxisTooltip && (null === t2.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i2)) && (e.yaxisTooltip = document.createElement("div"), e.yaxisTooltip.setAttribute("class", a + " " + t2.config.tooltip.theme), r.appendChild(e.yaxisTooltip), 0 === i2 && (e.yaxisTooltipText = []), e.yaxisTooltipText.push(document.createElement("div")), e.yaxisTooltipText[i2].classList.add("apexcharts-yaxistooltip-text"), e.yaxisTooltip.appendChild(e.yaxisTooltipText[i2])));
    }, s = 0; s < t2.config.yaxis.length; s++) i(s);
  } }, { key: "setXCrosshairWidth", value: function() {
    var t2 = this.w, e = this.ttCtx, i = e.getElXCrosshairs();
    if (e.xcrosshairsWidth = parseInt(t2.config.xaxis.crosshairs.width), t2.globals.comboCharts) {
      var s = t2.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
      if (null !== s && "barWidth" === t2.config.xaxis.crosshairs.width) {
        var a = parseFloat(s.getAttribute("barWidth"));
        e.xcrosshairsWidth = a;
      } else if ("tickWidth" === t2.config.xaxis.crosshairs.width) {
        var r = t2.globals.labels.length;
        e.xcrosshairsWidth = t2.globals.gridWidth / r;
      }
    } else if ("tickWidth" === t2.config.xaxis.crosshairs.width) {
      var n = t2.globals.labels.length;
      e.xcrosshairsWidth = t2.globals.gridWidth / n;
    } else if ("barWidth" === t2.config.xaxis.crosshairs.width) {
      var o = t2.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
      if (null !== o) {
        var l = parseFloat(o.getAttribute("barWidth"));
        e.xcrosshairsWidth = l;
      } else e.xcrosshairsWidth = 1;
    }
    t2.globals.isBarHorizontal && (e.xcrosshairsWidth = 0), null !== i && e.xcrosshairsWidth > 0 && i.setAttribute("width", e.xcrosshairsWidth);
  } }, { key: "handleYCrosshair", value: function() {
    var t2 = this.w, e = this.ttCtx;
    e.ycrosshairs = t2.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"), e.ycrosshairsHidden = t2.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden");
  } }, { key: "drawYaxisTooltipText", value: function(t2, e, i) {
    var s = this.ttCtx, a = this.w, r = a.globals.yLabelFormatters[t2];
    if (s.blyaxisTooltip) {
      var n = s.getElGrid().getBoundingClientRect(), o = (e - n.top) * i.yRatio[t2], l = a.globals.maxYArr[t2] - a.globals.minYArr[t2], h = a.globals.minYArr[t2] + (l - o);
      s.tooltipPosition.moveYCrosshairs(e - n.top), s.yaxisTooltipText[t2].innerHTML = r(h), s.tooltipPosition.moveYAxisTooltip(t2);
    }
  } }]), t;
})();
var Tooltip = (function() {
  function t(e) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w;
    var i = this.w;
    this.tConfig = i.config.tooltip, this.tooltipUtil = new Utils$1(this), this.tooltipLabels = new Labels(this), this.tooltipPosition = new Position(this), this.marker = new Marker(this), this.intersect = new Intersect(this), this.axesTooltip = new AxesTooltip(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !i.globals.isBarHorizontal && this.tConfig.shared;
  }
  return _createClass(t, [{ key: "getElTooltip", value: function(t2) {
    return t2 || (t2 = this), t2.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip");
  } }, { key: "getElXCrosshairs", value: function() {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs");
  } }, { key: "getElGrid", value: function() {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid");
  } }, { key: "drawTooltip", value: function(t2) {
    var e = this.w;
    this.xyRatios = t2, this.blxaxisTooltip = e.config.xaxis.tooltip.enabled && e.globals.axisCharts, this.blyaxisTooltip = e.config.yaxis[0].tooltip.enabled && e.globals.axisCharts, this.allTooltipSeriesGroups = [], e.globals.axisCharts || (this.showTooltipTitle = false);
    var i = document.createElement("div");
    if (i.classList.add("apexcharts-tooltip"), i.classList.add(this.tConfig.theme), e.globals.dom.elWrap.appendChild(i), e.globals.axisCharts) {
      this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair();
      var s = new XAxis(this.ctx);
      this.xAxisTicksPositions = s.getXAxisTicksPositions();
    }
    if ((e.globals.comboCharts && !this.tConfig.shared || this.tConfig.intersect && !this.tConfig.shared || ("bar" === e.config.chart.type || "rangeBar" === e.config.chart.type) && !this.tConfig.shared) && (this.showOnIntersect = true), 0 !== e.config.markers.size && 0 !== e.globals.markers.largestSize || this.marker.drawDynamicPoints(this), e.globals.collapsedSeries.length !== e.globals.series.length) {
      this.dataPointsDividedHeight = e.globals.gridHeight / e.globals.dataPoints, this.dataPointsDividedWidth = e.globals.gridWidth / e.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"), this.tooltipTitle.classList.add("apexcharts-tooltip-title"), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || e.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, i.appendChild(this.tooltipTitle));
      var a = e.globals.series.length;
      (e.globals.xyCharts || e.globals.comboCharts) && this.tConfig.shared && (a = this.showOnIntersect ? 1 : e.globals.series.length), this.legendLabels = e.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"), this.ttItems = this.createTTElements(a), this.addSVGEvents();
    }
  } }, { key: "createTTElements", value: function(t2) {
    for (var e = this.w, i = [], s = this.getElTooltip(), a = 0; a < t2; a++) {
      var r = document.createElement("div");
      r.classList.add("apexcharts-tooltip-series-group"), this.tConfig.shared && this.tConfig.enabledOnSeries && Array.isArray(this.tConfig.enabledOnSeries) && this.tConfig.enabledOnSeries.indexOf(a) < 0 && r.classList.add("apexcharts-tooltip-series-group-hidden");
      var n = document.createElement("span");
      n.classList.add("apexcharts-tooltip-marker"), n.style.backgroundColor = e.globals.colors[a], r.appendChild(n);
      var o = document.createElement("div");
      o.classList.add("apexcharts-tooltip-text"), o.style.fontFamily = this.tConfig.style.fontFamily || e.config.chart.fontFamily, o.style.fontSize = this.tConfig.style.fontSize;
      var l = document.createElement("div");
      l.classList.add("apexcharts-tooltip-y-group");
      var h = document.createElement("span");
      h.classList.add("apexcharts-tooltip-text-label"), l.appendChild(h);
      var c = document.createElement("span");
      c.classList.add("apexcharts-tooltip-text-value"), l.appendChild(c);
      var d = document.createElement("div");
      d.classList.add("apexcharts-tooltip-z-group");
      var u = document.createElement("span");
      u.classList.add("apexcharts-tooltip-text-z-label"), d.appendChild(u);
      var g = document.createElement("span");
      g.classList.add("apexcharts-tooltip-text-z-value"), d.appendChild(g), o.appendChild(l), o.appendChild(d), r.appendChild(o), s.appendChild(r), i.push(r);
    }
    return i;
  } }, { key: "addSVGEvents", value: function() {
    var t2 = this.w, e = t2.config.chart.type, i = this.getElTooltip(), s = !("bar" !== e && "candlestick" !== e && "rangeBar" !== e), a = t2.globals.dom.Paper.node, r = this.getElGrid();
    r && (this.seriesBound = r.getBoundingClientRect());
    var n, o = [], l = [], h = { hoverArea: a, elGrid: r, tooltipEl: i, tooltipY: o, tooltipX: l, ttItems: this.ttItems };
    if (t2.globals.axisCharts && ("area" === e || "line" === e || "scatter" === e || "bubble" === e ? n = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : s ? n = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-rangebar-area") : "heatmap" === e ? n = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap") : "radar" === e && (n = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-marker")), n && n.length)) for (var c = 0; c < n.length; c++) o.push(n[c].getAttribute("cy")), l.push(n[c].getAttribute("cx"));
    if (t2.globals.xyCharts && !this.showOnIntersect || t2.globals.comboCharts && !this.showOnIntersect || s && this.hasBars() && this.tConfig.shared) this.addPathsEventListeners([a], h);
    else if (s && !t2.globals.comboCharts) this.addBarsEventListeners(h);
    else if ("bubble" === e || "scatter" === e || "radar" === e || this.showOnIntersect && ("area" === e || "line" === e)) this.addPointsEventsListeners(h);
    else if (!t2.globals.axisCharts || "heatmap" === e) {
      var d = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
      this.addPathsEventListeners(d, h);
    }
    if (this.showOnIntersect) {
      var u = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker");
      u.length > 0 && this.addPathsEventListeners(u, h);
      var g = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-area-series .apexcharts-marker");
      g.length > 0 && this.addPathsEventListeners(g, h), this.hasBars() && !this.tConfig.shared && this.addBarsEventListeners(h);
    }
  } }, { key: "drawFixedTooltipRect", value: function() {
    var t2 = this.w, e = this.getElTooltip(), i = e.getBoundingClientRect(), s = i.width + 10, a = i.height + 10, r = this.tConfig.fixed.offsetX, n = this.tConfig.fixed.offsetY;
    return this.tConfig.fixed.position.toLowerCase().indexOf("right") > -1 && (r = r + t2.globals.svgWidth - s + 10), this.tConfig.fixed.position.toLowerCase().indexOf("bottom") > -1 && (n = n + t2.globals.svgHeight - a - 10), e.style.left = r + "px", e.style.top = n + "px", { x: r, y: n, ttWidth: s, ttHeight: a };
  } }, { key: "addPointsEventsListeners", value: function(t2) {
    var e = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker");
    this.addPathsEventListeners(e, t2);
  } }, { key: "addBarsEventListeners", value: function(t2) {
    var e = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-rangebar-area");
    this.addPathsEventListeners(e, t2);
  } }, { key: "addPathsEventListeners", value: function(t2, e) {
    for (var i = this, s = this, a = function(a2) {
      var r2 = { paths: t2[a2], tooltipEl: e.tooltipEl, tooltipY: e.tooltipY, tooltipX: e.tooltipX, elGrid: e.elGrid, hoverArea: e.hoverArea, ttItems: e.ttItems };
      i.w.globals.tooltipOpts = r2;
      ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map(function(e2) {
        return t2[a2].addEventListener(e2, s.seriesHover.bind(s, r2), { capture: false, passive: true });
      });
    }, r = 0; r < t2.length; r++) a(r);
  } }, { key: "seriesHover", value: function(t2, e) {
    var i = this, s = [], a = this.w;
    a.config.chart.group && (s = this.ctx.getGroupedCharts()), a.globals.axisCharts && (a.globals.minX === -1 / 0 && a.globals.maxX === 1 / 0 || 0 === a.globals.dataPoints) || (s.length ? s.forEach(function(s2) {
      var a2 = i.getElTooltip(s2), r = { paths: t2.paths, tooltipEl: a2, tooltipY: t2.tooltipY, tooltipX: t2.tooltipX, elGrid: t2.elGrid, hoverArea: t2.hoverArea, ttItems: s2.w.globals.tooltip.ttItems };
      s2.w.globals.minX === i.w.globals.minX && s2.w.globals.maxX === i.w.globals.maxX && s2.w.globals.tooltip.seriesHoverByContext({ chartCtx: s2, ttCtx: s2.w.globals.tooltip, opt: r, e });
    }) : this.seriesHoverByContext({ chartCtx: this.ctx, ttCtx: this.w.globals.tooltip, opt: t2, e }));
  } }, { key: "seriesHoverByContext", value: function(t2) {
    var e = t2.chartCtx, i = t2.ttCtx, s = t2.opt, a = t2.e, r = e.w, n = this.getElTooltip();
    (i.tooltipRect = { x: 0, y: 0, ttWidth: n.getBoundingClientRect().width, ttHeight: n.getBoundingClientRect().height }, i.e = a, !i.hasBars() || r.globals.comboCharts || i.isBarShared) || this.tConfig.onDatasetHover.highlightDataSeries && new Series(e).toggleSeriesOnHover(a, a.target.parentNode);
    i.fixedTooltip && i.drawFixedTooltipRect(), r.globals.axisCharts ? i.axisChartsTooltips({ e: a, opt: s, tooltipRect: i.tooltipRect }) : i.nonAxisChartsTooltips({ e: a, opt: s, tooltipRect: i.tooltipRect });
  } }, { key: "axisChartsTooltips", value: function(t2) {
    var e, i, s, a = t2.e, r = t2.opt, n = this.w, o = null, l = r.elGrid.getBoundingClientRect(), h = "touchmove" === a.type ? a.touches[0].clientX : a.clientX, c = "touchmove" === a.type ? a.touches[0].clientY : a.clientY;
    if (this.clientY = c, this.clientX = h, n.globals.capturedSeriesIndex = -1, n.globals.capturedDataPointIndex = -1, c < l.top || c > l.top + l.height) this.handleMouseOut(r);
    else {
      if (Array.isArray(this.tConfig.enabledOnSeries) && !n.config.tooltip.shared) {
        var d = parseInt(r.paths.getAttribute("index"));
        if (this.tConfig.enabledOnSeries.indexOf(d) < 0) return void this.handleMouseOut(r);
      }
      var u = this.getElTooltip(), g = this.getElXCrosshairs(), f = n.globals.xyCharts || "bar" === n.config.chart.type && !n.globals.isBarHorizontal && this.hasBars() && this.tConfig.shared || n.globals.comboCharts && this.hasBars;
      if (n.globals.isBarHorizontal && this.hasBars() && (f = false), "mousemove" === a.type || "touchmove" === a.type || "mouseup" === a.type) {
        if (null !== g && g.classList.add("active"), null !== this.ycrosshairs && this.blyaxisTooltip && this.ycrosshairs.classList.add("active"), f && !this.showOnIntersect) {
          e = (o = this.tooltipUtil.getNearestValues({ context: this, hoverArea: r.hoverArea, elGrid: r.elGrid, clientX: h, clientY: c, hasBars: this.hasBars })).j;
          var p = o.capturedSeries;
          if (o.hoverX < 0 || o.hoverX > n.globals.gridWidth) return void this.handleMouseOut(r);
          if (null !== p) {
            if (null === n.globals.series[p][e]) return void this.handleMouseOut(r);
            void 0 !== n.globals.series[p][e] ? this.tConfig.shared && this.tooltipUtil.isXoverlap(e) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(a, this, p, e, r.ttItems) : this.create(a, this, p, e, r.ttItems, false) : this.tooltipUtil.isXoverlap(e) && this.create(a, this, 0, e, r.ttItems);
          } else this.tooltipUtil.isXoverlap(e) && this.create(a, this, 0, e, r.ttItems);
        } else if ("heatmap" === n.config.chart.type) {
          var x = this.intersect.handleHeatTooltip({ e: a, opt: r, x: i, y: s });
          i = x.x, s = x.y, u.style.left = i + "px", u.style.top = s + "px";
        } else this.hasBars && this.intersect.handleBarTooltip({ e: a, opt: r }), this.hasMarkers && this.intersect.handleMarkerTooltip({ e: a, opt: r, x: i, y: s });
        if (this.blyaxisTooltip) for (var m = 0; m < n.config.yaxis.length; m++) this.axesTooltip.drawYaxisTooltipText(m, c, this.xyRatios);
        r.tooltipEl.classList.add("active");
      } else "mouseout" !== a.type && "touchend" !== a.type || this.handleMouseOut(r);
    }
  } }, { key: "nonAxisChartsTooltips", value: function(t2) {
    var e = t2.e, i = t2.opt, s = t2.tooltipRect, a = this.w, r = i.paths.getAttribute("rel"), n = this.getElTooltip(), o = a.globals.dom.elWrap.getBoundingClientRect();
    if ("mousemove" === e.type || "touchmove" === e.type) {
      n.classList.add("active"), this.tooltipLabels.drawSeriesTexts({ ttItems: i.ttItems, i: parseInt(r) - 1, shared: false });
      var l = a.globals.clientX - o.left - s.ttWidth / 2, h = a.globals.clientY - o.top - s.ttHeight - 10;
      n.style.left = l + "px", n.style.top = h + "px";
    } else "mouseout" !== e.type && "touchend" !== e.type || n.classList.remove("active");
  } }, { key: "deactivateHoverFilter", value: function() {
    for (var t2 = this.w, e = new Graphics(this.ctx), i = t2.globals.dom.Paper.select(".apexcharts-bar-area"), s = 0; s < i.length; s++) e.pathMouseLeave(i[s]);
  } }, { key: "handleMouseOut", value: function(t2) {
    var e = this.w, i = this.getElXCrosshairs();
    if (t2.tooltipEl.classList.remove("active"), this.deactivateHoverFilter(), "bubble" !== e.config.chart.type && this.marker.resetPointsSize(), null !== i && i.classList.remove("active"), null !== this.ycrosshairs && this.ycrosshairs.classList.remove("active"), this.blxaxisTooltip && this.xaxisTooltip.classList.remove("active"), this.blyaxisTooltip) {
      null === this.yaxisTTEls && (this.yaxisTTEls = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
      for (var s = 0; s < this.yaxisTTEls.length; s++) this.yaxisTTEls[s].classList.remove("active");
    }
    e.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(t3) {
      var e2 = t3.getAttribute("data:default-text");
      t3.innerHTML = e2;
    });
  } }, { key: "getElMarkers", value: function() {
    return this.w.globals.dom.baseEl.querySelectorAll(" .apexcharts-series-markers");
  } }, { key: "getAllMarkers", value: function() {
    return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker");
  } }, { key: "hasMarkers", value: function() {
    return this.getElMarkers().length > 0;
  } }, { key: "getElBars", value: function() {
    return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-rangebar-series");
  } }, { key: "hasBars", value: function() {
    return this.getElBars().length > 0;
  } }, { key: "markerClick", value: function(t2, e, i) {
    var s = this.w;
    "function" == typeof s.config.chart.events.markerClick && s.config.chart.events.markerClick(t2, this.ctx, { seriesIndex: e, dataPointIndex: i, w: s }), this.ctx.fireEvent("markerClick", [t2, this.ctx, { seriesIndex: e, dataPointIndex: i, w: s }]);
  } }, { key: "create", value: function(t2, e, i, s, a) {
    var r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, n = this.w, o = e;
    "mouseup" === t2.type && this.markerClick(t2, i, s), null === r && (r = this.tConfig.shared);
    var l = this.hasMarkers(), h = this.getElBars();
    if (n.config.legend.tooltipHoverFormatter) {
      var c = n.config.legend.tooltipHoverFormatter, d = Array.from(this.legendLabels);
      d.forEach(function(t3) {
        var e2 = t3.getAttribute("data:default-text");
        t3.innerHTML = e2;
      });
      for (var u = 0; u < d.length; u++) {
        var g = d[u], f = parseInt(g.getAttribute("i")), p = g.getAttribute("data:default-text"), x = c(p, { seriesIndex: r ? f : i, dataPointIndex: s, w: n });
        if (r) g.innerHTML = n.globals.collapsedSeriesIndices.indexOf(f) < 0 ? x : p;
        else if (g.innerHTML = f === i ? x : p, i === f) break;
      }
    }
    if (r) {
      if (o.tooltipLabels.drawSeriesTexts({ ttItems: a, i, j: s, shared: !this.showOnIntersect && this.tConfig.shared }), l && (n.globals.markers.largestSize > 0 ? o.marker.enlargePoints(s) : o.tooltipPosition.moveDynamicPointsOnHover(s)), this.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(h), this.barSeriesHeight > 0)) {
        var m = new Graphics(this.ctx), b = n.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(s, "']"));
        this.deactivateHoverFilter(), this.tooltipPosition.moveStickyTooltipOverBars(s);
        for (var v = 0; v < b.length; v++) m.pathMouseEnter(b[v]);
      }
    } else o.tooltipLabels.drawSeriesTexts({ shared: false, ttItems: a, i, j: s }), this.hasBars() && o.tooltipPosition.moveStickyTooltipOverBars(s), l && o.tooltipPosition.moveMarkers(i, s);
  } }]), t;
})();
var icoPan = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <defs>\n        <path d="M0 0h24v24H0z" id="a"/>\n    </defs>\n    <clipPath id="b">\n        <use overflow="visible" xlink:href="#a"/>\n    </clipPath>\n    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>\n</svg>';
var icoZoom = '<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n    <path d="M0 0h24v24H0V0z" fill="none"/>\n    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>\n</svg>';
var icoReset = '<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>';
var icoZoomIn = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n';
var icoZoomOut = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n';
var icoSelect = '<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>\n</svg>';
var icoMenu = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>';
var Toolbar = (function() {
  function t(e) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.ev = this.w.config.chart.events, this.localeValues = this.w.globals.locale.toolbar;
  }
  return _createClass(t, [{ key: "createToolbar", value: function() {
    var t2 = this.w, e = document.createElement("div");
    if (e.setAttribute("class", "apexcharts-toolbar"), t2.globals.dom.elWrap.appendChild(e), this.elZoom = document.createElement("div"), this.elZoomIn = document.createElement("div"), this.elZoomOut = document.createElement("div"), this.elPan = document.createElement("div"), this.elSelection = document.createElement("div"), this.elZoomReset = document.createElement("div"), this.elMenuIcon = document.createElement("div"), this.elMenu = document.createElement("div"), this.elCustomIcons = [], this.t = t2.config.chart.toolbar.tools, Array.isArray(this.t.customIcons)) for (var i = 0; i < this.t.customIcons.length; i++) this.elCustomIcons.push(document.createElement("div"));
    this.elMenuItems = [];
    var s = [];
    this.t.zoomin && t2.config.chart.zoom.enabled && s.push({ el: this.elZoomIn, icon: "string" == typeof this.t.zoomin ? this.t.zoomin : icoZoomIn, title: this.localeValues.zoomIn, class: "apexcharts-zoom-in-icon" }), this.t.zoomout && t2.config.chart.zoom.enabled && s.push({ el: this.elZoomOut, icon: "string" == typeof this.t.zoomout ? this.t.zoomout : icoZoomOut, title: this.localeValues.zoomOut, class: "apexcharts-zoom-out-icon" }), this.t.zoom && t2.config.chart.zoom.enabled && s.push({ el: this.elZoom, icon: "string" == typeof this.t.zoom ? this.t.zoom : icoZoom, title: this.localeValues.selectionZoom, class: t2.globals.isTouchDevice ? "hidden" : "apexcharts-zoom-icon" }), this.t.selection && t2.config.chart.selection.enabled && s.push({ el: this.elSelection, icon: "string" == typeof this.t.selection ? this.t.selection : icoSelect, title: this.localeValues.selection, class: t2.globals.isTouchDevice ? "hidden" : "apexcharts-selection-icon" }), this.t.pan && t2.config.chart.zoom.enabled && s.push({ el: this.elPan, icon: "string" == typeof this.t.pan ? this.t.pan : icoPan, title: this.localeValues.pan, class: t2.globals.isTouchDevice ? "hidden" : "apexcharts-pan-icon" }), this.t.reset && t2.config.chart.zoom.enabled && s.push({ el: this.elZoomReset, icon: "string" == typeof this.t.reset ? this.t.reset : icoReset, title: this.localeValues.reset, class: "apexcharts-reset-zoom-icon" }), this.t.download && s.push({ el: this.elMenuIcon, icon: "string" == typeof this.t.download ? this.t.download : icoMenu, title: this.localeValues.menu, class: "apexcharts-menu-icon" });
    for (var a = 0; a < this.elCustomIcons.length; a++) s.push({ el: this.elCustomIcons[a], icon: this.t.customIcons[a].icon, title: this.t.customIcons[a].title, index: this.t.customIcons[a].index, class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[a].class });
    s.forEach(function(t3, e2) {
      t3.index && Utils.moveIndexInArray(s, e2, t3.index);
    });
    for (var r = 0; r < s.length; r++) Graphics.setAttrs(s[r].el, { class: s[r].class, title: s[r].title }), s[r].el.innerHTML = s[r].icon, e.appendChild(s[r].el);
    e.appendChild(this.elMenu), Graphics.setAttrs(this.elMenu, { class: "apexcharts-menu" });
    for (var n = [{ name: "exportSVG", title: this.localeValues.exportToSVG }, { name: "exportPNG", title: this.localeValues.exportToPNG }], o = 0; o < n.length; o++) this.elMenuItems.push(document.createElement("div")), this.elMenuItems[o].innerHTML = n[o].title, Graphics.setAttrs(this.elMenuItems[o], { class: "apexcharts-menu-item ".concat(n[o].name), title: n[o].title }), this.elMenu.appendChild(this.elMenuItems[o]);
    t2.globals.zoomEnabled ? this.elZoom.classList.add("selected") : t2.globals.panEnabled ? this.elPan.classList.add("selected") : t2.globals.selectionEnabled && this.elSelection.classList.add("selected"), this.addToolbarEventListeners();
  } }, { key: "addToolbarEventListeners", value: function() {
    var t2 = this;
    this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)), this.elSelection.addEventListener("click", this.toggleSelection.bind(this)), this.elZoom.addEventListener("click", this.toggleZooming.bind(this)), this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)), this.elPan.addEventListener("click", this.togglePanning.bind(this)), this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)), this.elMenuItems.forEach(function(e2) {
      e2.classList.contains("exportSVG") ? e2.addEventListener("click", t2.downloadSVG.bind(t2)) : e2.classList.contains("exportPNG") && e2.addEventListener("click", t2.downloadPNG.bind(t2));
    });
    for (var e = 0; e < this.t.customIcons.length; e++) this.elCustomIcons[e].addEventListener("click", this.t.customIcons[e].click.bind(this, this.ctx, this.ctx.w));
  } }, { key: "toggleSelection", value: function() {
    this.toggleOtherControls(), this.w.globals.selectionEnabled = !this.w.globals.selectionEnabled, this.elSelection.classList.contains("selected") ? this.elSelection.classList.remove("selected") : this.elSelection.classList.add("selected");
  } }, { key: "toggleZooming", value: function() {
    this.toggleOtherControls(), this.w.globals.zoomEnabled = !this.w.globals.zoomEnabled, this.elZoom.classList.contains("selected") ? this.elZoom.classList.remove("selected") : this.elZoom.classList.add("selected");
  } }, { key: "getToolbarIconsReference", value: function() {
    var t2 = this.w;
    this.elZoom || (this.elZoom = t2.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")), this.elPan || (this.elPan = t2.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")), this.elSelection || (this.elSelection = t2.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"));
  } }, { key: "enableZooming", value: function() {
    this.toggleOtherControls(), this.w.globals.zoomEnabled = true, this.elZoom && this.elZoom.classList.add("selected"), this.elPan && this.elPan.classList.remove("selected");
  } }, { key: "enablePanning", value: function() {
    this.toggleOtherControls(), this.w.globals.panEnabled = true, this.elPan && this.elPan.classList.add("selected"), this.elZoom && this.elZoom.classList.remove("selected");
  } }, { key: "togglePanning", value: function() {
    this.toggleOtherControls(), this.w.globals.panEnabled = !this.w.globals.panEnabled, this.elPan.classList.contains("selected") ? this.elPan.classList.remove("selected") : this.elPan.classList.add("selected");
  } }, { key: "toggleOtherControls", value: function() {
    var t2 = this.w;
    t2.globals.panEnabled = false, t2.globals.zoomEnabled = false, t2.globals.selectionEnabled = false, this.getToolbarIconsReference(), this.elPan && this.elPan.classList.remove("selected"), this.elSelection && this.elSelection.classList.remove("selected"), this.elZoom && this.elZoom.classList.remove("selected");
  } }, { key: "handleZoomIn", value: function() {
    var t2 = this.w, e = (t2.globals.minX + t2.globals.maxX) / 2, i = (t2.globals.minX + e) / 2, s = (t2.globals.maxX + e) / 2;
    t2.globals.disableZoomIn || this.zoomUpdateOptions(i, s);
  } }, { key: "handleZoomOut", value: function() {
    var t2 = this.w;
    if (!("datetime" === t2.config.xaxis.type && new Date(t2.globals.minX).getUTCFullYear() < 1e3)) {
      var e = (t2.globals.minX + t2.globals.maxX) / 2, i = t2.globals.minX - (e - t2.globals.minX), s = t2.globals.maxX - (e - t2.globals.maxX);
      t2.globals.disableZoomOut || this.zoomUpdateOptions(i, s);
    }
  } }, { key: "zoomUpdateOptions", value: function(t2, e) {
    var i = { min: t2, max: e }, s = this.getBeforeZoomRange(i);
    s && (i = s.xaxis), this.w.globals.zoomed = true, this.ctx._updateOptions({ xaxis: i }, false, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(i);
  } }, { key: "zoomCallback", value: function(t2, e) {
    "function" == typeof this.ev.zoomed && this.ev.zoomed(this.ctx, { xaxis: t2, yaxis: e });
  } }, { key: "getBeforeZoomRange", value: function(t2, e) {
    var i = null;
    return "function" == typeof this.ev.beforeZoom && (i = this.ev.beforeZoom(this, { xaxis: t2, yaxis: e })), i;
  } }, { key: "toggleMenu", value: function() {
    this.elMenu.classList.contains("open") ? this.elMenu.classList.remove("open") : this.elMenu.classList.add("open");
  } }, { key: "downloadPNG", value: function() {
    var t2 = new Exports(this.ctx);
    t2.exportToPng(this.ctx), this.toggleMenu();
  } }, { key: "downloadSVG", value: function() {
    var t2 = new Exports(this.ctx);
    t2.exportToSVG(), this.toggleMenu();
  } }, { key: "handleZoomReset", value: function(t2) {
    var e = this;
    this.ctx.getSyncedCharts().forEach(function(t3) {
      var i = t3.w;
      i.globals.minX !== i.globals.initialminX && i.globals.maxX !== i.globals.initialmaxX && (t3.revertDefaultAxisMinMax(), "function" == typeof i.config.chart.events.zoomed && e.zoomCallback({ min: i.config.xaxis.min, max: i.config.xaxis.max }), i.globals.zoomed = false, t3._updateSeries(i.globals.initialSeries, i.config.chart.animations.dynamicAnimation.enabled));
    });
  } }, { key: "destroy", value: function() {
    this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null;
  } }]), t;
})();
var ZoomPanSelection = (function(t) {
  function e(t2) {
    var i;
    return _classCallCheck(this, e), (i = _possibleConstructorReturn(this, _getPrototypeOf(e).call(this, t2))).ctx = t2, i.w = t2.w, i.dragged = false, i.graphics = new Graphics(i.ctx), i.eventList = ["mousedown", "mouseleave", "mousemove", "touchstart", "touchmove", "mouseup", "touchend"], i.clientX = 0, i.clientY = 0, i.startX = 0, i.endX = 0, i.dragX = 0, i.startY = 0, i.endY = 0, i.dragY = 0, i;
  }
  return _inherits(e, Toolbar), _createClass(e, [{ key: "init", value: function(t2) {
    var e2 = this, i = t2.xyRatios, s = this.w, a = this;
    this.xyRatios = i, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = s.globals.dom.baseEl.querySelector(".apexcharts-grid"), this.zoomRect.node.classList.add("apexcharts-zoom-rect"), this.selectionRect.node.classList.add("apexcharts-selection-rect"), s.globals.dom.elGraphical.add(this.zoomRect), s.globals.dom.elGraphical.add(this.selectionRect), "x" === s.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, minY: 0, maxX: s.globals.gridWidth, maxY: s.globals.gridHeight }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : "y" === s.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, maxX: s.globals.gridWidth }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : this.slDraggableRect = this.selectionRect.draggable().on("dragmove", this.selectionDragging.bind(this, "dragging")), this.preselectedSelection(), this.hoverArea = s.globals.dom.baseEl.querySelector(s.globals.chartClass), this.hoverArea.classList.add("zoomable"), this.eventList.forEach(function(t3) {
      e2.hoverArea.addEventListener(t3, a.svgMouseEvents.bind(a, i), { capture: false, passive: true });
    });
  } }, { key: "destroy", value: function() {
    this.slDraggableRect && (this.slDraggableRect.draggable(false), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null;
  } }, { key: "svgMouseEvents", value: function(t2, e2) {
    var i = this.w, s = this, a = this.ctx.toolbar, r = i.globals.zoomEnabled ? i.config.chart.zoom.type : i.config.chart.selection.type;
    if (e2.shiftKey ? (this.shiftWasPressed = true, a.enablePanning()) : this.shiftWasPressed && (a.enableZooming(), this.shiftWasPressed = false), !(e2.target.classList.contains("apexcharts-selection-rect") || e2.target.parentNode.classList.contains("apexcharts-toolbar"))) {
      if (s.clientX = "touchmove" === e2.type || "touchstart" === e2.type ? e2.touches[0].clientX : "touchend" === e2.type ? e2.changedTouches[0].clientX : e2.clientX, s.clientY = "touchmove" === e2.type || "touchstart" === e2.type ? e2.touches[0].clientY : "touchend" === e2.type ? e2.changedTouches[0].clientY : e2.clientY, "mousedown" === e2.type && 1 === e2.which) {
        var n = s.gridRect.getBoundingClientRect();
        s.startX = s.clientX - n.left, s.startY = s.clientY - n.top, s.dragged = false, s.w.globals.mousedown = true;
      }
      if (("mousemove" === e2.type && 1 === e2.which || "touchmove" === e2.type) && (s.dragged = true, i.globals.panEnabled ? (i.globals.selection = null, s.w.globals.mousedown && s.panDragging({ context: s, zoomtype: r, xyRatios: t2 })) : (s.w.globals.mousedown && i.globals.zoomEnabled || s.w.globals.mousedown && i.globals.selectionEnabled) && (s.selection = s.selectionDrawing({ context: s, zoomtype: r }))), "mouseup" === e2.type || "touchend" === e2.type || "mouseleave" === e2.type) {
        var o = s.gridRect.getBoundingClientRect();
        s.w.globals.mousedown && (s.endX = s.clientX - o.left, s.endY = s.clientY - o.top, s.dragX = Math.abs(s.endX - s.startX), s.dragY = Math.abs(s.endY - s.startY), (i.globals.zoomEnabled || i.globals.selectionEnabled) && s.selectionDrawn({ context: s, zoomtype: r })), i.globals.zoomEnabled && s.hideSelectionRect(this.selectionRect), s.dragged = false, s.w.globals.mousedown = false;
      }
      this.makeSelectionRectDraggable();
    }
  } }, { key: "makeSelectionRectDraggable", value: function() {
    var t2 = this.w;
    if (this.selectionRect) {
      var e2 = this.selectionRect.node.getBoundingClientRect();
      e2.width > 0 && e2.height > 0 && this.slDraggableRect.selectize().resize({ constraint: { minX: 0, minY: 0, maxX: t2.globals.gridWidth, maxY: t2.globals.gridHeight } }).on("resizing", this.selectionDragging.bind(this, "resizing"));
    }
  } }, { key: "preselectedSelection", value: function() {
    var t2 = this.w, e2 = this.xyRatios;
    if (!t2.globals.zoomEnabled) {
      if (void 0 !== t2.globals.selection && null !== t2.globals.selection) this.drawSelectionRect(t2.globals.selection);
      else if (void 0 !== t2.config.chart.selection.xaxis.min && void 0 !== t2.config.chart.selection.xaxis.max) {
        var i = (t2.config.chart.selection.xaxis.min - t2.globals.minX) / e2.xRatio, s = { x: i, y: 0, width: t2.globals.gridWidth - (t2.globals.maxX - t2.config.chart.selection.xaxis.max) / e2.xRatio - i, height: t2.globals.gridHeight, translateX: 0, translateY: 0, selectionEnabled: true };
        this.drawSelectionRect(s), this.makeSelectionRectDraggable(), "function" == typeof t2.config.chart.events.selection && t2.config.chart.events.selection(this.ctx, { xaxis: { min: t2.config.chart.selection.xaxis.min, max: t2.config.chart.selection.xaxis.max }, yaxis: {} });
      }
    }
  } }, { key: "drawSelectionRect", value: function(t2) {
    var e2 = t2.x, i = t2.y, s = t2.width, a = t2.height, r = t2.translateX, n = t2.translateY, o = this.w, l = this.zoomRect, h = this.selectionRect;
    if (this.dragged || null !== o.globals.selection) {
      var c = { transform: "translate(" + r + ", " + n + ")" };
      o.globals.zoomEnabled && this.dragged && (l.attr({ x: e2, y: i, width: s, height: a, fill: o.config.chart.zoom.zoomedArea.fill.color, "fill-opacity": o.config.chart.zoom.zoomedArea.fill.opacity, stroke: o.config.chart.zoom.zoomedArea.stroke.color, "stroke-width": o.config.chart.zoom.zoomedArea.stroke.width, "stroke-opacity": o.config.chart.zoom.zoomedArea.stroke.opacity }), Graphics.setAttrs(l.node, c)), o.globals.selectionEnabled && (h.attr({ x: e2, y: i, width: s > 0 ? s : 0, height: a > 0 ? a : 0, fill: o.config.chart.selection.fill.color, "fill-opacity": o.config.chart.selection.fill.opacity, stroke: o.config.chart.selection.stroke.color, "stroke-width": o.config.chart.selection.stroke.width, "stroke-dasharray": o.config.chart.selection.stroke.dashArray, "stroke-opacity": o.config.chart.selection.stroke.opacity }), Graphics.setAttrs(h.node, c));
    }
  } }, { key: "hideSelectionRect", value: function(t2) {
    t2 && t2.attr({ x: 0, y: 0, width: 0, height: 0 });
  } }, { key: "selectionDrawing", value: function(t2) {
    var e2 = t2.context, i = t2.zoomtype, s = this.w, a = e2, r = this.gridRect.getBoundingClientRect(), n = a.startX - 1, o = a.startY, l = a.clientX - r.left - n, h = a.clientY - r.top - o, c = 0, d = 0, u = {};
    return Math.abs(l + n) > s.globals.gridWidth ? l = s.globals.gridWidth - n : a.clientX - r.left < 0 && (l = n), n > a.clientX - r.left && (c = -(l = Math.abs(l))), o > a.clientY - r.top && (d = -(h = Math.abs(h))), u = "x" === i ? { x: n, y: 0, width: l, height: s.globals.gridHeight, translateX: c, translateY: 0 } : "y" === i ? { x: 0, y: o, width: s.globals.gridWidth, height: h, translateX: 0, translateY: d } : { x: n, y: o, width: l, height: h, translateX: c, translateY: d }, a.drawSelectionRect(u), a.selectionDragging("resizing"), u;
  } }, { key: "selectionDragging", value: function(t2, e2) {
    var i = this, s = this.w, a = this.xyRatios, r = this.selectionRect, n = 0;
    "resizing" === t2 && (n = 30), "function" == typeof s.config.chart.events.selection && s.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout(function() {
      var t3 = i.gridRect.getBoundingClientRect(), e3 = r.node.getBoundingClientRect(), n2 = s.globals.xAxisScale.niceMin + (e3.left - t3.left) * a.xRatio, o = s.globals.xAxisScale.niceMin + (e3.right - t3.left) * a.xRatio, l = s.globals.yAxisScale[0].niceMin + (t3.bottom - e3.bottom) * a.yRatio[0], h = s.globals.yAxisScale[0].niceMax - (e3.top - t3.top) * a.yRatio[0];
      s.config.chart.events.selection(i.ctx, { xaxis: { min: n2, max: o }, yaxis: { min: l, max: h } });
    }, n));
  } }, { key: "selectionDrawn", value: function(t2) {
    var e2 = t2.context, i = t2.zoomtype, s = this.w, a = e2, r = this.xyRatios, n = this.ctx.toolbar;
    if (a.startX > a.endX) {
      var o = a.startX;
      a.startX = a.endX, a.endX = o;
    }
    if (a.startY > a.endY) {
      var l = a.startY;
      a.startY = a.endY, a.endY = l;
    }
    var h = s.globals.xAxisScale.niceMin + a.startX * r.xRatio, c = s.globals.xAxisScale.niceMin + a.endX * r.xRatio, d = [], u = [];
    if (s.config.yaxis.forEach(function(t3, e3) {
      d.push(Math.floor(s.globals.yAxisScale[e3].niceMax - r.yRatio[e3] * a.startY)), u.push(Math.floor(s.globals.yAxisScale[e3].niceMax - r.yRatio[e3] * a.endY));
    }), a.dragged && (a.dragX > 10 || a.dragY > 10) && h !== c) {
      if (s.globals.zoomEnabled) {
        var g = Utils.clone(s.globals.initialConfig.yaxis);
        s.globals.zoomed || (s.globals.lastXAxis = Utils.clone(s.config.xaxis), s.globals.lastYAxis = Utils.clone(s.config.yaxis));
        var f = { min: h, max: c };
        if ("xy" !== i && "y" !== i || g.forEach(function(t3, e3) {
          g[e3].min = u[e3], g[e3].max = d[e3];
        }), s.config.chart.zoom.autoScaleYaxis) {
          var p = new Range(a.ctx);
          g = p.autoScaleY(a.ctx, g, { xaxis: f });
        }
        if (n) {
          var x = n.getBeforeZoomRange(f, g);
          x && (f = x.xaxis ? x.xaxis : f, g = x.yaxis ? x.yaxe : g);
        }
        var m = { xaxis: f };
        s.config.chart.group || (m.yaxis = g), a.ctx._updateOptions(m, false, a.w.config.chart.animations.dynamicAnimation.enabled), "function" == typeof s.config.chart.events.zoomed && n.zoomCallback(f, g), s.globals.zoomed = true;
      } else if (s.globals.selectionEnabled) {
        var b, v = null;
        b = { min: h, max: c }, "xy" !== i && "y" !== i || (v = Utils.clone(s.config.yaxis)).forEach(function(t3, e3) {
          v[e3].min = u[e3], v[e3].max = d[e3];
        }), s.globals.selection = a.selection, "function" == typeof s.config.chart.events.selection && s.config.chart.events.selection(a.ctx, { xaxis: b, yaxis: v });
      }
    }
  } }, { key: "panDragging", value: function(t2) {
    var e2, i = t2.context, s = this.w, a = i;
    if (void 0 !== s.globals.lastClientPosition.x) {
      var r = s.globals.lastClientPosition.x - a.clientX, n = s.globals.lastClientPosition.y - a.clientY;
      Math.abs(r) > Math.abs(n) && r > 0 ? e2 = "left" : Math.abs(r) > Math.abs(n) && r < 0 ? e2 = "right" : Math.abs(n) > Math.abs(r) && n > 0 ? e2 = "up" : Math.abs(n) > Math.abs(r) && n < 0 && (e2 = "down");
    }
    s.globals.lastClientPosition = { x: a.clientX, y: a.clientY };
    var o = s.globals.minX, l = s.globals.maxX;
    a.panScrolled(e2, o, l);
  } }, { key: "panScrolled", value: function(t2, e2, i) {
    var s = this.w, a = this.xyRatios, r = Utils.clone(s.globals.initialConfig.yaxis);
    "left" === t2 ? (e2 = s.globals.minX + s.globals.gridWidth / 15 * a.xRatio, i = s.globals.maxX + s.globals.gridWidth / 15 * a.xRatio) : "right" === t2 && (e2 = s.globals.minX - s.globals.gridWidth / 15 * a.xRatio, i = s.globals.maxX - s.globals.gridWidth / 15 * a.xRatio), (e2 < s.globals.initialminX || i > s.globals.initialmaxX) && (e2 = s.globals.minX, i = s.globals.maxX);
    var n = { min: e2, max: i };
    s.config.chart.zoom.autoScaleYaxis && (r = new Range(this.ctx).autoScaleY(this.ctx, r, { xaxis: n }));
    var o = { xaxis: { min: e2, max: i } };
    s.config.chart.group || (o.yaxis = r), this.ctx._updateOptions(o, false, false), "function" == typeof s.config.chart.events.scrolled && s.config.chart.events.scrolled(this.ctx, { xaxis: { min: e2, max: i } });
  } }]), e;
})();
var TitleSubtitle = (function() {
  function t(e) {
    _classCallCheck(this, t), this.ctx = e, this.w = e.w;
  }
  return _createClass(t, [{ key: "draw", value: function() {
    this.drawTitleSubtitle("title"), this.drawTitleSubtitle("subtitle");
  } }, { key: "drawTitleSubtitle", value: function(t2) {
    var e = this.w, i = "title" === t2 ? e.config.title : e.config.subtitle, s = e.globals.svgWidth / 2, a = i.offsetY, r = "middle";
    if ("left" === i.align ? (s = 10, r = "start") : "right" === i.align && (s = e.globals.svgWidth - 10, r = "end"), s += i.offsetX, a = a + parseInt(i.style.fontSize) + 2, void 0 !== i.text) {
      var n = new Graphics(this.ctx).drawText({ x: s, y: a, text: i.text, textAnchor: r, fontSize: i.style.fontSize, fontFamily: i.style.fontFamily, foreColor: i.style.color, opacity: 1 });
      n.node.setAttribute("class", "apexcharts-".concat(t2, "-text")), e.globals.dom.Paper.add(n);
    }
  } }]), t;
})();
function styleInject(t, e) {
  void 0 === e && (e = {});
  var i = e.insertAt;
  if (t && "undefined" != typeof document) {
    var s = document.head || document.getElementsByTagName("head")[0], a = document.createElement("style");
    a.type = "text/css", "top" === i && s.firstChild ? s.insertBefore(a, s.firstChild) : s.appendChild(a), a.styleSheet ? a.styleSheet.cssText = t : a.appendChild(document.createTextNode(t));
  }
}
!(function(t, e) {
  "function" == typeof define && define.amd ? define(function() {
    return e(t, t.document);
  }) : "object" === ("undefined" == typeof exports ? "undefined" : _typeof(exports)) && "undefined" != typeof module ? module.exports = t.document ? e(t, t.document) : function(t2) {
    return e(t2, t2.document);
  } : t.SVG = e(t, t.document);
})("undefined" != typeof window ? window : void 0, function(t, e) {
  var i = (void 0 !== this ? this : t).SVG = function(t2) {
    if (i.supported) return t2 = new i.Doc(t2), i.parser.draw || i.prepare(), t2;
  };
  if (i.ns = "http://www.w3.org/2000/svg", i.xmlns = "http://www.w3.org/2000/xmlns/", i.xlink = "http://www.w3.org/1999/xlink", i.svgjs = "http://svgjs.com/svgjs", i.supported = true, !i.supported) return false;
  i.did = 1e3, i.eid = function(t2) {
    return "Svgjs" + c(t2) + i.did++;
  }, i.create = function(t2) {
    var i2 = e.createElementNS(this.ns, t2);
    return i2.setAttribute("id", this.eid(t2)), i2;
  }, i.extend = function() {
    var t2, e2, s2, a2;
    for (e2 = (t2 = [].slice.call(arguments)).pop(), a2 = t2.length - 1; a2 >= 0; a2--) if (t2[a2]) for (s2 in e2) t2[a2].prototype[s2] = e2[s2];
    i.Set && i.Set.inherit && i.Set.inherit();
  }, i.invent = function(t2) {
    var e2 = "function" == typeof t2.create ? t2.create : function() {
      this.constructor.call(this, i.create(t2.create));
    };
    return t2.inherit && (e2.prototype = new t2.inherit()), t2.extend && i.extend(e2, t2.extend), t2.construct && i.extend(t2.parent || i.Container, t2.construct), e2;
  }, i.adopt = function(e2) {
    return e2 ? e2.instance ? e2.instance : ((s2 = "svg" == e2.nodeName ? e2.parentNode instanceof t.SVGElement ? new i.Nested() : new i.Doc() : "linearGradient" == e2.nodeName ? new i.Gradient("linear") : "radialGradient" == e2.nodeName ? new i.Gradient("radial") : i[c(e2.nodeName)] ? new i[c(e2.nodeName)]() : new i.Element(e2)).type = e2.nodeName, s2.node = e2, e2.instance = s2, s2 instanceof i.Doc && s2.namespace().defs(), s2.setData(JSON.parse(e2.getAttribute("svgjs:data")) || {}), s2) : null;
    var s2;
  }, i.prepare = function() {
    var t2 = e.getElementsByTagName("body")[0], s2 = (t2 ? new i.Doc(t2) : i.adopt(e.documentElement).nested()).size(2, 0);
    i.parser = { body: t2 || e.documentElement, draw: s2.style("opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden").node, poly: s2.polyline().node, path: s2.path().node, native: i.create("svg") };
  }, i.parser = { native: i.create("svg") }, e.addEventListener("DOMContentLoaded", function() {
    i.parser.draw || i.prepare();
  }, false), i.regex = { numberAndUnit: /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i, hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, rgb: /rgb\((\d+),(\d+),(\d+)\)/, reference: /#([a-z0-9\-_]+)/i, transforms: /\)\s*,?\s*/, whitespace: /\s/g, isHex: /^#[a-f0-9]{3,6}$/i, isRgb: /^rgb\(/, isCss: /[^:]+:[^;]+;?/, isBlank: /^(\s+)?$/, isNumber: /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, isPercent: /^-?[\d\.]+%$/, isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i, delimiter: /[\s,]+/, hyphen: /([^e])\-/gi, pathLetters: /[MLHVCSQTAZ]/gi, isPathLetter: /[MLHVCSQTAZ]/i, numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi, dots: /\./g }, i.utils = { map: function(t2, e2) {
    var i2, s2 = t2.length, a2 = [];
    for (i2 = 0; i2 < s2; i2++) a2.push(e2(t2[i2]));
    return a2;
  }, filter: function(t2, e2) {
    var i2, s2 = t2.length, a2 = [];
    for (i2 = 0; i2 < s2; i2++) e2(t2[i2]) && a2.push(t2[i2]);
    return a2;
  }, radians: function(t2) {
    return t2 % 360 * Math.PI / 180;
  }, degrees: function(t2) {
    return 180 * t2 / Math.PI % 360;
  }, filterSVGElements: function(e2) {
    return this.filter(e2, function(e3) {
      return e3 instanceof t.SVGElement;
    });
  } }, i.defaults = { attrs: { "fill-opacity": 1, "stroke-opacity": 1, "stroke-width": 0, "stroke-linejoin": "miter", "stroke-linecap": "butt", fill: "#000000", stroke: "#000000", opacity: 1, x: 0, y: 0, cx: 0, cy: 0, width: 0, height: 0, r: 0, rx: 0, ry: 0, offset: 0, "stop-opacity": 1, "stop-color": "#000000", "font-size": 16, "font-family": "Helvetica, Arial, sans-serif", "text-anchor": "start" } }, i.Color = function(t2) {
    var e2, s2;
    (this.r = 0, this.g = 0, this.b = 0, t2) && ("string" == typeof t2 ? i.regex.isRgb.test(t2) ? (e2 = i.regex.rgb.exec(t2.replace(i.regex.whitespace, "")), this.r = parseInt(e2[1]), this.g = parseInt(e2[2]), this.b = parseInt(e2[3])) : i.regex.isHex.test(t2) && (e2 = i.regex.hex.exec(4 == (s2 = t2).length ? ["#", s2.substring(1, 2), s2.substring(1, 2), s2.substring(2, 3), s2.substring(2, 3), s2.substring(3, 4), s2.substring(3, 4)].join("") : s2), this.r = parseInt(e2[1], 16), this.g = parseInt(e2[2], 16), this.b = parseInt(e2[3], 16)) : "object" === _typeof(t2) && (this.r = t2.r, this.g = t2.g, this.b = t2.b));
  }, i.extend(i.Color, { toString: function() {
    return this.toHex();
  }, toHex: function() {
    return "#" + d(this.r) + d(this.g) + d(this.b);
  }, toRgb: function() {
    return "rgb(" + [this.r, this.g, this.b].join() + ")";
  }, brightness: function() {
    return this.r / 255 * 0.3 + this.g / 255 * 0.59 + this.b / 255 * 0.11;
  }, morph: function(t2) {
    return this.destination = new i.Color(t2), this;
  }, at: function(t2) {
    return this.destination ? (t2 = t2 < 0 ? 0 : t2 > 1 ? 1 : t2, new i.Color({ r: ~~(this.r + (this.destination.r - this.r) * t2), g: ~~(this.g + (this.destination.g - this.g) * t2), b: ~~(this.b + (this.destination.b - this.b) * t2) })) : this;
  } }), i.Color.test = function(t2) {
    return t2 += "", i.regex.isHex.test(t2) || i.regex.isRgb.test(t2);
  }, i.Color.isRgb = function(t2) {
    return t2 && "number" == typeof t2.r && "number" == typeof t2.g && "number" == typeof t2.b;
  }, i.Color.isColor = function(t2) {
    return i.Color.isRgb(t2) || i.Color.test(t2);
  }, i.Array = function(t2, e2) {
    0 == (t2 = (t2 || []).valueOf()).length && e2 && (t2 = e2.valueOf()), this.value = this.parse(t2);
  }, i.extend(i.Array, { morph: function(t2) {
    if (this.destination = this.parse(t2), this.value.length != this.destination.length) {
      for (var e2 = this.value[this.value.length - 1], i2 = this.destination[this.destination.length - 1]; this.value.length > this.destination.length; ) this.destination.push(i2);
      for (; this.value.length < this.destination.length; ) this.value.push(e2);
    }
    return this;
  }, settle: function() {
    for (var t2 = 0, e2 = this.value.length, i2 = []; t2 < e2; t2++) -1 == i2.indexOf(this.value[t2]) && i2.push(this.value[t2]);
    return this.value = i2;
  }, at: function(t2) {
    if (!this.destination) return this;
    for (var e2 = 0, s2 = this.value.length, a2 = []; e2 < s2; e2++) a2.push(this.value[e2] + (this.destination[e2] - this.value[e2]) * t2);
    return new i.Array(a2);
  }, toString: function() {
    return this.value.join(" ");
  }, valueOf: function() {
    return this.value;
  }, parse: function(t2) {
    return t2 = t2.valueOf(), Array.isArray(t2) ? t2 : this.split(t2);
  }, split: function(t2) {
    return t2.trim().split(i.regex.delimiter).map(parseFloat);
  }, reverse: function() {
    return this.value.reverse(), this;
  }, clone: function() {
    var t2 = new this.constructor();
    return t2.value = (function t3(e2) {
      var i2 = e2.slice(0);
      for (var s2 = i2.length; s2--; ) Array.isArray(i2[s2]) && (i2[s2] = t3(i2[s2]));
      return i2;
    })(this.value), t2;
  } }), i.PointArray = function(t2, e2) {
    i.Array.call(this, t2, e2 || [[0, 0]]);
  }, i.PointArray.prototype = new i.Array(), i.PointArray.prototype.constructor = i.PointArray, i.extend(i.PointArray, { toString: function() {
    for (var t2 = 0, e2 = this.value.length, i2 = []; t2 < e2; t2++) i2.push(this.value[t2].join(","));
    return i2.join(" ");
  }, toLine: function() {
    return { x1: this.value[0][0], y1: this.value[0][1], x2: this.value[1][0], y2: this.value[1][1] };
  }, at: function(t2) {
    if (!this.destination) return this;
    for (var e2 = 0, s2 = this.value.length, a2 = []; e2 < s2; e2++) a2.push([this.value[e2][0] + (this.destination[e2][0] - this.value[e2][0]) * t2, this.value[e2][1] + (this.destination[e2][1] - this.value[e2][1]) * t2]);
    return new i.PointArray(a2);
  }, parse: function(t2) {
    var e2 = [];
    if (t2 = t2.valueOf(), Array.isArray(t2)) {
      if (Array.isArray(t2[0])) return t2.map(function(t3) {
        return t3.slice();
      });
      if (null != t2[0].x) return t2.map(function(t3) {
        return [t3.x, t3.y];
      });
    } else t2 = t2.trim().split(i.regex.delimiter).map(parseFloat);
    t2.length % 2 != 0 && t2.pop();
    for (var s2 = 0, a2 = t2.length; s2 < a2; s2 += 2) e2.push([t2[s2], t2[s2 + 1]]);
    return e2;
  }, move: function(t2, e2) {
    var i2 = this.bbox();
    if (t2 -= i2.x, e2 -= i2.y, !isNaN(t2) && !isNaN(e2)) for (var s2 = this.value.length - 1; s2 >= 0; s2--) this.value[s2] = [this.value[s2][0] + t2, this.value[s2][1] + e2];
    return this;
  }, size: function(t2, e2) {
    var i2, s2 = this.bbox();
    for (i2 = this.value.length - 1; i2 >= 0; i2--) s2.width && (this.value[i2][0] = (this.value[i2][0] - s2.x) * t2 / s2.width + s2.x), s2.height && (this.value[i2][1] = (this.value[i2][1] - s2.y) * e2 / s2.height + s2.y);
    return this;
  }, bbox: function() {
    return i.parser.draw || i.prepare(), i.parser.poly.setAttribute("points", this.toString()), i.parser.poly.getBBox();
  } });
  for (var s = { M: function(t2, e2, i2) {
    return e2.x = i2.x = t2[0], e2.y = i2.y = t2[1], ["M", e2.x, e2.y];
  }, L: function(t2, e2) {
    return e2.x = t2[0], e2.y = t2[1], ["L", t2[0], t2[1]];
  }, H: function(t2, e2) {
    return e2.x = t2[0], ["H", t2[0]];
  }, V: function(t2, e2) {
    return e2.y = t2[0], ["V", t2[0]];
  }, C: function(t2, e2) {
    return e2.x = t2[4], e2.y = t2[5], ["C", t2[0], t2[1], t2[2], t2[3], t2[4], t2[5]];
  }, S: function(t2, e2) {
    return e2.x = t2[2], e2.y = t2[3], ["S", t2[0], t2[1], t2[2], t2[3]];
  }, Q: function(t2, e2) {
    return e2.x = t2[2], e2.y = t2[3], ["Q", t2[0], t2[1], t2[2], t2[3]];
  }, T: function(t2, e2) {
    return e2.x = t2[0], e2.y = t2[1], ["T", t2[0], t2[1]];
  }, Z: function(t2, e2, i2) {
    return e2.x = i2.x, e2.y = i2.y, ["Z"];
  }, A: function(t2, e2) {
    return e2.x = t2[5], e2.y = t2[6], ["A", t2[0], t2[1], t2[2], t2[3], t2[4], t2[5], t2[6]];
  } }, a = "mlhvqtcsaz".split(""), r = 0, n = a.length; r < n; ++r) s[a[r]] = /* @__PURE__ */ (function(t2) {
    return function(e2, i2, a2) {
      if ("H" == t2) e2[0] = e2[0] + i2.x;
      else if ("V" == t2) e2[0] = e2[0] + i2.y;
      else if ("A" == t2) e2[5] = e2[5] + i2.x, e2[6] = e2[6] + i2.y;
      else for (var r2 = 0, n2 = e2.length; r2 < n2; ++r2) e2[r2] = e2[r2] + (r2 % 2 ? i2.y : i2.x);
      return s[t2](e2, i2, a2);
    };
  })(a[r].toUpperCase());
  i.PathArray = function(t2, e2) {
    i.Array.call(this, t2, e2 || [["M", 0, 0]]);
  }, i.PathArray.prototype = new i.Array(), i.PathArray.prototype.constructor = i.PathArray, i.extend(i.PathArray, { toString: function() {
    return (function(t2) {
      for (var e2 = 0, i2 = t2.length, s2 = ""; e2 < i2; e2++) s2 += t2[e2][0], null != t2[e2][1] && (s2 += t2[e2][1], null != t2[e2][2] && (s2 += " ", s2 += t2[e2][2], null != t2[e2][3] && (s2 += " ", s2 += t2[e2][3], s2 += " ", s2 += t2[e2][4], null != t2[e2][5] && (s2 += " ", s2 += t2[e2][5], s2 += " ", s2 += t2[e2][6], null != t2[e2][7] && (s2 += " ", s2 += t2[e2][7])))));
      return s2 + " ";
    })(this.value);
  }, move: function(t2, e2) {
    var i2 = this.bbox();
    if (t2 -= i2.x, e2 -= i2.y, !isNaN(t2) && !isNaN(e2)) for (var s2, a2 = this.value.length - 1; a2 >= 0; a2--) "M" == (s2 = this.value[a2][0]) || "L" == s2 || "T" == s2 ? (this.value[a2][1] += t2, this.value[a2][2] += e2) : "H" == s2 ? this.value[a2][1] += t2 : "V" == s2 ? this.value[a2][1] += e2 : "C" == s2 || "S" == s2 || "Q" == s2 ? (this.value[a2][1] += t2, this.value[a2][2] += e2, this.value[a2][3] += t2, this.value[a2][4] += e2, "C" == s2 && (this.value[a2][5] += t2, this.value[a2][6] += e2)) : "A" == s2 && (this.value[a2][6] += t2, this.value[a2][7] += e2);
    return this;
  }, size: function(t2, e2) {
    var i2, s2, a2 = this.bbox();
    for (i2 = this.value.length - 1; i2 >= 0; i2--) "M" == (s2 = this.value[i2][0]) || "L" == s2 || "T" == s2 ? (this.value[i2][1] = (this.value[i2][1] - a2.x) * t2 / a2.width + a2.x, this.value[i2][2] = (this.value[i2][2] - a2.y) * e2 / a2.height + a2.y) : "H" == s2 ? this.value[i2][1] = (this.value[i2][1] - a2.x) * t2 / a2.width + a2.x : "V" == s2 ? this.value[i2][1] = (this.value[i2][1] - a2.y) * e2 / a2.height + a2.y : "C" == s2 || "S" == s2 || "Q" == s2 ? (this.value[i2][1] = (this.value[i2][1] - a2.x) * t2 / a2.width + a2.x, this.value[i2][2] = (this.value[i2][2] - a2.y) * e2 / a2.height + a2.y, this.value[i2][3] = (this.value[i2][3] - a2.x) * t2 / a2.width + a2.x, this.value[i2][4] = (this.value[i2][4] - a2.y) * e2 / a2.height + a2.y, "C" == s2 && (this.value[i2][5] = (this.value[i2][5] - a2.x) * t2 / a2.width + a2.x, this.value[i2][6] = (this.value[i2][6] - a2.y) * e2 / a2.height + a2.y)) : "A" == s2 && (this.value[i2][1] = this.value[i2][1] * t2 / a2.width, this.value[i2][2] = this.value[i2][2] * e2 / a2.height, this.value[i2][6] = (this.value[i2][6] - a2.x) * t2 / a2.width + a2.x, this.value[i2][7] = (this.value[i2][7] - a2.y) * e2 / a2.height + a2.y);
    return this;
  }, equalCommands: function(t2) {
    var e2, s2, a2;
    for (t2 = new i.PathArray(t2), a2 = this.value.length === t2.value.length, e2 = 0, s2 = this.value.length; a2 && e2 < s2; e2++) a2 = this.value[e2][0] === t2.value[e2][0];
    return a2;
  }, morph: function(t2) {
    return t2 = new i.PathArray(t2), this.equalCommands(t2) ? this.destination = t2 : this.destination = null, this;
  }, at: function(t2) {
    if (!this.destination) return this;
    var e2, s2, a2, r2, n2 = this.value, o2 = this.destination.value, l2 = [], h2 = new i.PathArray();
    for (e2 = 0, s2 = n2.length; e2 < s2; e2++) {
      for (l2[e2] = [n2[e2][0]], a2 = 1, r2 = n2[e2].length; a2 < r2; a2++) l2[e2][a2] = n2[e2][a2] + (o2[e2][a2] - n2[e2][a2]) * t2;
      "A" === l2[e2][0] && (l2[e2][4] = +(0 != l2[e2][4]), l2[e2][5] = +(0 != l2[e2][5]));
    }
    return h2.value = l2, h2;
  }, parse: function(t2) {
    if (t2 instanceof i.PathArray) return t2.valueOf();
    var e2, a2 = { M: 2, L: 2, H: 1, V: 1, C: 6, S: 4, Q: 4, T: 2, A: 7, Z: 0 };
    t2 = "string" == typeof t2 ? t2.replace(i.regex.numbersWithDots, l).replace(i.regex.pathLetters, " $& ").replace(i.regex.hyphen, "$1 -").trim().split(i.regex.delimiter) : t2.reduce(function(t3, e3) {
      return [].concat.call(t3, e3);
    }, []);
    var r2 = [], n2 = new i.Point(), o2 = new i.Point(), h2 = 0, c2 = t2.length;
    do {
      i.regex.isPathLetter.test(t2[h2]) ? (e2 = t2[h2], ++h2) : "M" == e2 ? e2 = "L" : "m" == e2 && (e2 = "l"), r2.push(s[e2].call(null, t2.slice(h2, h2 += a2[e2.toUpperCase()]).map(parseFloat), n2, o2));
    } while (c2 > h2);
    return r2;
  }, bbox: function() {
    return i.parser.draw || i.prepare(), i.parser.path.setAttribute("d", this.toString()), i.parser.path.getBBox();
  } }), i.Number = i.invent({ create: function(t2, e2) {
    this.value = 0, this.unit = e2 || "", "number" == typeof t2 ? this.value = isNaN(t2) ? 0 : isFinite(t2) ? t2 : t2 < 0 ? -34e37 : 34e37 : "string" == typeof t2 ? (e2 = t2.match(i.regex.numberAndUnit)) && (this.value = parseFloat(e2[1]), "%" == e2[5] ? this.value /= 100 : "s" == e2[5] && (this.value *= 1e3), this.unit = e2[5]) : t2 instanceof i.Number && (this.value = t2.valueOf(), this.unit = t2.unit);
  }, extend: { toString: function() {
    return ("%" == this.unit ? ~~(1e8 * this.value) / 1e6 : "s" == this.unit ? this.value / 1e3 : this.value) + this.unit;
  }, toJSON: function() {
    return this.toString();
  }, valueOf: function() {
    return this.value;
  }, plus: function(t2) {
    return t2 = new i.Number(t2), new i.Number(this + t2, this.unit || t2.unit);
  }, minus: function(t2) {
    return t2 = new i.Number(t2), new i.Number(this - t2, this.unit || t2.unit);
  }, times: function(t2) {
    return t2 = new i.Number(t2), new i.Number(this * t2, this.unit || t2.unit);
  }, divide: function(t2) {
    return t2 = new i.Number(t2), new i.Number(this / t2, this.unit || t2.unit);
  }, to: function(t2) {
    var e2 = new i.Number(this);
    return "string" == typeof t2 && (e2.unit = t2), e2;
  }, morph: function(t2) {
    return this.destination = new i.Number(t2), t2.relative && (this.destination.value += this.value), this;
  }, at: function(t2) {
    return this.destination ? new i.Number(this.destination).minus(this).times(t2).plus(this) : this;
  } } }), i.Element = i.invent({ create: function(t2) {
    this._stroke = i.defaults.attrs.stroke, this._event = null, this.dom = {}, (this.node = t2) && (this.type = t2.nodeName, this.node.instance = this, this._stroke = t2.getAttribute("stroke") || this._stroke);
  }, extend: { x: function(t2) {
    return this.attr("x", t2);
  }, y: function(t2) {
    return this.attr("y", t2);
  }, cx: function(t2) {
    return null == t2 ? this.x() + this.width() / 2 : this.x(t2 - this.width() / 2);
  }, cy: function(t2) {
    return null == t2 ? this.y() + this.height() / 2 : this.y(t2 - this.height() / 2);
  }, move: function(t2, e2) {
    return this.x(t2).y(e2);
  }, center: function(t2, e2) {
    return this.cx(t2).cy(e2);
  }, width: function(t2) {
    return this.attr("width", t2);
  }, height: function(t2) {
    return this.attr("height", t2);
  }, size: function(t2, e2) {
    var s2 = u(this, t2, e2);
    return this.width(new i.Number(s2.width)).height(new i.Number(s2.height));
  }, clone: function(t2) {
    this.writeDataToDom();
    var e2 = x(this.node.cloneNode(true));
    return t2 ? t2.add(e2) : this.after(e2), e2;
  }, remove: function() {
    return this.parent() && this.parent().removeElement(this), this;
  }, replace: function(t2) {
    return this.after(t2).remove(), t2;
  }, addTo: function(t2) {
    return t2.put(this);
  }, putIn: function(t2) {
    return t2.add(this);
  }, id: function(t2) {
    return this.attr("id", t2);
  }, inside: function(t2, e2) {
    var i2 = this.bbox();
    return t2 > i2.x && e2 > i2.y && t2 < i2.x + i2.width && e2 < i2.y + i2.height;
  }, show: function() {
    return this.style("display", "");
  }, hide: function() {
    return this.style("display", "none");
  }, visible: function() {
    return "none" != this.style("display");
  }, toString: function() {
    return this.attr("id");
  }, classes: function() {
    var t2 = this.attr("class");
    return null == t2 ? [] : t2.trim().split(i.regex.delimiter);
  }, hasClass: function(t2) {
    return -1 != this.classes().indexOf(t2);
  }, addClass: function(t2) {
    if (!this.hasClass(t2)) {
      var e2 = this.classes();
      e2.push(t2), this.attr("class", e2.join(" "));
    }
    return this;
  }, removeClass: function(t2) {
    return this.hasClass(t2) && this.attr("class", this.classes().filter(function(e2) {
      return e2 != t2;
    }).join(" ")), this;
  }, toggleClass: function(t2) {
    return this.hasClass(t2) ? this.removeClass(t2) : this.addClass(t2);
  }, reference: function(t2) {
    return i.get(this.attr(t2));
  }, parent: function(e2) {
    var s2 = this;
    if (!s2.node.parentNode) return null;
    if (s2 = i.adopt(s2.node.parentNode), !e2) return s2;
    for (; s2 && s2.node instanceof t.SVGElement; ) {
      if ("string" == typeof e2 ? s2.matches(e2) : s2 instanceof e2) return s2;
      if (!s2.node.parentNode || "#document" == s2.node.parentNode.nodeName) return null;
      s2 = i.adopt(s2.node.parentNode);
    }
  }, doc: function() {
    return this instanceof i.Doc ? this : this.parent(i.Doc);
  }, parents: function(t2) {
    var e2 = [], i2 = this;
    do {
      if (!(i2 = i2.parent(t2)) || !i2.node) break;
      e2.push(i2);
    } while (i2.parent);
    return e2;
  }, matches: function(t2) {
    return (function(t3, e2) {
      return (t3.matches || t3.matchesSelector || t3.msMatchesSelector || t3.mozMatchesSelector || t3.webkitMatchesSelector || t3.oMatchesSelector).call(t3, e2);
    })(this.node, t2);
  }, native: function() {
    return this.node;
  }, svg: function(t2) {
    var s2 = e.createElement("svg");
    if (!(t2 && this instanceof i.Parent)) return s2.appendChild(t2 = e.createElement("svg")), this.writeDataToDom(), t2.appendChild(this.node.cloneNode(true)), s2.innerHTML.replace(/^<svg>/, "").replace(/<\/svg>$/, "");
    s2.innerHTML = "<svg>" + t2.replace(/\n/, "").replace(/<([\w:-]+)([^<]+?)\/>/g, "<$1$2></$1>") + "</svg>";
    for (var a2 = 0, r2 = s2.firstChild.childNodes.length; a2 < r2; a2++) this.node.appendChild(s2.firstChild.firstChild);
    return this;
  }, writeDataToDom: function() {
    (this.each || this.lines) && (this.each ? this : this.lines()).each(function() {
      this.writeDataToDom();
    });
    return this.node.removeAttribute("svgjs:data"), Object.keys(this.dom).length && this.node.setAttribute("svgjs:data", JSON.stringify(this.dom)), this;
  }, setData: function(t2) {
    return this.dom = t2, this;
  }, is: function(t2) {
    return (function(t3, e2) {
      return t3 instanceof e2;
    })(this, t2);
  } } }), i.easing = { "-": function(t2) {
    return t2;
  }, "<>": function(t2) {
    return -Math.cos(t2 * Math.PI) / 2 + 0.5;
  }, ">": function(t2) {
    return Math.sin(t2 * Math.PI / 2);
  }, "<": function(t2) {
    return 1 - Math.cos(t2 * Math.PI / 2);
  } }, i.morph = function(t2) {
    return function(e2, s2) {
      return new i.MorphObj(e2, s2).at(t2);
    };
  }, i.Situation = i.invent({ create: function(t2) {
    this.init = false, this.reversed = false, this.reversing = false, this.duration = new i.Number(t2.duration).valueOf(), this.delay = new i.Number(t2.delay).valueOf(), this.start = +/* @__PURE__ */ new Date() + this.delay, this.finish = this.start + this.duration, this.ease = t2.ease, this.loop = 0, this.loops = false, this.animations = {}, this.attrs = {}, this.styles = {}, this.transforms = [], this.once = {};
  } }), i.FX = i.invent({ create: function(t2) {
    this._target = t2, this.situations = [], this.active = false, this.situation = null, this.paused = false, this.lastPos = 0, this.pos = 0, this.absPos = 0, this._speed = 1;
  }, extend: { animate: function(t2, e2, s2) {
    "object" === _typeof(t2) && (e2 = t2.ease, s2 = t2.delay, t2 = t2.duration);
    var a2 = new i.Situation({ duration: t2 || 1e3, delay: s2 || 0, ease: i.easing[e2 || "-"] || e2 });
    return this.queue(a2), this;
  }, delay: function(t2) {
    var e2 = new i.Situation({ duration: t2, delay: 0, ease: i.easing["-"] });
    return this.queue(e2);
  }, target: function(t2) {
    return t2 && t2 instanceof i.Element ? (this._target = t2, this) : this._target;
  }, timeToAbsPos: function(t2) {
    return (t2 - this.situation.start) / (this.situation.duration / this._speed);
  }, absPosToTime: function(t2) {
    return this.situation.duration / this._speed * t2 + this.situation.start;
  }, startAnimFrame: function() {
    this.stopAnimFrame(), this.animationFrame = t.requestAnimationFrame((function() {
      this.step();
    }).bind(this));
  }, stopAnimFrame: function() {
    t.cancelAnimationFrame(this.animationFrame);
  }, start: function() {
    return !this.active && this.situation && (this.active = true, this.startCurrent()), this;
  }, startCurrent: function() {
    return this.situation.start = +/* @__PURE__ */ new Date() + this.situation.delay / this._speed, this.situation.finish = this.situation.start + this.situation.duration / this._speed, this.initAnimations().step();
  }, queue: function(t2) {
    return ("function" == typeof t2 || t2 instanceof i.Situation) && this.situations.push(t2), this.situation || (this.situation = this.situations.shift()), this;
  }, dequeue: function() {
    return this.stop(), this.situation = this.situations.shift(), this.situation && (this.situation instanceof i.Situation ? this.start() : this.situation.call(this)), this;
  }, initAnimations: function() {
    var t2, e2, s2, a2 = this.situation;
    if (a2.init) return this;
    for (t2 in a2.animations) for (s2 = this.target()[t2](), Array.isArray(s2) || (s2 = [s2]), Array.isArray(a2.animations[t2]) || (a2.animations[t2] = [a2.animations[t2]]), e2 = s2.length; e2--; ) a2.animations[t2][e2] instanceof i.Number && (s2[e2] = new i.Number(s2[e2])), a2.animations[t2][e2] = s2[e2].morph(a2.animations[t2][e2]);
    for (t2 in a2.attrs) a2.attrs[t2] = new i.MorphObj(this.target().attr(t2), a2.attrs[t2]);
    for (t2 in a2.styles) a2.styles[t2] = new i.MorphObj(this.target().style(t2), a2.styles[t2]);
    return a2.initialTransformation = this.target().matrixify(), a2.init = true, this;
  }, clearQueue: function() {
    return this.situations = [], this;
  }, clearCurrent: function() {
    return this.situation = null, this;
  }, stop: function(t2, e2) {
    var i2 = this.active;
    return this.active = false, e2 && this.clearQueue(), t2 && this.situation && (!i2 && this.startCurrent(), this.atEnd()), this.stopAnimFrame(), this.clearCurrent();
  }, reset: function() {
    if (this.situation) {
      var t2 = this.situation;
      this.stop(), this.situation = t2, this.atStart();
    }
    return this;
  }, finish: function() {
    for (this.stop(true, false); this.dequeue().situation && this.stop(true, false); ) ;
    return this.clearQueue().clearCurrent(), this;
  }, atStart: function() {
    return this.at(0, true);
  }, atEnd: function() {
    return true === this.situation.loops && (this.situation.loops = this.situation.loop + 1), "number" == typeof this.situation.loops ? this.at(this.situation.loops, true) : this.at(1, true);
  }, at: function(t2, e2) {
    var i2 = this.situation.duration / this._speed;
    return this.absPos = t2, e2 || (this.situation.reversed && (this.absPos = 1 - this.absPos), this.absPos += this.situation.loop), this.situation.start = +/* @__PURE__ */ new Date() - this.absPos * i2, this.situation.finish = this.situation.start + i2, this.step(true);
  }, speed: function(t2) {
    return 0 === t2 ? this.pause() : t2 ? (this._speed = t2, this.at(this.absPos, true)) : this._speed;
  }, loop: function(t2, e2) {
    var i2 = this.last();
    return i2.loops = null == t2 || t2, i2.loop = 0, e2 && (i2.reversing = true), this;
  }, pause: function() {
    return this.paused = true, this.stopAnimFrame(), this;
  }, play: function() {
    return this.paused ? (this.paused = false, this.at(this.absPos, true)) : this;
  }, reverse: function(t2) {
    var e2 = this.last();
    return e2.reversed = void 0 === t2 ? !e2.reversed : t2, this;
  }, progress: function(t2) {
    return t2 ? this.situation.ease(this.pos) : this.pos;
  }, after: function(t2) {
    var e2 = this.last();
    return this.target().on("finished.fx", function i2(s2) {
      s2.detail.situation == e2 && (t2.call(this, e2), this.off("finished.fx", i2));
    }), this._callStart();
  }, during: function(t2) {
    var e2 = this.last(), s2 = function(s3) {
      s3.detail.situation == e2 && t2.call(this, s3.detail.pos, i.morph(s3.detail.pos), s3.detail.eased, e2);
    };
    return this.target().off("during.fx", s2).on("during.fx", s2), this.after(function() {
      this.off("during.fx", s2);
    }), this._callStart();
  }, afterAll: function(t2) {
    var e2 = function e3(i2) {
      t2.call(this), this.off("allfinished.fx", e3);
    };
    return this.target().off("allfinished.fx", e2).on("allfinished.fx", e2), this._callStart();
  }, duringAll: function(t2) {
    var e2 = function(e3) {
      t2.call(this, e3.detail.pos, i.morph(e3.detail.pos), e3.detail.eased, e3.detail.situation);
    };
    return this.target().off("during.fx", e2).on("during.fx", e2), this.afterAll(function() {
      this.off("during.fx", e2);
    }), this._callStart();
  }, last: function() {
    return this.situations.length ? this.situations[this.situations.length - 1] : this.situation;
  }, add: function(t2, e2, i2) {
    return this.last()[i2 || "animations"][t2] = e2, this._callStart();
  }, step: function(t2) {
    var e2, i2, s2;
    (t2 || (this.absPos = this.timeToAbsPos(+/* @__PURE__ */ new Date())), false !== this.situation.loops) ? (e2 = Math.max(this.absPos, 0), i2 = Math.floor(e2), true === this.situation.loops || i2 < this.situation.loops ? (this.pos = e2 - i2, s2 = this.situation.loop, this.situation.loop = i2) : (this.absPos = this.situation.loops, this.pos = 1, s2 = this.situation.loop - 1, this.situation.loop = this.situation.loops), this.situation.reversing && (this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - s2) % 2))) : (this.absPos = Math.min(this.absPos, 1), this.pos = this.absPos);
    this.pos < 0 && (this.pos = 0), this.situation.reversed && (this.pos = 1 - this.pos);
    var a2 = this.situation.ease(this.pos);
    for (var r2 in this.situation.once) r2 > this.lastPos && r2 <= a2 && (this.situation.once[r2].call(this.target(), this.pos, a2), delete this.situation.once[r2]);
    return this.active && this.target().fire("during", { pos: this.pos, eased: a2, fx: this, situation: this.situation }), this.situation ? (this.eachAt(), 1 == this.pos && !this.situation.reversed || this.situation.reversed && 0 == this.pos ? (this.stopAnimFrame(), this.target().fire("finished", { fx: this, situation: this.situation }), this.situations.length || (this.target().fire("allfinished"), this.situations.length || (this.target().off(".fx"), this.active = false)), this.active ? this.dequeue() : this.clearCurrent()) : !this.paused && this.active && this.startAnimFrame(), this.lastPos = a2, this) : this;
  }, eachAt: function() {
    var t2, e2, s2, a2 = this, r2 = this.target(), n2 = this.situation;
    for (t2 in n2.animations) s2 = [].concat(n2.animations[t2]).map(function(t3) {
      return "string" != typeof t3 && t3.at ? t3.at(n2.ease(a2.pos), a2.pos) : t3;
    }), r2[t2].apply(r2, s2);
    for (t2 in n2.attrs) s2 = [t2].concat(n2.attrs[t2]).map(function(t3) {
      return "string" != typeof t3 && t3.at ? t3.at(n2.ease(a2.pos), a2.pos) : t3;
    }), r2.attr.apply(r2, s2);
    for (t2 in n2.styles) s2 = [t2].concat(n2.styles[t2]).map(function(t3) {
      return "string" != typeof t3 && t3.at ? t3.at(n2.ease(a2.pos), a2.pos) : t3;
    }), r2.style.apply(r2, s2);
    if (n2.transforms.length) {
      for (s2 = n2.initialTransformation, t2 = 0, e2 = n2.transforms.length; t2 < e2; t2++) {
        var o2 = n2.transforms[t2];
        o2 instanceof i.Matrix ? s2 = o2.relative ? s2.multiply(new i.Matrix().morph(o2).at(n2.ease(this.pos))) : s2.morph(o2).at(n2.ease(this.pos)) : (o2.relative || o2.undo(s2.extract()), s2 = s2.multiply(o2.at(n2.ease(this.pos))));
      }
      r2.matrix(s2);
    }
    return this;
  }, once: function(t2, e2, i2) {
    var s2 = this.last();
    return i2 || (t2 = s2.ease(t2)), s2.once[t2] = e2, this;
  }, _callStart: function() {
    return setTimeout((function() {
      this.start();
    }).bind(this), 0), this;
  } }, parent: i.Element, construct: { animate: function(t2, e2, s2) {
    return (this.fx || (this.fx = new i.FX(this))).animate(t2, e2, s2);
  }, delay: function(t2) {
    return (this.fx || (this.fx = new i.FX(this))).delay(t2);
  }, stop: function(t2, e2) {
    return this.fx && this.fx.stop(t2, e2), this;
  }, finish: function() {
    return this.fx && this.fx.finish(), this;
  }, pause: function() {
    return this.fx && this.fx.pause(), this;
  }, play: function() {
    return this.fx && this.fx.play(), this;
  }, speed: function(t2) {
    if (this.fx) {
      if (null == t2) return this.fx.speed();
      this.fx.speed(t2);
    }
    return this;
  } } }), i.MorphObj = i.invent({ create: function(t2, e2) {
    return i.Color.isColor(e2) ? new i.Color(t2).morph(e2) : i.regex.delimiter.test(t2) ? i.regex.pathLetters.test(t2) ? new i.PathArray(t2).morph(e2) : new i.Array(t2).morph(e2) : i.regex.numberAndUnit.test(e2) ? new i.Number(t2).morph(e2) : (this.value = t2, void (this.destination = e2));
  }, extend: { at: function(t2, e2) {
    return e2 < 1 ? this.value : this.destination;
  }, valueOf: function() {
    return this.value;
  } } }), i.extend(i.FX, { attr: function(t2, e2, i2) {
    if ("object" === _typeof(t2)) for (var s2 in t2) this.attr(s2, t2[s2]);
    else this.add(t2, e2, "attrs");
    return this;
  }, style: function(t2, e2) {
    if ("object" === _typeof(t2)) for (var i2 in t2) this.style(i2, t2[i2]);
    else this.add(t2, e2, "styles");
    return this;
  }, x: function(t2, e2) {
    if (this.target() instanceof i.G) return this.transform({ x: t2 }, e2), this;
    var s2 = new i.Number(t2);
    return s2.relative = e2, this.add("x", s2);
  }, y: function(t2, e2) {
    if (this.target() instanceof i.G) return this.transform({ y: t2 }, e2), this;
    var s2 = new i.Number(t2);
    return s2.relative = e2, this.add("y", s2);
  }, cx: function(t2) {
    return this.add("cx", new i.Number(t2));
  }, cy: function(t2) {
    return this.add("cy", new i.Number(t2));
  }, move: function(t2, e2) {
    return this.x(t2).y(e2);
  }, center: function(t2, e2) {
    return this.cx(t2).cy(e2);
  }, size: function(t2, e2) {
    var s2;
    this.target() instanceof i.Text ? this.attr("font-size", t2) : (t2 && e2 || (s2 = this.target().bbox()), t2 || (t2 = s2.width / s2.height * e2), e2 || (e2 = s2.height / s2.width * t2), this.add("width", new i.Number(t2)).add("height", new i.Number(e2)));
    return this;
  }, width: function(t2) {
    return this.add("width", new i.Number(t2));
  }, height: function(t2) {
    return this.add("height", new i.Number(t2));
  }, plot: function(t2, e2, i2, s2) {
    return 4 == arguments.length ? this.plot([t2, e2, i2, s2]) : this.add("plot", new (this.target()).morphArray(t2));
  }, leading: function(t2) {
    return this.target().leading ? this.add("leading", new i.Number(t2)) : this;
  }, viewbox: function(t2, e2, s2, a2) {
    return this.target() instanceof i.Container && this.add("viewbox", new i.ViewBox(t2, e2, s2, a2)), this;
  }, update: function(t2) {
    if (this.target() instanceof i.Stop) {
      if ("number" == typeof t2 || t2 instanceof i.Number) return this.update({ offset: arguments[0], color: arguments[1], opacity: arguments[2] });
      null != t2.opacity && this.attr("stop-opacity", t2.opacity), null != t2.color && this.attr("stop-color", t2.color), null != t2.offset && this.attr("offset", t2.offset);
    }
    return this;
  } }), i.Box = i.invent({ create: function(t2, e2, s2, a2) {
    if (!("object" !== _typeof(t2) || t2 instanceof i.Element)) return i.Box.call(this, null != t2.left ? t2.left : t2.x, null != t2.top ? t2.top : t2.y, t2.width, t2.height);
    4 == arguments.length && (this.x = t2, this.y = e2, this.width = s2, this.height = a2), m(this);
  }, extend: { merge: function(t2) {
    var e2 = new this.constructor();
    return e2.x = Math.min(this.x, t2.x), e2.y = Math.min(this.y, t2.y), e2.width = Math.max(this.x + this.width, t2.x + t2.width) - e2.x, e2.height = Math.max(this.y + this.height, t2.y + t2.height) - e2.y, m(e2);
  }, transform: function(t2) {
    var e2, s2 = 1 / 0, a2 = -1 / 0, r2 = 1 / 0, n2 = -1 / 0;
    return [new i.Point(this.x, this.y), new i.Point(this.x2, this.y), new i.Point(this.x, this.y2), new i.Point(this.x2, this.y2)].forEach(function(e3) {
      e3 = e3.transform(t2), s2 = Math.min(s2, e3.x), a2 = Math.max(a2, e3.x), r2 = Math.min(r2, e3.y), n2 = Math.max(n2, e3.y);
    }), (e2 = new this.constructor()).x = s2, e2.width = a2 - s2, e2.y = r2, e2.height = n2 - r2, m(e2), e2;
  } } }), i.BBox = i.invent({ create: function(t2) {
    if (i.Box.apply(this, [].slice.call(arguments)), t2 instanceof i.Element) {
      var s2;
      try {
        if (!e.documentElement.contains) {
          for (var a2 = t2.node; a2.parentNode; ) a2 = a2.parentNode;
          if (a2 != e) throw new Error("Element not in the dom");
        }
        s2 = t2.node.getBBox();
      } catch (e2) {
        if (t2 instanceof i.Shape) {
          i.parser.draw || i.prepare();
          var r2 = t2.clone(i.parser.draw.instance).show();
          s2 = r2.node.getBBox(), r2.remove();
        } else s2 = { x: t2.node.clientLeft, y: t2.node.clientTop, width: t2.node.clientWidth, height: t2.node.clientHeight };
      }
      i.Box.call(this, s2);
    }
  }, inherit: i.Box, parent: i.Element, construct: { bbox: function() {
    return new i.BBox(this);
  } } }), i.BBox.prototype.constructor = i.BBox, i.extend(i.Element, { tbox: function() {
    return console.warn("Use of TBox is deprecated and mapped to RBox. Use .rbox() instead."), this.rbox(this.doc());
  } }), i.RBox = i.invent({ create: function(t2) {
    i.Box.apply(this, [].slice.call(arguments)), t2 instanceof i.Element && i.Box.call(this, t2.node.getBoundingClientRect());
  }, inherit: i.Box, parent: i.Element, extend: { addOffset: function() {
    return this.x += t.pageXOffset, this.y += t.pageYOffset, this;
  } }, construct: { rbox: function(t2) {
    return t2 ? new i.RBox(this).transform(t2.screenCTM().inverse()) : new i.RBox(this).addOffset();
  } } }), i.RBox.prototype.constructor = i.RBox, i.Matrix = i.invent({ create: function(t2) {
    var e2, s2 = f([1, 0, 0, 1, 0, 0]);
    for (t2 = t2 instanceof i.Element ? t2.matrixify() : "string" == typeof t2 ? f(t2.split(i.regex.delimiter).map(parseFloat)) : 6 == arguments.length ? f([].slice.call(arguments)) : Array.isArray(t2) ? f(t2) : "object" === _typeof(t2) ? t2 : s2, e2 = v.length - 1; e2 >= 0; --e2) this[v[e2]] = null != t2[v[e2]] ? t2[v[e2]] : s2[v[e2]];
  }, extend: { extract: function() {
    var t2 = g(this, 0, 1), e2 = g(this, 1, 0), s2 = 180 / Math.PI * Math.atan2(t2.y, t2.x) - 90;
    return { x: this.e, y: this.f, transformedX: (this.e * Math.cos(s2 * Math.PI / 180) + this.f * Math.sin(s2 * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b), transformedY: (this.f * Math.cos(s2 * Math.PI / 180) + this.e * Math.sin(-s2 * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d), skewX: -s2, skewY: 180 / Math.PI * Math.atan2(e2.y, e2.x), scaleX: Math.sqrt(this.a * this.a + this.b * this.b), scaleY: Math.sqrt(this.c * this.c + this.d * this.d), rotation: s2, a: this.a, b: this.b, c: this.c, d: this.d, e: this.e, f: this.f, matrix: new i.Matrix(this) };
  }, clone: function() {
    return new i.Matrix(this);
  }, morph: function(t2) {
    return this.destination = new i.Matrix(t2), this;
  }, at: function(t2) {
    return this.destination ? new i.Matrix({ a: this.a + (this.destination.a - this.a) * t2, b: this.b + (this.destination.b - this.b) * t2, c: this.c + (this.destination.c - this.c) * t2, d: this.d + (this.destination.d - this.d) * t2, e: this.e + (this.destination.e - this.e) * t2, f: this.f + (this.destination.f - this.f) * t2 }) : this;
  }, multiply: function(t2) {
    return new i.Matrix(this.native().multiply((function(t3) {
      t3 instanceof i.Matrix || (t3 = new i.Matrix(t3));
      return t3;
    })(t2).native()));
  }, inverse: function() {
    return new i.Matrix(this.native().inverse());
  }, translate: function(t2, e2) {
    return new i.Matrix(this.native().translate(t2 || 0, e2 || 0));
  }, scale: function(t2, e2, s2, a2) {
    return 1 == arguments.length ? e2 = t2 : 3 == arguments.length && (a2 = s2, s2 = e2, e2 = t2), this.around(s2, a2, new i.Matrix(t2, 0, 0, e2, 0, 0));
  }, rotate: function(t2, e2, s2) {
    return t2 = i.utils.radians(t2), this.around(e2, s2, new i.Matrix(Math.cos(t2), Math.sin(t2), -Math.sin(t2), Math.cos(t2), 0, 0));
  }, flip: function(t2, e2) {
    return "x" == t2 ? this.scale(-1, 1, e2, 0) : "y" == t2 ? this.scale(1, -1, 0, e2) : this.scale(-1, -1, t2, null != e2 ? e2 : t2);
  }, skew: function(t2, e2, s2, a2) {
    return 1 == arguments.length ? e2 = t2 : 3 == arguments.length && (a2 = s2, s2 = e2, e2 = t2), t2 = i.utils.radians(t2), e2 = i.utils.radians(e2), this.around(s2, a2, new i.Matrix(1, Math.tan(e2), Math.tan(t2), 1, 0, 0));
  }, skewX: function(t2, e2, i2) {
    return this.skew(t2, 0, e2, i2);
  }, skewY: function(t2, e2, i2) {
    return this.skew(0, t2, e2, i2);
  }, around: function(t2, e2, s2) {
    return this.multiply(new i.Matrix(1, 0, 0, 1, t2 || 0, e2 || 0)).multiply(s2).multiply(new i.Matrix(1, 0, 0, 1, -t2 || 0, -e2 || 0));
  }, native: function() {
    for (var t2 = i.parser.native.createSVGMatrix(), e2 = v.length - 1; e2 >= 0; e2--) t2[v[e2]] = this[v[e2]];
    return t2;
  }, toString: function() {
    return "matrix(" + b(this.a) + "," + b(this.b) + "," + b(this.c) + "," + b(this.d) + "," + b(this.e) + "," + b(this.f) + ")";
  } }, parent: i.Element, construct: { ctm: function() {
    return new i.Matrix(this.node.getCTM());
  }, screenCTM: function() {
    if (this instanceof i.Nested) {
      var t2 = this.rect(1, 1), e2 = t2.node.getScreenCTM();
      return t2.remove(), new i.Matrix(e2);
    }
    return new i.Matrix(this.node.getScreenCTM());
  } } }), i.Point = i.invent({ create: function(t2, e2) {
    var i2;
    i2 = Array.isArray(t2) ? { x: t2[0], y: t2[1] } : "object" === _typeof(t2) ? { x: t2.x, y: t2.y } : null != t2 ? { x: t2, y: null != e2 ? e2 : t2 } : { x: 0, y: 0 }, this.x = i2.x, this.y = i2.y;
  }, extend: { clone: function() {
    return new i.Point(this);
  }, morph: function(t2, e2) {
    return this.destination = new i.Point(t2, e2), this;
  }, at: function(t2) {
    return this.destination ? new i.Point({ x: this.x + (this.destination.x - this.x) * t2, y: this.y + (this.destination.y - this.y) * t2 }) : this;
  }, native: function() {
    var t2 = i.parser.native.createSVGPoint();
    return t2.x = this.x, t2.y = this.y, t2;
  }, transform: function(t2) {
    return new i.Point(this.native().matrixTransform(t2.native()));
  } } }), i.extend(i.Element, { point: function(t2, e2) {
    return new i.Point(t2, e2).transform(this.screenCTM().inverse());
  } }), i.extend(i.Element, { attr: function(t2, e2, s2) {
    if (null == t2) {
      for (t2 = {}, s2 = (e2 = this.node.attributes).length - 1; s2 >= 0; s2--) t2[e2[s2].nodeName] = i.regex.isNumber.test(e2[s2].nodeValue) ? parseFloat(e2[s2].nodeValue) : e2[s2].nodeValue;
      return t2;
    }
    if ("object" === _typeof(t2)) for (e2 in t2) this.attr(e2, t2[e2]);
    else if (null === e2) this.node.removeAttribute(t2);
    else {
      if (null == e2) return null == (e2 = this.node.getAttribute(t2)) ? i.defaults.attrs[t2] : i.regex.isNumber.test(e2) ? parseFloat(e2) : e2;
      "stroke-width" == t2 ? this.attr("stroke", parseFloat(e2) > 0 ? this._stroke : null) : "stroke" == t2 && (this._stroke = e2), "fill" != t2 && "stroke" != t2 || (i.regex.isImage.test(e2) && (e2 = this.doc().defs().image(e2, 0, 0)), e2 instanceof i.Image && (e2 = this.doc().defs().pattern(0, 0, function() {
        this.add(e2);
      }))), "number" == typeof e2 ? e2 = new i.Number(e2) : i.Color.isColor(e2) ? e2 = new i.Color(e2) : Array.isArray(e2) && (e2 = new i.Array(e2)), "leading" == t2 ? this.leading && this.leading(e2) : "string" == typeof s2 ? this.node.setAttributeNS(s2, t2, e2.toString()) : this.node.setAttribute(t2, e2.toString()), !this.rebuild || "font-size" != t2 && "x" != t2 || this.rebuild(t2, e2);
    }
    return this;
  } }), i.extend(i.Element, { transform: function(t2, e2) {
    var s2, a2;
    if ("object" !== _typeof(t2)) return s2 = new i.Matrix(this).extract(), "string" == typeof t2 ? s2[t2] : s2;
    if (s2 = new i.Matrix(this), e2 = !!e2 || !!t2.relative, null != t2.a) s2 = e2 ? s2.multiply(new i.Matrix(t2)) : new i.Matrix(t2);
    else if (null != t2.rotation) p(t2, this), s2 = e2 ? s2.rotate(t2.rotation, t2.cx, t2.cy) : s2.rotate(t2.rotation - s2.extract().rotation, t2.cx, t2.cy);
    else if (null != t2.scale || null != t2.scaleX || null != t2.scaleY) {
      if (p(t2, this), t2.scaleX = null != t2.scale ? t2.scale : null != t2.scaleX ? t2.scaleX : 1, t2.scaleY = null != t2.scale ? t2.scale : null != t2.scaleY ? t2.scaleY : 1, !e2) {
        var r2 = s2.extract();
        t2.scaleX = 1 * t2.scaleX / r2.scaleX, t2.scaleY = 1 * t2.scaleY / r2.scaleY;
      }
      s2 = s2.scale(t2.scaleX, t2.scaleY, t2.cx, t2.cy);
    } else if (null != t2.skew || null != t2.skewX || null != t2.skewY) {
      if (p(t2, this), t2.skewX = null != t2.skew ? t2.skew : null != t2.skewX ? t2.skewX : 0, t2.skewY = null != t2.skew ? t2.skew : null != t2.skewY ? t2.skewY : 0, !e2) {
        r2 = s2.extract();
        s2 = s2.multiply(new i.Matrix().skew(r2.skewX, r2.skewY, t2.cx, t2.cy).inverse());
      }
      s2 = s2.skew(t2.skewX, t2.skewY, t2.cx, t2.cy);
    } else t2.flip ? ("x" == t2.flip || "y" == t2.flip ? t2.offset = null == t2.offset ? this.bbox()["c" + t2.flip] : t2.offset : null == t2.offset ? (a2 = this.bbox(), t2.flip = a2.cx, t2.offset = a2.cy) : t2.flip = t2.offset, s2 = new i.Matrix().flip(t2.flip, t2.offset)) : null == t2.x && null == t2.y || (e2 ? s2 = s2.translate(t2.x, t2.y) : (null != t2.x && (s2.e = t2.x), null != t2.y && (s2.f = t2.y)));
    return this.attr("transform", s2);
  } }), i.extend(i.FX, { transform: function(t2, e2) {
    var s2, a2, r2 = this.target();
    return "object" !== _typeof(t2) ? (s2 = new i.Matrix(r2).extract(), "string" == typeof t2 ? s2[t2] : s2) : (e2 = !!e2 || !!t2.relative, null != t2.a ? s2 = new i.Matrix(t2) : null != t2.rotation ? (p(t2, r2), s2 = new i.Rotate(t2.rotation, t2.cx, t2.cy)) : null != t2.scale || null != t2.scaleX || null != t2.scaleY ? (p(t2, r2), t2.scaleX = null != t2.scale ? t2.scale : null != t2.scaleX ? t2.scaleX : 1, t2.scaleY = null != t2.scale ? t2.scale : null != t2.scaleY ? t2.scaleY : 1, s2 = new i.Scale(t2.scaleX, t2.scaleY, t2.cx, t2.cy)) : null != t2.skewX || null != t2.skewY ? (p(t2, r2), t2.skewX = null != t2.skewX ? t2.skewX : 0, t2.skewY = null != t2.skewY ? t2.skewY : 0, s2 = new i.Skew(t2.skewX, t2.skewY, t2.cx, t2.cy)) : t2.flip ? ("x" == t2.flip || "y" == t2.flip ? t2.offset = null == t2.offset ? r2.bbox()["c" + t2.flip] : t2.offset : null == t2.offset ? (a2 = r2.bbox(), t2.flip = a2.cx, t2.offset = a2.cy) : t2.flip = t2.offset, s2 = new i.Matrix().flip(t2.flip, t2.offset)) : null == t2.x && null == t2.y || (s2 = new i.Translate(t2.x, t2.y)), s2 ? (s2.relative = e2, this.last().transforms.push(s2), this._callStart()) : this);
  } }), i.extend(i.Element, { untransform: function() {
    return this.attr("transform", null);
  }, matrixify: function() {
    return (this.attr("transform") || "").split(i.regex.transforms).slice(0, -1).map(function(t2) {
      var e2 = t2.trim().split("(");
      return [e2[0], e2[1].split(i.regex.delimiter).map(function(t3) {
        return parseFloat(t3);
      })];
    }).reduce(function(t2, e2) {
      return "matrix" == e2[0] ? t2.multiply(f(e2[1])) : t2[e2[0]].apply(t2, e2[1]);
    }, new i.Matrix());
  }, toParent: function(t2) {
    if (this == t2) return this;
    var e2 = this.screenCTM(), i2 = t2.screenCTM().inverse();
    return this.addTo(t2).untransform().transform(i2.multiply(e2)), this;
  }, toDoc: function() {
    return this.toParent(this.doc());
  } }), i.Transformation = i.invent({ create: function(t2, e2) {
    if (arguments.length > 1 && "boolean" != typeof e2) return this.constructor.call(this, [].slice.call(arguments));
    if (Array.isArray(t2)) for (var i2 = 0, s2 = this.arguments.length; i2 < s2; ++i2) this[this.arguments[i2]] = t2[i2];
    else if ("object" === _typeof(t2)) for (i2 = 0, s2 = this.arguments.length; i2 < s2; ++i2) this[this.arguments[i2]] = t2[this.arguments[i2]];
    this.inversed = false, true === e2 && (this.inversed = true);
  }, extend: { arguments: [], method: "", at: function(t2) {
    for (var e2 = [], s2 = 0, a2 = this.arguments.length; s2 < a2; ++s2) e2.push(this[this.arguments[s2]]);
    var r2 = this._undo || new i.Matrix();
    return r2 = new i.Matrix().morph(i.Matrix.prototype[this.method].apply(r2, e2)).at(t2), this.inversed ? r2.inverse() : r2;
  }, undo: function(t2) {
    for (var e2 = 0, s2 = this.arguments.length; e2 < s2; ++e2) t2[this.arguments[e2]] = void 0 === this[this.arguments[e2]] ? 0 : t2[this.arguments[e2]];
    return t2.cx = this.cx, t2.cy = this.cy, this._undo = new i[c(this.method)](t2, true).at(1), this;
  } } }), i.Translate = i.invent({ parent: i.Matrix, inherit: i.Transformation, create: function(t2, e2) {
    this.constructor.apply(this, [].slice.call(arguments));
  }, extend: { arguments: ["transformedX", "transformedY"], method: "translate" } }), i.Rotate = i.invent({ parent: i.Matrix, inherit: i.Transformation, create: function(t2, e2) {
    this.constructor.apply(this, [].slice.call(arguments));
  }, extend: { arguments: ["rotation", "cx", "cy"], method: "rotate", at: function(t2) {
    var e2 = new i.Matrix().rotate(new i.Number().morph(this.rotation - (this._undo ? this._undo.rotation : 0)).at(t2), this.cx, this.cy);
    return this.inversed ? e2.inverse() : e2;
  }, undo: function(t2) {
    return this._undo = t2, this;
  } } }), i.Scale = i.invent({ parent: i.Matrix, inherit: i.Transformation, create: function(t2, e2) {
    this.constructor.apply(this, [].slice.call(arguments));
  }, extend: { arguments: ["scaleX", "scaleY", "cx", "cy"], method: "scale" } }), i.Skew = i.invent({ parent: i.Matrix, inherit: i.Transformation, create: function(t2, e2) {
    this.constructor.apply(this, [].slice.call(arguments));
  }, extend: { arguments: ["skewX", "skewY", "cx", "cy"], method: "skew" } }), i.extend(i.Element, { style: function(t2, e2) {
    if (0 == arguments.length) return this.node.style.cssText || "";
    if (arguments.length < 2) if ("object" === _typeof(t2)) for (e2 in t2) this.style(e2, t2[e2]);
    else {
      if (!i.regex.isCss.test(t2)) return this.node.style[h(t2)];
      for (t2 = t2.split(/\s*;\s*/).filter(function(t3) {
        return !!t3;
      }).map(function(t3) {
        return t3.split(/\s*:\s*/);
      }); e2 = t2.pop(); ) this.style(e2[0], e2[1]);
    }
    else this.node.style[h(t2)] = null === e2 || i.regex.isBlank.test(e2) ? "" : e2;
    return this;
  } }), i.Parent = i.invent({ create: function(t2) {
    this.constructor.call(this, t2);
  }, inherit: i.Element, extend: { children: function() {
    return i.utils.map(i.utils.filterSVGElements(this.node.childNodes), function(t2) {
      return i.adopt(t2);
    });
  }, add: function(t2, e2) {
    return null == e2 ? this.node.appendChild(t2.node) : t2.node != this.node.childNodes[e2] && this.node.insertBefore(t2.node, this.node.childNodes[e2]), this;
  }, put: function(t2, e2) {
    return this.add(t2, e2), t2;
  }, has: function(t2) {
    return this.index(t2) >= 0;
  }, index: function(t2) {
    return [].slice.call(this.node.childNodes).indexOf(t2.node);
  }, get: function(t2) {
    return i.adopt(this.node.childNodes[t2]);
  }, first: function() {
    return this.get(0);
  }, last: function() {
    return this.get(this.node.childNodes.length - 1);
  }, each: function(t2, e2) {
    var s2, a2, r2 = this.children();
    for (s2 = 0, a2 = r2.length; s2 < a2; s2++) r2[s2] instanceof i.Element && t2.apply(r2[s2], [s2, r2]), e2 && r2[s2] instanceof i.Container && r2[s2].each(t2, e2);
    return this;
  }, removeElement: function(t2) {
    return this.node.removeChild(t2.node), this;
  }, clear: function() {
    for (; this.node.hasChildNodes(); ) this.node.removeChild(this.node.lastChild);
    return delete this._defs, this;
  }, defs: function() {
    return this.doc().defs();
  } } }), i.extend(i.Parent, { ungroup: function(t2, e2) {
    return 0 === e2 || this instanceof i.Defs || this.node == i.parser.draw ? this : (t2 = t2 || (this instanceof i.Doc ? this : this.parent(i.Parent)), e2 = e2 || 1 / 0, this.each(function() {
      return this instanceof i.Defs ? this : this instanceof i.Parent ? this.ungroup(t2, e2 - 1) : this.toParent(t2);
    }), this.node.firstChild || this.remove(), this);
  }, flatten: function(t2, e2) {
    return this.ungroup(t2, e2);
  } }), i.Container = i.invent({ create: function(t2) {
    this.constructor.call(this, t2);
  }, inherit: i.Parent }), i.ViewBox = i.invent({ create: function(t2) {
    var e2, s2, a2, r2, n2, o2, l2, h2 = 1, c2 = 1, d2 = /[+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?/gi;
    if (t2 instanceof i.Element) {
      for (o2 = t2, l2 = t2, n2 = (t2.attr("viewBox") || "").match(d2), t2.bbox, a2 = new i.Number(t2.width()), r2 = new i.Number(t2.height()); "%" == a2.unit; ) h2 *= a2.value, a2 = new i.Number(o2 instanceof i.Doc ? o2.parent().offsetWidth : o2.parent().width()), o2 = o2.parent();
      for (; "%" == r2.unit; ) c2 *= r2.value, r2 = new i.Number(l2 instanceof i.Doc ? l2.parent().offsetHeight : l2.parent().height()), l2 = l2.parent();
      this.x = 0, this.y = 0, this.width = a2 * h2, this.height = r2 * c2, this.zoom = 1, n2 && (e2 = parseFloat(n2[0]), s2 = parseFloat(n2[1]), a2 = parseFloat(n2[2]), r2 = parseFloat(n2[3]), this.zoom = this.width / this.height > a2 / r2 ? this.height / r2 : this.width / a2, this.x = e2, this.y = s2, this.width = a2, this.height = r2);
    } else t2 = "string" == typeof t2 ? t2.match(d2).map(function(t3) {
      return parseFloat(t3);
    }) : Array.isArray(t2) ? t2 : "object" === _typeof(t2) ? [t2.x, t2.y, t2.width, t2.height] : 4 == arguments.length ? [].slice.call(arguments) : [0, 0, 0, 0], this.x = t2[0], this.y = t2[1], this.width = t2[2], this.height = t2[3];
  }, extend: { toString: function() {
    return this.x + " " + this.y + " " + this.width + " " + this.height;
  }, morph: function(t2, e2, s2, a2) {
    return this.destination = new i.ViewBox(t2, e2, s2, a2), this;
  }, at: function(t2) {
    return this.destination ? new i.ViewBox([this.x + (this.destination.x - this.x) * t2, this.y + (this.destination.y - this.y) * t2, this.width + (this.destination.width - this.width) * t2, this.height + (this.destination.height - this.height) * t2]) : this;
  } }, parent: i.Container, construct: { viewbox: function(t2, e2, s2, a2) {
    return 0 == arguments.length ? new i.ViewBox(this) : this.attr("viewBox", new i.ViewBox(t2, e2, s2, a2));
  } } }), ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel"].forEach(function(t2) {
    i.Element.prototype[t2] = function(e2) {
      return i.on(this.node, t2, e2), this;
    };
  }), i.listeners = [], i.handlerMap = [], i.listenerId = 0, i.on = function(t2, e2, s2, a2, r2) {
    var n2 = s2.bind(a2 || t2.instance || t2), o2 = (i.handlerMap.indexOf(t2) + 1 || i.handlerMap.push(t2)) - 1, l2 = e2.split(".")[0], h2 = e2.split(".")[1] || "*";
    i.listeners[o2] = i.listeners[o2] || {}, i.listeners[o2][l2] = i.listeners[o2][l2] || {}, i.listeners[o2][l2][h2] = i.listeners[o2][l2][h2] || {}, s2._svgjsListenerId || (s2._svgjsListenerId = ++i.listenerId), i.listeners[o2][l2][h2][s2._svgjsListenerId] = n2, t2.addEventListener(l2, n2, r2 || false);
  }, i.off = function(t2, e2, s2) {
    var a2 = i.handlerMap.indexOf(t2), r2 = e2 && e2.split(".")[0], n2 = e2 && e2.split(".")[1], o2 = "";
    if (-1 != a2) if (s2) {
      if ("function" == typeof s2 && (s2 = s2._svgjsListenerId), !s2) return;
      i.listeners[a2][r2] && i.listeners[a2][r2][n2 || "*"] && (t2.removeEventListener(r2, i.listeners[a2][r2][n2 || "*"][s2], false), delete i.listeners[a2][r2][n2 || "*"][s2]);
    } else if (n2 && r2) {
      if (i.listeners[a2][r2] && i.listeners[a2][r2][n2]) {
        for (s2 in i.listeners[a2][r2][n2]) i.off(t2, [r2, n2].join("."), s2);
        delete i.listeners[a2][r2][n2];
      }
    } else if (n2) for (e2 in i.listeners[a2]) for (o2 in i.listeners[a2][e2]) n2 === o2 && i.off(t2, [e2, n2].join("."));
    else if (r2) {
      if (i.listeners[a2][r2]) {
        for (o2 in i.listeners[a2][r2]) i.off(t2, [r2, o2].join("."));
        delete i.listeners[a2][r2];
      }
    } else {
      for (e2 in i.listeners[a2]) i.off(t2, e2);
      delete i.listeners[a2], delete i.handlerMap[a2];
    }
  }, i.extend(i.Element, { on: function(t2, e2, s2, a2) {
    return i.on(this.node, t2, e2, s2, a2), this;
  }, off: function(t2, e2) {
    return i.off(this.node, t2, e2), this;
  }, fire: function(e2, s2) {
    return e2 instanceof t.Event ? this.node.dispatchEvent(e2) : this.node.dispatchEvent(e2 = new i.CustomEvent(e2, { detail: s2, cancelable: true })), this._event = e2, this;
  }, event: function() {
    return this._event;
  } }), i.Defs = i.invent({ create: "defs", inherit: i.Container }), i.G = i.invent({ create: "g", inherit: i.Container, extend: { x: function(t2) {
    return null == t2 ? this.transform("x") : this.transform({ x: t2 - this.x() }, true);
  }, y: function(t2) {
    return null == t2 ? this.transform("y") : this.transform({ y: t2 - this.y() }, true);
  }, cx: function(t2) {
    return null == t2 ? this.gbox().cx : this.x(t2 - this.gbox().width / 2);
  }, cy: function(t2) {
    return null == t2 ? this.gbox().cy : this.y(t2 - this.gbox().height / 2);
  }, gbox: function() {
    var t2 = this.bbox(), e2 = this.transform();
    return t2.x += e2.x, t2.x2 += e2.x, t2.cx += e2.x, t2.y += e2.y, t2.y2 += e2.y, t2.cy += e2.y, t2;
  } }, construct: { group: function() {
    return this.put(new i.G());
  } } }), i.Doc = i.invent({ create: function(t2) {
    t2 && ("svg" == (t2 = "string" == typeof t2 ? e.getElementById(t2) : t2).nodeName ? this.constructor.call(this, t2) : (this.constructor.call(this, i.create("svg")), t2.appendChild(this.node), this.size("100%", "100%")), this.namespace().defs());
  }, inherit: i.Container, extend: { namespace: function() {
    return this.attr({ xmlns: i.ns, version: "1.1" }).attr("xmlns:xlink", i.xlink, i.xmlns).attr("xmlns:svgjs", i.svgjs, i.xmlns);
  }, defs: function() {
    var t2;
    this._defs || ((t2 = this.node.getElementsByTagName("defs")[0]) ? this._defs = i.adopt(t2) : this._defs = new i.Defs(), this.node.appendChild(this._defs.node));
    return this._defs;
  }, parent: function() {
    return this.node.parentNode && "#document" != this.node.parentNode.nodeName ? this.node.parentNode : null;
  }, spof: function() {
    var t2 = this.node.getScreenCTM();
    return t2 && this.style("left", -t2.e % 1 + "px").style("top", -t2.f % 1 + "px"), this;
  }, remove: function() {
    return this.parent() && this.parent().removeChild(this.node), this;
  }, clear: function() {
    for (; this.node.hasChildNodes(); ) this.node.removeChild(this.node.lastChild);
    return delete this._defs, i.parser.draw && !i.parser.draw.parentNode && this.node.appendChild(i.parser.draw), this;
  }, clone: function(t2) {
    this.writeDataToDom();
    var e2 = this.node, i2 = x(e2.cloneNode(true));
    return t2 ? (t2.node || t2).appendChild(i2.node) : e2.parentNode.insertBefore(i2.node, e2.nextSibling), i2;
  } } }), i.extend(i.Element, { siblings: function() {
    return this.parent().children();
  }, position: function() {
    return this.parent().index(this);
  }, next: function() {
    return this.siblings()[this.position() + 1];
  }, previous: function() {
    return this.siblings()[this.position() - 1];
  }, forward: function() {
    var t2 = this.position() + 1, e2 = this.parent();
    return e2.removeElement(this).add(this, t2), e2 instanceof i.Doc && e2.node.appendChild(e2.defs().node), this;
  }, backward: function() {
    var t2 = this.position();
    return t2 > 0 && this.parent().removeElement(this).add(this, t2 - 1), this;
  }, front: function() {
    var t2 = this.parent();
    return t2.node.appendChild(this.node), t2 instanceof i.Doc && t2.node.appendChild(t2.defs().node), this;
  }, back: function() {
    return this.position() > 0 && this.parent().removeElement(this).add(this, 0), this;
  }, before: function(t2) {
    t2.remove();
    var e2 = this.position();
    return this.parent().add(t2, e2), this;
  }, after: function(t2) {
    t2.remove();
    var e2 = this.position();
    return this.parent().add(t2, e2 + 1), this;
  } }), i.Mask = i.invent({ create: function() {
    this.constructor.call(this, i.create("mask")), this.targets = [];
  }, inherit: i.Container, extend: { remove: function() {
    for (var t2 = this.targets.length - 1; t2 >= 0; t2--) this.targets[t2] && this.targets[t2].unmask();
    return this.targets = [], i.Element.prototype.remove.call(this), this;
  } }, construct: { mask: function() {
    return this.defs().put(new i.Mask());
  } } }), i.extend(i.Element, { maskWith: function(t2) {
    return this.masker = t2 instanceof i.Mask ? t2 : this.parent().mask().add(t2), this.masker.targets.push(this), this.attr("mask", 'url("#' + this.masker.attr("id") + '")');
  }, unmask: function() {
    return delete this.masker, this.attr("mask", null);
  } }), i.ClipPath = i.invent({ create: function() {
    this.constructor.call(this, i.create("clipPath")), this.targets = [];
  }, inherit: i.Container, extend: { remove: function() {
    for (var t2 = this.targets.length - 1; t2 >= 0; t2--) this.targets[t2] && this.targets[t2].unclip();
    return this.targets = [], this.parent().removeElement(this), this;
  } }, construct: { clip: function() {
    return this.defs().put(new i.ClipPath());
  } } }), i.extend(i.Element, { clipWith: function(t2) {
    return this.clipper = t2 instanceof i.ClipPath ? t2 : this.parent().clip().add(t2), this.clipper.targets.push(this), this.attr("clip-path", 'url("#' + this.clipper.attr("id") + '")');
  }, unclip: function() {
    return delete this.clipper, this.attr("clip-path", null);
  } }), i.Gradient = i.invent({ create: function(t2) {
    this.constructor.call(this, i.create(t2 + "Gradient")), this.type = t2;
  }, inherit: i.Container, extend: { at: function(t2, e2, s2) {
    return this.put(new i.Stop()).update(t2, e2, s2);
  }, update: function(t2) {
    return this.clear(), "function" == typeof t2 && t2.call(this, this), this;
  }, fill: function() {
    return "url(#" + this.id() + ")";
  }, toString: function() {
    return this.fill();
  }, attr: function(t2, e2, s2) {
    return "transform" == t2 && (t2 = "gradientTransform"), i.Container.prototype.attr.call(this, t2, e2, s2);
  } }, construct: { gradient: function(t2, e2) {
    return this.defs().gradient(t2, e2);
  } } }), i.extend(i.Gradient, i.FX, { from: function(t2, e2) {
    return "radial" == (this._target || this).type ? this.attr({ fx: new i.Number(t2), fy: new i.Number(e2) }) : this.attr({ x1: new i.Number(t2), y1: new i.Number(e2) });
  }, to: function(t2, e2) {
    return "radial" == (this._target || this).type ? this.attr({ cx: new i.Number(t2), cy: new i.Number(e2) }) : this.attr({ x2: new i.Number(t2), y2: new i.Number(e2) });
  } }), i.extend(i.Defs, { gradient: function(t2, e2) {
    return this.put(new i.Gradient(t2)).update(e2);
  } }), i.Stop = i.invent({ create: "stop", inherit: i.Element, extend: { update: function(t2) {
    return ("number" == typeof t2 || t2 instanceof i.Number) && (t2 = { offset: arguments[0], color: arguments[1], opacity: arguments[2] }), null != t2.opacity && this.attr("stop-opacity", t2.opacity), null != t2.color && this.attr("stop-color", t2.color), null != t2.offset && this.attr("offset", new i.Number(t2.offset)), this;
  } } }), i.Pattern = i.invent({ create: "pattern", inherit: i.Container, extend: { fill: function() {
    return "url(#" + this.id() + ")";
  }, update: function(t2) {
    return this.clear(), "function" == typeof t2 && t2.call(this, this), this;
  }, toString: function() {
    return this.fill();
  }, attr: function(t2, e2, s2) {
    return "transform" == t2 && (t2 = "patternTransform"), i.Container.prototype.attr.call(this, t2, e2, s2);
  } }, construct: { pattern: function(t2, e2, i2) {
    return this.defs().pattern(t2, e2, i2);
  } } }), i.extend(i.Defs, { pattern: function(t2, e2, s2) {
    return this.put(new i.Pattern()).update(s2).attr({ x: 0, y: 0, width: t2, height: e2, patternUnits: "userSpaceOnUse" });
  } }), i.Shape = i.invent({ create: function(t2) {
    this.constructor.call(this, t2);
  }, inherit: i.Element }), i.Bare = i.invent({ create: function(t2, e2) {
    if (this.constructor.call(this, i.create(t2)), e2) for (var s2 in e2.prototype) "function" == typeof e2.prototype[s2] && (this[s2] = e2.prototype[s2]);
  }, inherit: i.Element, extend: { words: function(t2) {
    for (; this.node.hasChildNodes(); ) this.node.removeChild(this.node.lastChild);
    return this.node.appendChild(e.createTextNode(t2)), this;
  } } }), i.extend(i.Parent, { element: function(t2, e2) {
    return this.put(new i.Bare(t2, e2));
  } }), i.Symbol = i.invent({ create: "symbol", inherit: i.Container, construct: { symbol: function() {
    return this.put(new i.Symbol());
  } } }), i.Use = i.invent({ create: "use", inherit: i.Shape, extend: { element: function(t2, e2) {
    return this.attr("href", (e2 || "") + "#" + t2, i.xlink);
  } }, construct: { use: function(t2, e2) {
    return this.put(new i.Use()).element(t2, e2);
  } } }), i.Rect = i.invent({ create: "rect", inherit: i.Shape, construct: { rect: function(t2, e2) {
    return this.put(new i.Rect()).size(t2, e2);
  } } }), i.Circle = i.invent({ create: "circle", inherit: i.Shape, construct: { circle: function(t2) {
    return this.put(new i.Circle()).rx(new i.Number(t2).divide(2)).move(0, 0);
  } } }), i.extend(i.Circle, i.FX, { rx: function(t2) {
    return this.attr("r", t2);
  }, ry: function(t2) {
    return this.rx(t2);
  } }), i.Ellipse = i.invent({ create: "ellipse", inherit: i.Shape, construct: { ellipse: function(t2, e2) {
    return this.put(new i.Ellipse()).size(t2, e2).move(0, 0);
  } } }), i.extend(i.Ellipse, i.Rect, i.FX, { rx: function(t2) {
    return this.attr("rx", t2);
  }, ry: function(t2) {
    return this.attr("ry", t2);
  } }), i.extend(i.Circle, i.Ellipse, { x: function(t2) {
    return null == t2 ? this.cx() - this.rx() : this.cx(t2 + this.rx());
  }, y: function(t2) {
    return null == t2 ? this.cy() - this.ry() : this.cy(t2 + this.ry());
  }, cx: function(t2) {
    return null == t2 ? this.attr("cx") : this.attr("cx", t2);
  }, cy: function(t2) {
    return null == t2 ? this.attr("cy") : this.attr("cy", t2);
  }, width: function(t2) {
    return null == t2 ? 2 * this.rx() : this.rx(new i.Number(t2).divide(2));
  }, height: function(t2) {
    return null == t2 ? 2 * this.ry() : this.ry(new i.Number(t2).divide(2));
  }, size: function(t2, e2) {
    var s2 = u(this, t2, e2);
    return this.rx(new i.Number(s2.width).divide(2)).ry(new i.Number(s2.height).divide(2));
  } }), i.Line = i.invent({ create: "line", inherit: i.Shape, extend: { array: function() {
    return new i.PointArray([[this.attr("x1"), this.attr("y1")], [this.attr("x2"), this.attr("y2")]]);
  }, plot: function(t2, e2, s2, a2) {
    return null == t2 ? this.array() : (t2 = void 0 !== e2 ? { x1: t2, y1: e2, x2: s2, y2: a2 } : new i.PointArray(t2).toLine(), this.attr(t2));
  }, move: function(t2, e2) {
    return this.attr(this.array().move(t2, e2).toLine());
  }, size: function(t2, e2) {
    var i2 = u(this, t2, e2);
    return this.attr(this.array().size(i2.width, i2.height).toLine());
  } }, construct: { line: function(t2, e2, s2, a2) {
    return i.Line.prototype.plot.apply(this.put(new i.Line()), null != t2 ? [t2, e2, s2, a2] : [0, 0, 0, 0]);
  } } }), i.Polyline = i.invent({ create: "polyline", inherit: i.Shape, construct: { polyline: function(t2) {
    return this.put(new i.Polyline()).plot(t2 || new i.PointArray());
  } } }), i.Polygon = i.invent({ create: "polygon", inherit: i.Shape, construct: { polygon: function(t2) {
    return this.put(new i.Polygon()).plot(t2 || new i.PointArray());
  } } }), i.extend(i.Polyline, i.Polygon, { array: function() {
    return this._array || (this._array = new i.PointArray(this.attr("points")));
  }, plot: function(t2) {
    return null == t2 ? this.array() : this.clear().attr("points", "string" == typeof t2 ? t2 : this._array = new i.PointArray(t2));
  }, clear: function() {
    return delete this._array, this;
  }, move: function(t2, e2) {
    return this.attr("points", this.array().move(t2, e2));
  }, size: function(t2, e2) {
    var i2 = u(this, t2, e2);
    return this.attr("points", this.array().size(i2.width, i2.height));
  } }), i.extend(i.Line, i.Polyline, i.Polygon, { morphArray: i.PointArray, x: function(t2) {
    return null == t2 ? this.bbox().x : this.move(t2, this.bbox().y);
  }, y: function(t2) {
    return null == t2 ? this.bbox().y : this.move(this.bbox().x, t2);
  }, width: function(t2) {
    var e2 = this.bbox();
    return null == t2 ? e2.width : this.size(t2, e2.height);
  }, height: function(t2) {
    var e2 = this.bbox();
    return null == t2 ? e2.height : this.size(e2.width, t2);
  } }), i.Path = i.invent({ create: "path", inherit: i.Shape, extend: { morphArray: i.PathArray, array: function() {
    return this._array || (this._array = new i.PathArray(this.attr("d")));
  }, plot: function(t2) {
    return null == t2 ? this.array() : this.clear().attr("d", "string" == typeof t2 ? t2 : this._array = new i.PathArray(t2));
  }, clear: function() {
    return delete this._array, this;
  }, move: function(t2, e2) {
    return this.attr("d", this.array().move(t2, e2));
  }, x: function(t2) {
    return null == t2 ? this.bbox().x : this.move(t2, this.bbox().y);
  }, y: function(t2) {
    return null == t2 ? this.bbox().y : this.move(this.bbox().x, t2);
  }, size: function(t2, e2) {
    var i2 = u(this, t2, e2);
    return this.attr("d", this.array().size(i2.width, i2.height));
  }, width: function(t2) {
    return null == t2 ? this.bbox().width : this.size(t2, this.bbox().height);
  }, height: function(t2) {
    return null == t2 ? this.bbox().height : this.size(this.bbox().width, t2);
  } }, construct: { path: function(t2) {
    return this.put(new i.Path()).plot(t2 || new i.PathArray());
  } } }), i.Image = i.invent({ create: "image", inherit: i.Shape, extend: { load: function(e2) {
    if (!e2) return this;
    var s2 = this, a2 = new t.Image();
    return i.on(a2, "load", function() {
      i.off(a2);
      var t2 = s2.parent(i.Pattern);
      null !== t2 && (0 == s2.width() && 0 == s2.height() && s2.size(a2.width, a2.height), t2 && 0 == t2.width() && 0 == t2.height() && t2.size(s2.width(), s2.height()), "function" == typeof s2._loaded && s2._loaded.call(s2, { width: a2.width, height: a2.height, ratio: a2.width / a2.height, url: e2 }));
    }), i.on(a2, "error", function(t2) {
      i.off(a2), "function" == typeof s2._error && s2._error.call(s2, t2);
    }), this.attr("href", a2.src = this.src = e2, i.xlink);
  }, loaded: function(t2) {
    return this._loaded = t2, this;
  }, error: function(t2) {
    return this._error = t2, this;
  } }, construct: { image: function(t2, e2, s2) {
    return this.put(new i.Image()).load(t2).size(e2 || 0, s2 || e2 || 0);
  } } }), i.Text = i.invent({ create: function() {
    this.constructor.call(this, i.create("text")), this.dom.leading = new i.Number(1.3), this._rebuild = true, this._build = false, this.attr("font-family", i.defaults.attrs["font-family"]);
  }, inherit: i.Shape, extend: { x: function(t2) {
    return null == t2 ? this.attr("x") : this.attr("x", t2);
  }, y: function(t2) {
    var e2 = this.attr("y"), i2 = "number" == typeof e2 ? e2 - this.bbox().y : 0;
    return null == t2 ? "number" == typeof e2 ? e2 - i2 : e2 : this.attr("y", "number" == typeof t2.valueOf() ? t2 + i2 : t2);
  }, cx: function(t2) {
    return null == t2 ? this.bbox().cx : this.x(t2 - this.bbox().width / 2);
  }, cy: function(t2) {
    return null == t2 ? this.bbox().cy : this.y(t2 - this.bbox().height / 2);
  }, text: function(t2) {
    if (void 0 === t2) {
      t2 = "";
      for (var e2 = this.node.childNodes, s2 = 0, a2 = e2.length; s2 < a2; ++s2) 0 != s2 && 3 != e2[s2].nodeType && 1 == i.adopt(e2[s2]).dom.newLined && (t2 += "\n"), t2 += e2[s2].textContent;
      return t2;
    }
    if (this.clear().build(true), "function" == typeof t2) t2.call(this, this);
    else {
      s2 = 0;
      for (var r2 = (t2 = t2.split("\n")).length; s2 < r2; s2++) this.tspan(t2[s2]).newLine();
    }
    return this.build(false).rebuild();
  }, size: function(t2) {
    return this.attr("font-size", t2).rebuild();
  }, leading: function(t2) {
    return null == t2 ? this.dom.leading : (this.dom.leading = new i.Number(t2), this.rebuild());
  }, lines: function() {
    var t2 = (this.textPath && this.textPath() || this).node, e2 = i.utils.map(i.utils.filterSVGElements(t2.childNodes), function(t3) {
      return i.adopt(t3);
    });
    return new i.Set(e2);
  }, rebuild: function(t2) {
    if ("boolean" == typeof t2 && (this._rebuild = t2), this._rebuild) {
      var e2 = this, s2 = 0, a2 = this.dom.leading * new i.Number(this.attr("font-size"));
      this.lines().each(function() {
        this.dom.newLined && (e2.textPath() || this.attr("x", e2.attr("x")), "\n" == this.text() ? s2 += a2 : (this.attr("dy", a2 + s2), s2 = 0));
      }), this.fire("rebuild");
    }
    return this;
  }, build: function(t2) {
    return this._build = !!t2, this;
  }, setData: function(t2) {
    return this.dom = t2, this.dom.leading = new i.Number(t2.leading || 1.3), this;
  } }, construct: { text: function(t2) {
    return this.put(new i.Text()).text(t2);
  }, plain: function(t2) {
    return this.put(new i.Text()).plain(t2);
  } } }), i.Tspan = i.invent({ create: "tspan", inherit: i.Shape, extend: { text: function(t2) {
    return null == t2 ? this.node.textContent + (this.dom.newLined ? "\n" : "") : ("function" == typeof t2 ? t2.call(this, this) : this.plain(t2), this);
  }, dx: function(t2) {
    return this.attr("dx", t2);
  }, dy: function(t2) {
    return this.attr("dy", t2);
  }, newLine: function() {
    var t2 = this.parent(i.Text);
    return this.dom.newLined = true, this.dy(t2.dom.leading * t2.attr("font-size")).attr("x", t2.x());
  } } }), i.extend(i.Text, i.Tspan, { plain: function(t2) {
    return false === this._build && this.clear(), this.node.appendChild(e.createTextNode(t2)), this;
  }, tspan: function(t2) {
    var e2 = (this.textPath && this.textPath() || this).node, s2 = new i.Tspan();
    return false === this._build && this.clear(), e2.appendChild(s2.node), s2.text(t2);
  }, clear: function() {
    for (var t2 = (this.textPath && this.textPath() || this).node; t2.hasChildNodes(); ) t2.removeChild(t2.lastChild);
    return this;
  }, length: function() {
    return this.node.getComputedTextLength();
  } }), i.TextPath = i.invent({ create: "textPath", inherit: i.Parent, parent: i.Text, construct: { morphArray: i.PathArray, path: function(t2) {
    for (var e2 = new i.TextPath(), s2 = this.doc().defs().path(t2); this.node.hasChildNodes(); ) e2.node.appendChild(this.node.firstChild);
    return this.node.appendChild(e2.node), e2.attr("href", "#" + s2, i.xlink), this;
  }, array: function() {
    var t2 = this.track();
    return t2 ? t2.array() : null;
  }, plot: function(t2) {
    var e2 = this.track(), i2 = null;
    return e2 && (i2 = e2.plot(t2)), null == t2 ? i2 : this;
  }, track: function() {
    var t2 = this.textPath();
    if (t2) return t2.reference("href");
  }, textPath: function() {
    if (this.node.firstChild && "textPath" == this.node.firstChild.nodeName) return i.adopt(this.node.firstChild);
  } } }), i.Nested = i.invent({ create: function() {
    this.constructor.call(this, i.create("svg")), this.style("overflow", "visible");
  }, inherit: i.Container, construct: { nested: function() {
    return this.put(new i.Nested());
  } } }), i.A = i.invent({ create: "a", inherit: i.Container, extend: { to: function(t2) {
    return this.attr("href", t2, i.xlink);
  }, show: function(t2) {
    return this.attr("show", t2, i.xlink);
  }, target: function(t2) {
    return this.attr("target", t2);
  } }, construct: { link: function(t2) {
    return this.put(new i.A()).to(t2);
  } } }), i.extend(i.Element, { linkTo: function(t2) {
    var e2 = new i.A();
    return "function" == typeof t2 ? t2.call(e2, e2) : e2.to(t2), this.parent().put(e2).put(this);
  } }), i.Marker = i.invent({ create: "marker", inherit: i.Container, extend: { width: function(t2) {
    return this.attr("markerWidth", t2);
  }, height: function(t2) {
    return this.attr("markerHeight", t2);
  }, ref: function(t2, e2) {
    return this.attr("refX", t2).attr("refY", e2);
  }, update: function(t2) {
    return this.clear(), "function" == typeof t2 && t2.call(this, this), this;
  }, toString: function() {
    return "url(#" + this.id() + ")";
  } }, construct: { marker: function(t2, e2, i2) {
    return this.defs().marker(t2, e2, i2);
  } } }), i.extend(i.Defs, { marker: function(t2, e2, s2) {
    return this.put(new i.Marker()).size(t2, e2).ref(t2 / 2, e2 / 2).viewbox(0, 0, t2, e2).attr("orient", "auto").update(s2);
  } }), i.extend(i.Line, i.Polyline, i.Polygon, i.Path, { marker: function(t2, e2, s2, a2) {
    var r2 = ["marker"];
    return "all" != t2 && r2.push(t2), r2 = r2.join("-"), t2 = arguments[1] instanceof i.Marker ? arguments[1] : this.doc().marker(e2, s2, a2), this.attr(r2, t2);
  } });
  var o = { stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"], fill: ["color", "opacity", "rule"], prefix: function(t2, e2) {
    return "color" == e2 ? t2 : t2 + "-" + e2;
  } };
  function l(t2, e2, s2, a2) {
    return s2 + a2.replace(i.regex.dots, " .");
  }
  function h(t2) {
    return t2.toLowerCase().replace(/-(.)/g, function(t3, e2) {
      return e2.toUpperCase();
    });
  }
  function c(t2) {
    return t2.charAt(0).toUpperCase() + t2.slice(1);
  }
  function d(t2) {
    var e2 = t2.toString(16);
    return 1 == e2.length ? "0" + e2 : e2;
  }
  function u(t2, e2, i2) {
    if (null == e2 || null == i2) {
      var s2 = t2.bbox();
      null == e2 ? e2 = s2.width / s2.height * i2 : null == i2 && (i2 = s2.height / s2.width * e2);
    }
    return { width: e2, height: i2 };
  }
  function g(t2, e2, i2) {
    return { x: e2 * t2.a + i2 * t2.c + 0, y: e2 * t2.b + i2 * t2.d + 0 };
  }
  function f(t2) {
    return { a: t2[0], b: t2[1], c: t2[2], d: t2[3], e: t2[4], f: t2[5] };
  }
  function p(t2, e2) {
    t2.cx = null == t2.cx ? e2.bbox().cx : t2.cx, t2.cy = null == t2.cy ? e2.bbox().cy : t2.cy;
  }
  function x(e2) {
    for (var s2 = e2.childNodes.length - 1; s2 >= 0; s2--) e2.childNodes[s2] instanceof t.SVGElement && x(e2.childNodes[s2]);
    return i.adopt(e2).id(i.eid(e2.nodeName));
  }
  function m(t2) {
    return null == t2.x && (t2.x = 0, t2.y = 0, t2.width = 0, t2.height = 0), t2.w = t2.width, t2.h = t2.height, t2.x2 = t2.x + t2.width, t2.y2 = t2.y + t2.height, t2.cx = t2.x + t2.width / 2, t2.cy = t2.y + t2.height / 2, t2;
  }
  function b(t2) {
    return Math.abs(t2) > 1e-37 ? t2 : 0;
  }
  ["fill", "stroke"].forEach(function(t2) {
    var e2, s2 = {};
    s2[t2] = function(s3) {
      if (void 0 === s3) return this;
      if ("string" == typeof s3 || i.Color.isRgb(s3) || s3 && "function" == typeof s3.fill) this.attr(t2, s3);
      else for (e2 = o[t2].length - 1; e2 >= 0; e2--) null != s3[o[t2][e2]] && this.attr(o.prefix(t2, o[t2][e2]), s3[o[t2][e2]]);
      return this;
    }, i.extend(i.Element, i.FX, s2);
  }), i.extend(i.Element, i.FX, { rotate: function(t2, e2, i2) {
    return this.transform({ rotation: t2, cx: e2, cy: i2 });
  }, skew: function(t2, e2, i2, s2) {
    return 1 == arguments.length || 3 == arguments.length ? this.transform({ skew: t2, cx: e2, cy: i2 }) : this.transform({ skewX: t2, skewY: e2, cx: i2, cy: s2 });
  }, scale: function(t2, e2, i2, s2) {
    return 1 == arguments.length || 3 == arguments.length ? this.transform({ scale: t2, cx: e2, cy: i2 }) : this.transform({ scaleX: t2, scaleY: e2, cx: i2, cy: s2 });
  }, translate: function(t2, e2) {
    return this.transform({ x: t2, y: e2 });
  }, flip: function(t2, e2) {
    return e2 = "number" == typeof t2 ? t2 : e2, this.transform({ flip: t2 || "both", offset: e2 });
  }, matrix: function(t2) {
    return this.attr("transform", new i.Matrix(6 == arguments.length ? [].slice.call(arguments) : t2));
  }, opacity: function(t2) {
    return this.attr("opacity", t2);
  }, dx: function(t2) {
    return this.x(new i.Number(t2).plus(this instanceof i.FX ? 0 : this.x()), true);
  }, dy: function(t2) {
    return this.y(new i.Number(t2).plus(this instanceof i.FX ? 0 : this.y()), true);
  }, dmove: function(t2, e2) {
    return this.dx(t2).dy(e2);
  } }), i.extend(i.Rect, i.Ellipse, i.Circle, i.Gradient, i.FX, { radius: function(t2, e2) {
    var s2 = (this._target || this).type;
    return "radial" == s2 || "circle" == s2 ? this.attr("r", new i.Number(t2)) : this.rx(t2).ry(null == e2 ? t2 : e2);
  } }), i.extend(i.Path, { length: function() {
    return this.node.getTotalLength();
  }, pointAt: function(t2) {
    return this.node.getPointAtLength(t2);
  } }), i.extend(i.Parent, i.Text, i.Tspan, i.FX, { font: function(t2, e2) {
    if ("object" === _typeof(t2)) for (e2 in t2) this.font(e2, t2[e2]);
    return "leading" == t2 ? this.leading(e2) : "anchor" == t2 ? this.attr("text-anchor", e2) : "size" == t2 || "family" == t2 || "weight" == t2 || "stretch" == t2 || "variant" == t2 || "style" == t2 ? this.attr("font-" + t2, e2) : this.attr(t2, e2);
  } }), i.Set = i.invent({ create: function(t2) {
    Array.isArray(t2) ? this.members = t2 : this.clear();
  }, extend: { add: function() {
    var t2, e2, i2 = [].slice.call(arguments);
    for (t2 = 0, e2 = i2.length; t2 < e2; t2++) this.members.push(i2[t2]);
    return this;
  }, remove: function(t2) {
    var e2 = this.index(t2);
    return e2 > -1 && this.members.splice(e2, 1), this;
  }, each: function(t2) {
    for (var e2 = 0, i2 = this.members.length; e2 < i2; e2++) t2.apply(this.members[e2], [e2, this.members]);
    return this;
  }, clear: function() {
    return this.members = [], this;
  }, length: function() {
    return this.members.length;
  }, has: function(t2) {
    return this.index(t2) >= 0;
  }, index: function(t2) {
    return this.members.indexOf(t2);
  }, get: function(t2) {
    return this.members[t2];
  }, first: function() {
    return this.get(0);
  }, last: function() {
    return this.get(this.members.length - 1);
  }, valueOf: function() {
    return this.members;
  }, bbox: function() {
    if (0 == this.members.length) return new i.RBox();
    var t2 = this.members[0].rbox(this.members[0].doc());
    return this.each(function() {
      t2 = t2.merge(this.rbox(this.doc()));
    }), t2;
  } }, construct: { set: function(t2) {
    return new i.Set(t2);
  } } }), i.FX.Set = i.invent({ create: function(t2) {
    this.set = t2;
  } }), i.Set.inherit = function() {
    var t2 = [];
    for (var e2 in i.Shape.prototype) "function" == typeof i.Shape.prototype[e2] && "function" != typeof i.Set.prototype[e2] && t2.push(e2);
    for (var e2 in t2.forEach(function(t3) {
      i.Set.prototype[t3] = function() {
        for (var e3 = 0, s2 = this.members.length; e3 < s2; e3++) this.members[e3] && "function" == typeof this.members[e3][t3] && this.members[e3][t3].apply(this.members[e3], arguments);
        return "animate" == t3 ? this.fx || (this.fx = new i.FX.Set(this)) : this;
      };
    }), t2 = [], i.FX.prototype) "function" == typeof i.FX.prototype[e2] && "function" != typeof i.FX.Set.prototype[e2] && t2.push(e2);
    t2.forEach(function(t3) {
      i.FX.Set.prototype[t3] = function() {
        for (var e3 = 0, i2 = this.set.members.length; e3 < i2; e3++) this.set.members[e3].fx[t3].apply(this.set.members[e3].fx, arguments);
        return this;
      };
    });
  }, i.extend(i.Element, { data: function(t2, e2, i2) {
    if ("object" === _typeof(t2)) for (e2 in t2) this.data(e2, t2[e2]);
    else if (arguments.length < 2) try {
      return JSON.parse(this.attr("data-" + t2));
    } catch (e3) {
      return this.attr("data-" + t2);
    }
    else this.attr("data-" + t2, null === e2 ? null : true === i2 || "string" == typeof e2 || "number" == typeof e2 ? e2 : JSON.stringify(e2));
    return this;
  } }), i.extend(i.Element, { remember: function(t2, e2) {
    if ("object" === _typeof(arguments[0])) for (var e2 in t2) this.remember(e2, t2[e2]);
    else {
      if (1 == arguments.length) return this.memory()[t2];
      this.memory()[t2] = e2;
    }
    return this;
  }, forget: function() {
    if (0 == arguments.length) this._memory = {};
    else for (var t2 = arguments.length - 1; t2 >= 0; t2--) delete this.memory()[arguments[t2]];
    return this;
  }, memory: function() {
    return this._memory || (this._memory = {});
  } }), i.get = function(t2) {
    var s2 = e.getElementById((function(t3) {
      var e2 = (t3 || "").toString().match(i.regex.reference);
      if (e2) return e2[1];
    })(t2) || t2);
    return i.adopt(s2);
  }, i.select = function(t2, s2) {
    return new i.Set(i.utils.map((s2 || e).querySelectorAll(t2), function(t3) {
      return i.adopt(t3);
    }));
  }, i.extend(i.Parent, { select: function(t2) {
    return i.select(t2, this.node);
  } });
  var v = "abcdef".split("");
  if ("function" != typeof t.CustomEvent) {
    var y = function(t2, i2) {
      i2 = i2 || { bubbles: false, cancelable: false, detail: void 0 };
      var s2 = e.createEvent("CustomEvent");
      return s2.initCustomEvent(t2, i2.bubbles, i2.cancelable, i2.detail), s2;
    };
    y.prototype = t.Event.prototype, i.CustomEvent = y;
  } else i.CustomEvent = t.CustomEvent;
  return (function(e2) {
    for (var i2 = 0, s2 = ["moz", "webkit"], a2 = 0; a2 < s2.length && !t.requestAnimationFrame; ++a2) e2.requestAnimationFrame = e2[s2[a2] + "RequestAnimationFrame"], e2.cancelAnimationFrame = e2[s2[a2] + "CancelAnimationFrame"] || e2[s2[a2] + "CancelRequestAnimationFrame"];
    e2.requestAnimationFrame = e2.requestAnimationFrame || function(t2) {
      var s3 = (/* @__PURE__ */ new Date()).getTime(), a3 = Math.max(0, 16 - (s3 - i2)), r2 = e2.setTimeout(function() {
        t2(s3 + a3);
      }, a3);
      return i2 = s3 + a3, r2;
    }, e2.cancelAnimationFrame = e2.cancelAnimationFrame || e2.clearTimeout;
  })(t), i;
}), (function() {
  SVG.Filter = SVG.invent({ create: "filter", inherit: SVG.Parent, extend: { source: "SourceGraphic", sourceAlpha: "SourceAlpha", background: "BackgroundImage", backgroundAlpha: "BackgroundAlpha", fill: "FillPaint", stroke: "StrokePaint", autoSetIn: true, put: function(t2, e2) {
    return this.add(t2, e2), !t2.attr("in") && this.autoSetIn && t2.attr("in", this.source), t2.attr("result") || t2.attr("result", t2), t2;
  }, blend: function(t2, e2, i2) {
    return this.put(new SVG.BlendEffect(t2, e2, i2));
  }, colorMatrix: function(t2, e2) {
    return this.put(new SVG.ColorMatrixEffect(t2, e2));
  }, convolveMatrix: function(t2) {
    return this.put(new SVG.ConvolveMatrixEffect(t2));
  }, componentTransfer: function(t2) {
    return this.put(new SVG.ComponentTransferEffect(t2));
  }, composite: function(t2, e2, i2) {
    return this.put(new SVG.CompositeEffect(t2, e2, i2));
  }, flood: function(t2, e2) {
    return this.put(new SVG.FloodEffect(t2, e2));
  }, offset: function(t2, e2) {
    return this.put(new SVG.OffsetEffect(t2, e2));
  }, image: function(t2) {
    return this.put(new SVG.ImageEffect(t2));
  }, merge: function() {
    var t2 = [void 0];
    for (var e2 in arguments) t2.push(arguments[e2]);
    return this.put(new (SVG.MergeEffect.bind.apply(SVG.MergeEffect, t2))());
  }, gaussianBlur: function(t2, e2) {
    return this.put(new SVG.GaussianBlurEffect(t2, e2));
  }, morphology: function(t2, e2) {
    return this.put(new SVG.MorphologyEffect(t2, e2));
  }, diffuseLighting: function(t2, e2, i2) {
    return this.put(new SVG.DiffuseLightingEffect(t2, e2, i2));
  }, displacementMap: function(t2, e2, i2, s2, a2) {
    return this.put(new SVG.DisplacementMapEffect(t2, e2, i2, s2, a2));
  }, specularLighting: function(t2, e2, i2, s2) {
    return this.put(new SVG.SpecularLightingEffect(t2, e2, i2, s2));
  }, tile: function() {
    return this.put(new SVG.TileEffect());
  }, turbulence: function(t2, e2, i2, s2, a2) {
    return this.put(new SVG.TurbulenceEffect(t2, e2, i2, s2, a2));
  }, toString: function() {
    return "url(#" + this.attr("id") + ")";
  } } }), SVG.extend(SVG.Defs, { filter: function(t2) {
    var e2 = this.put(new SVG.Filter());
    return "function" == typeof t2 && t2.call(e2, e2), e2;
  } }), SVG.extend(SVG.Container, { filter: function(t2) {
    return this.defs().filter(t2);
  } }), SVG.extend(SVG.Element, SVG.G, SVG.Nested, { filter: function(t2) {
    return this.filterer = t2 instanceof SVG.Element ? t2 : this.doc().filter(t2), this.doc() && this.filterer.doc() !== this.doc() && this.doc().defs().add(this.filterer), this.attr("filter", this.filterer), this.filterer;
  }, unfilter: function(t2) {
    return this.filterer && true === t2 && this.filterer.remove(), delete this.filterer, this.attr("filter", null);
  } }), SVG.Effect = SVG.invent({ create: function() {
    this.constructor.call(this);
  }, inherit: SVG.Element, extend: { in: function(t2) {
    return null == t2 ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", t2);
  }, result: function(t2) {
    return null == t2 ? this.attr("result") : this.attr("result", t2);
  }, toString: function() {
    return this.result();
  } } }), SVG.ParentEffect = SVG.invent({ create: function() {
    this.constructor.call(this);
  }, inherit: SVG.Parent, extend: { in: function(t2) {
    return null == t2 ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", t2);
  }, result: function(t2) {
    return null == t2 ? this.attr("result") : this.attr("result", t2);
  }, toString: function() {
    return this.result();
  } } });
  var t = { blend: function(t2, e2) {
    return this.parent() && this.parent().blend(this, t2, e2);
  }, colorMatrix: function(t2, e2) {
    return this.parent() && this.parent().colorMatrix(t2, e2).in(this);
  }, convolveMatrix: function(t2) {
    return this.parent() && this.parent().convolveMatrix(t2).in(this);
  }, componentTransfer: function(t2) {
    return this.parent() && this.parent().componentTransfer(t2).in(this);
  }, composite: function(t2, e2) {
    return this.parent() && this.parent().composite(this, t2, e2);
  }, flood: function(t2, e2) {
    return this.parent() && this.parent().flood(t2, e2);
  }, offset: function(t2, e2) {
    return this.parent() && this.parent().offset(t2, e2).in(this);
  }, image: function(t2) {
    return this.parent() && this.parent().image(t2);
  }, merge: function() {
    return this.parent() && this.parent().merge.apply(this.parent(), [this].concat(arguments));
  }, gaussianBlur: function(t2, e2) {
    return this.parent() && this.parent().gaussianBlur(t2, e2).in(this);
  }, morphology: function(t2, e2) {
    return this.parent() && this.parent().morphology(t2, e2).in(this);
  }, diffuseLighting: function(t2, e2, i2) {
    return this.parent() && this.parent().diffuseLighting(t2, e2, i2).in(this);
  }, displacementMap: function(t2, e2, i2, s2) {
    return this.parent() && this.parent().displacementMap(this, t2, e2, i2, s2);
  }, specularLighting: function(t2, e2, i2, s2) {
    return this.parent() && this.parent().specularLighting(t2, e2, i2, s2).in(this);
  }, tile: function() {
    return this.parent() && this.parent().tile().in(this);
  }, turbulence: function(t2, e2, i2, s2, a2) {
    return this.parent() && this.parent().turbulence(t2, e2, i2, s2, a2).in(this);
  } };
  SVG.extend(SVG.Effect, t), SVG.extend(SVG.ParentEffect, t), SVG.ChildEffect = SVG.invent({ create: function() {
    this.constructor.call(this);
  }, inherit: SVG.Element, extend: { in: function(t2) {
    this.attr("in", t2);
  } } });
  var e = { blend: function(t2, e2, i2) {
    this.attr({ in: t2, in2: e2, mode: i2 || "normal" });
  }, colorMatrix: function(t2, e2) {
    "matrix" == t2 && (e2 = a(e2)), this.attr({ type: t2, values: void 0 === e2 ? null : e2 });
  }, convolveMatrix: function(t2) {
    t2 = a(t2), this.attr({ order: Math.sqrt(t2.split(" ").length), kernelMatrix: t2 });
  }, composite: function(t2, e2, i2) {
    this.attr({ in: t2, in2: e2, operator: i2 });
  }, flood: function(t2, e2) {
    this.attr("flood-color", t2), null != e2 && this.attr("flood-opacity", e2);
  }, offset: function(t2, e2) {
    this.attr({ dx: t2, dy: e2 });
  }, image: function(t2) {
    this.attr("href", t2, SVG.xlink);
  }, displacementMap: function(t2, e2, i2, s2, a2) {
    this.attr({ in: t2, in2: e2, scale: i2, xChannelSelector: s2, yChannelSelector: a2 });
  }, gaussianBlur: function(t2, e2) {
    null != t2 || null != e2 ? this.attr("stdDeviation", (function(t3) {
      if (!Array.isArray(t3)) return t3;
      for (var e3 = 0, i2 = t3.length, s2 = []; e3 < i2; e3++) s2.push(t3[e3]);
      return s2.join(" ");
    })(Array.prototype.slice.call(arguments))) : this.attr("stdDeviation", "0 0");
  }, morphology: function(t2, e2) {
    this.attr({ operator: t2, radius: e2 });
  }, tile: function() {
  }, turbulence: function(t2, e2, i2, s2, a2) {
    this.attr({ numOctaves: e2, seed: i2, stitchTiles: s2, baseFrequency: t2, type: a2 });
  } }, i = { merge: function() {
    var t2;
    if (arguments[0] instanceof SVG.Set) {
      var e2 = this;
      arguments[0].each(function(t3) {
        this instanceof SVG.MergeNode ? e2.put(this) : (this instanceof SVG.Effect || this instanceof SVG.ParentEffect) && e2.put(new SVG.MergeNode(this));
      });
    } else {
      t2 = Array.isArray(arguments[0]) ? arguments[0] : arguments;
      for (var i2 = 0; i2 < t2.length; i2++) t2[i2] instanceof SVG.MergeNode ? this.put(t2[i2]) : this.put(new SVG.MergeNode(t2[i2]));
    }
  }, componentTransfer: function(t2) {
    if (this.rgb = new SVG.Set(), ["r", "g", "b", "a"].forEach((function(t3) {
      this[t3] = new SVG["Func" + t3.toUpperCase()]("identity"), this.rgb.add(this[t3]), this.node.appendChild(this[t3].node);
    }).bind(this)), t2) for (var e2 in t2.rgb && (["r", "g", "b"].forEach((function(e3) {
      this[e3].attr(t2.rgb);
    }).bind(this)), delete t2.rgb), t2) this[e2].attr(t2[e2]);
  }, diffuseLighting: function(t2, e2, i2) {
    this.attr({ surfaceScale: t2, diffuseConstant: e2, kernelUnitLength: i2 });
  }, specularLighting: function(t2, e2, i2, s2) {
    this.attr({ surfaceScale: t2, diffuseConstant: e2, specularExponent: i2, kernelUnitLength: s2 });
  } }, s = { distantLight: function(t2, e2) {
    this.attr({ azimuth: t2, elevation: e2 });
  }, pointLight: function(t2, e2, i2) {
    this.attr({ x: t2, y: e2, z: i2 });
  }, spotLight: function(t2, e2, i2, s2, a2, r2) {
    this.attr({ x: t2, y: e2, z: i2, pointsAtX: s2, pointsAtY: a2, pointsAtZ: r2 });
  }, mergeNode: function(t2) {
    this.attr("in", t2);
  } };
  function a(t2) {
    return Array.isArray(t2) && (t2 = new SVG.Array(t2)), t2.toString().replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ");
  }
  function r() {
    var t2 = function() {
    };
    for (var e2 in "function" == typeof arguments[arguments.length - 1] && (t2 = arguments[arguments.length - 1], Array.prototype.splice.call(arguments, arguments.length - 1, 1)), arguments) for (var i2 in arguments[e2]) t2(arguments[e2][i2], i2, arguments[e2]);
  }
  ["r", "g", "b", "a"].forEach(function(t2) {
    s["Func" + t2.toUpperCase()] = function(t3) {
      switch (this.attr("type", t3), t3) {
        case "table":
          this.attr("tableValues", arguments[1]);
          break;
        case "linear":
          this.attr("slope", arguments[1]), this.attr("intercept", arguments[2]);
          break;
        case "gamma":
          this.attr("amplitude", arguments[1]), this.attr("exponent", arguments[2]), this.attr("offset", arguments[2]);
      }
    };
  }), r(e, function(t2, e2) {
    var i2 = e2.charAt(0).toUpperCase() + e2.slice(1);
    SVG[i2 + "Effect"] = SVG.invent({ create: function() {
      this.constructor.call(this, SVG.create("fe" + i2)), t2.apply(this, arguments), this.result(this.attr("id") + "Out");
    }, inherit: SVG.Effect, extend: {} });
  }), r(i, function(t2, e2) {
    var i2 = e2.charAt(0).toUpperCase() + e2.slice(1);
    SVG[i2 + "Effect"] = SVG.invent({ create: function() {
      this.constructor.call(this, SVG.create("fe" + i2)), t2.apply(this, arguments), this.result(this.attr("id") + "Out");
    }, inherit: SVG.ParentEffect, extend: {} });
  }), r(s, function(t2, e2) {
    var i2 = e2.charAt(0).toUpperCase() + e2.slice(1);
    SVG[i2] = SVG.invent({ create: function() {
      this.constructor.call(this, SVG.create("fe" + i2)), t2.apply(this, arguments);
    }, inherit: SVG.ChildEffect, extend: {} });
  }), SVG.extend(SVG.MergeEffect, { in: function(t2) {
    return t2 instanceof SVG.MergeNode ? this.add(t2, 0) : this.add(new SVG.MergeNode(t2), 0), this;
  } }), SVG.extend(SVG.CompositeEffect, SVG.BlendEffect, SVG.DisplacementMapEffect, { in2: function(t2) {
    return null == t2 ? this.parent() && this.parent().select('[result="' + this.attr("in2") + '"]').get(0) || this.attr("in2") : this.attr("in2", t2);
  } }), SVG.filter = { sepiatone: [0.343, 0.669, 0.119, 0, 0, 0.249, 0.626, 0.13, 0, 0, 0.172, 0.334, 0.111, 0, 0, 0, 0, 0, 1, 0] };
}).call(void 0), (function() {
  function t(t2, a2, r, n, o, l, h) {
    for (var c = t2.slice(a2, r || h), d = n.slice(o, l || h), u = 0, g = { pos: [0, 0], start: [0, 0] }, f = { pos: [0, 0], start: [0, 0] }; ; ) {
      if (c[u] = e.call(g, c[u]), d[u] = e.call(f, d[u]), c[u][0] != d[u][0] || "M" == c[u][0] || "A" == c[u][0] && (c[u][4] != d[u][4] || c[u][5] != d[u][5]) ? (Array.prototype.splice.apply(c, [u, 1].concat(s.call(g, c[u]))), Array.prototype.splice.apply(d, [u, 1].concat(s.call(f, d[u])))) : (c[u] = i.call(g, c[u]), d[u] = i.call(f, d[u])), ++u == c.length && u == d.length) break;
      u == c.length && c.push(["C", g.pos[0], g.pos[1], g.pos[0], g.pos[1], g.pos[0], g.pos[1]]), u == d.length && d.push(["C", f.pos[0], f.pos[1], f.pos[0], f.pos[1], f.pos[0], f.pos[1]]);
    }
    return { start: c, dest: d };
  }
  function e(t2) {
    switch (t2[0]) {
      case "z":
      case "Z":
        t2[0] = "L", t2[1] = this.start[0], t2[2] = this.start[1];
        break;
      case "H":
        t2[0] = "L", t2[2] = this.pos[1];
        break;
      case "V":
        t2[0] = "L", t2[2] = t2[1], t2[1] = this.pos[0];
        break;
      case "T":
        t2[0] = "Q", t2[3] = t2[1], t2[4] = t2[2], t2[1] = this.reflection[1], t2[2] = this.reflection[0];
        break;
      case "S":
        t2[0] = "C", t2[6] = t2[4], t2[5] = t2[3], t2[4] = t2[2], t2[3] = t2[1], t2[2] = this.reflection[1], t2[1] = this.reflection[0];
    }
    return t2;
  }
  function i(t2) {
    var e2 = t2.length;
    return this.pos = [t2[e2 - 2], t2[e2 - 1]], -1 != "SCQT".indexOf(t2[0]) && (this.reflection = [2 * this.pos[0] - t2[e2 - 4], 2 * this.pos[1] - t2[e2 - 3]]), t2;
  }
  function s(t2) {
    var e2 = [t2];
    switch (t2[0]) {
      case "M":
        return this.pos = this.start = [t2[1], t2[2]], e2;
      case "L":
        t2[5] = t2[3] = t2[1], t2[6] = t2[4] = t2[2], t2[1] = this.pos[0], t2[2] = this.pos[1];
        break;
      case "Q":
        t2[6] = t2[4], t2[5] = t2[3], t2[4] = 1 * t2[4] / 3 + 2 * t2[2] / 3, t2[3] = 1 * t2[3] / 3 + 2 * t2[1] / 3, t2[2] = 1 * this.pos[1] / 3 + 2 * t2[2] / 3, t2[1] = 1 * this.pos[0] / 3 + 2 * t2[1] / 3;
        break;
      case "A":
        t2 = (e2 = (function(t3, e3) {
          var i2, s2, a2, r, n, o, l, h, c, d, u, g, f, p, x, m, b, v, y, w, k, A, S, C, L, P, z = Math.abs(e3[1]), T = Math.abs(e3[2]), M = e3[3] % 360, E = e3[4], X = e3[5], I = e3[6], Y = e3[7], F = new SVG.Point(t3), R = new SVG.Point(I, Y), D = [];
          if (0 === z || 0 === T || F.x === R.x && F.y === R.y) return [["C", F.x, F.y, R.x, R.y, R.x, R.y]];
          i2 = new SVG.Point((F.x - R.x) / 2, (F.y - R.y) / 2).transform(new SVG.Matrix().rotate(M)), (s2 = i2.x * i2.x / (z * z) + i2.y * i2.y / (T * T)) > 1 && (s2 = Math.sqrt(s2), z *= s2, T *= s2);
          a2 = new SVG.Matrix().rotate(M).scale(1 / z, 1 / T).rotate(-M), F = F.transform(a2), R = R.transform(a2), r = [R.x - F.x, R.y - F.y], o = r[0] * r[0] + r[1] * r[1], n = Math.sqrt(o), r[0] /= n, r[1] /= n, l = o < 4 ? Math.sqrt(1 - o / 4) : 0, E === X && (l *= -1);
          h = new SVG.Point((R.x + F.x) / 2 + l * -r[1], (R.y + F.y) / 2 + l * r[0]), c = new SVG.Point(F.x - h.x, F.y - h.y), d = new SVG.Point(R.x - h.x, R.y - h.y), u = Math.acos(c.x / Math.sqrt(c.x * c.x + c.y * c.y)), c.y < 0 && (u *= -1);
          g = Math.acos(d.x / Math.sqrt(d.x * d.x + d.y * d.y)), d.y < 0 && (g *= -1);
          X && u > g && (g += 2 * Math.PI);
          !X && u < g && (g -= 2 * Math.PI);
          for (p = Math.ceil(2 * Math.abs(u - g) / Math.PI), m = [], b = u, f = (g - u) / p, x = 4 * Math.tan(f / 4) / 3, k = 0; k <= p; k++) y = Math.cos(b), v = Math.sin(b), w = new SVG.Point(h.x + y, h.y + v), m[k] = [new SVG.Point(w.x + x * v, w.y - x * y), w, new SVG.Point(w.x - x * v, w.y + x * y)], b += f;
          for (m[0][0] = m[0][1].clone(), m[m.length - 1][2] = m[m.length - 1][1].clone(), a2 = new SVG.Matrix().rotate(M).scale(z, T).rotate(-M), k = 0, A = m.length; k < A; k++) m[k][0] = m[k][0].transform(a2), m[k][1] = m[k][1].transform(a2), m[k][2] = m[k][2].transform(a2);
          for (k = 1, A = m.length; k < A; k++) w = m[k - 1][2], S = w.x, C = w.y, w = m[k][0], L = w.x, P = w.y, w = m[k][1], I = w.x, Y = w.y, D.push(["C", S, C, L, P, I, Y]);
          return D;
        })(this.pos, t2))[0];
    }
    return t2[0] = "C", this.pos = [t2[5], t2[6]], this.reflection = [2 * t2[5] - t2[3], 2 * t2[6] - t2[4]], e2;
  }
  function a(t2, e2) {
    if (false === e2) return false;
    for (var i2 = e2, s2 = t2.length; i2 < s2; ++i2) if ("M" == t2[i2][0]) return i2;
    return false;
  }
  SVG.extend(SVG.PathArray, { morph: function(e2) {
    for (var i2 = this.value, s2 = this.parse(e2), r = 0, n = 0, o = false, l = false; false !== r || false !== n; ) {
      var h;
      o = a(i2, false !== r && r + 1), l = a(s2, false !== n && n + 1), false === r && (r = 0 == (h = new SVG.PathArray(c.start).bbox()).height || 0 == h.width ? i2.push(i2[0]) - 1 : i2.push(["M", h.x + h.width / 2, h.y + h.height / 2]) - 1), false === n && (n = 0 == (h = new SVG.PathArray(c.dest).bbox()).height || 0 == h.width ? s2.push(s2[0]) - 1 : s2.push(["M", h.x + h.width / 2, h.y + h.height / 2]) - 1);
      var c = t(i2, r, o, s2, n, l);
      i2 = i2.slice(0, r).concat(c.start, false === o ? [] : i2.slice(o)), s2 = s2.slice(0, n).concat(c.dest, false === l ? [] : s2.slice(l)), r = false !== o && r + c.start.length, n = false !== l && n + c.dest.length;
    }
    return this.value = i2, this.destination = new SVG.PathArray(), this.destination.value = s2, this;
  } });
})(), (function() {
  function t(t2) {
    t2.remember("_draggable", this), this.el = t2;
  }
  t.prototype.init = function(t2, e) {
    var i = this;
    this.constraint = t2, this.value = e, this.el.on("mousedown.drag", function(t3) {
      i.start(t3);
    }), this.el.on("touchstart.drag", function(t3) {
      i.start(t3);
    });
  }, t.prototype.transformPoint = function(t2, e) {
    var i = (t2 = t2 || window.event).changedTouches && t2.changedTouches[0] || t2;
    return this.p.x = i.clientX - (e || 0), this.p.y = i.clientY, this.p.matrixTransform(this.m);
  }, t.prototype.getBBox = function() {
    var t2 = this.el.bbox();
    return this.el instanceof SVG.Nested && (t2 = this.el.rbox()), (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) && (t2.x = this.el.x(), t2.y = this.el.y()), t2;
  }, t.prototype.start = function(t2) {
    if ("click" != t2.type && "mousedown" != t2.type && "mousemove" != t2.type || 1 == (t2.which || t2.buttons)) {
      var e = this;
      if (this.el.fire("beforedrag", { event: t2, handler: this }), !this.el.event().defaultPrevented) {
        t2.preventDefault(), t2.stopPropagation(), this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc), this.p = this.parent.node.createSVGPoint(), this.m = this.el.node.getScreenCTM().inverse();
        var i, s = this.getBBox();
        if (this.el instanceof SVG.Text) switch (i = this.el.node.getComputedTextLength(), this.el.attr("text-anchor")) {
          case "middle":
            i /= 2;
            break;
          case "start":
            i = 0;
        }
        this.startPoints = { point: this.transformPoint(t2, i), box: s, transform: this.el.transform() }, SVG.on(window, "mousemove.drag", function(t3) {
          e.drag(t3);
        }), SVG.on(window, "touchmove.drag", function(t3) {
          e.drag(t3);
        }), SVG.on(window, "mouseup.drag", function(t3) {
          e.end(t3);
        }), SVG.on(window, "touchend.drag", function(t3) {
          e.end(t3);
        }), this.el.fire("dragstart", { event: t2, p: this.startPoints.point, m: this.m, handler: this });
      }
    }
  }, t.prototype.drag = function(t2) {
    var e = this.getBBox(), i = this.transformPoint(t2), s = this.startPoints.box.x + i.x - this.startPoints.point.x, a = this.startPoints.box.y + i.y - this.startPoints.point.y, r = this.constraint, n = i.x - this.startPoints.point.x, o = i.y - this.startPoints.point.y;
    if (this.el.fire("dragmove", { event: t2, p: i, m: this.m, handler: this }), this.el.event().defaultPrevented) return i;
    if ("function" == typeof r) {
      var l = r.call(this.el, s, a, this.m);
      "boolean" == typeof l && (l = { x: l, y: l }), true === l.x ? this.el.x(s) : false !== l.x && this.el.x(l.x), true === l.y ? this.el.y(a) : false !== l.y && this.el.y(l.y);
    } else "object" == typeof r && (null != r.minX && s < r.minX ? n = (s = r.minX) - this.startPoints.box.x : null != r.maxX && s > r.maxX - e.width && (n = (s = r.maxX - e.width) - this.startPoints.box.x), null != r.minY && a < r.minY ? o = (a = r.minY) - this.startPoints.box.y : null != r.maxY && a > r.maxY - e.height && (o = (a = r.maxY - e.height) - this.startPoints.box.y), null != r.snapToGrid && (s -= s % r.snapToGrid, a -= a % r.snapToGrid, n -= n % r.snapToGrid, o -= o % r.snapToGrid), this.el instanceof SVG.G ? this.el.matrix(this.startPoints.transform).transform({ x: n, y: o }, true) : this.el.move(s, a));
    return i;
  }, t.prototype.end = function(t2) {
    var e = this.drag(t2);
    this.el.fire("dragend", { event: t2, p: e, m: this.m, handler: this }), SVG.off(window, "mousemove.drag"), SVG.off(window, "touchmove.drag"), SVG.off(window, "mouseup.drag"), SVG.off(window, "touchend.drag");
  }, SVG.extend(SVG.Element, { draggable: function(e, i) {
    "function" != typeof e && "object" != typeof e || (i = e, e = true);
    var s = this.remember("_draggable") || new t(this);
    return (e = void 0 === e || e) ? s.init(i || {}, e) : (this.off("mousedown.drag"), this.off("touchstart.drag")), this;
  } });
}).call(void 0), (function() {
  function t(t2) {
    this.el = t2, t2.remember("_selectHandler", this), this.pointSelection = { isSelected: false }, this.rectSelection = { isSelected: false };
  }
  t.prototype.init = function(t2, e) {
    var i = this.el.bbox();
    for (var s in this.options = {}, this.el.selectize.defaults) this.options[s] = this.el.selectize.defaults[s], void 0 !== e[s] && (this.options[s] = e[s]);
    this.parent = this.el.parent(), this.nested = this.nested || this.parent.group(), this.nested.matrix(new SVG.Matrix(this.el).translate(i.x, i.y)), this.options.deepSelect && -1 !== ["line", "polyline", "polygon"].indexOf(this.el.type) ? this.selectPoints(t2) : this.selectRect(t2), this.observe(), this.cleanup();
  }, t.prototype.selectPoints = function(t2) {
    return this.pointSelection.isSelected = t2, this.pointSelection.set ? this : (this.pointSelection.set = this.parent.set(), this.drawCircles(), this);
  }, t.prototype.getPointArray = function() {
    var t2 = this.el.bbox();
    return this.el.array().valueOf().map(function(e) {
      return [e[0] - t2.x, e[1] - t2.y];
    });
  }, t.prototype.drawCircles = function() {
    for (var t2 = this, e = this.getPointArray(), i = 0, s = e.length; i < s; ++i) {
      var a = /* @__PURE__ */ (function(e2) {
        return function(i2) {
          (i2 = i2 || window.event).preventDefault ? i2.preventDefault() : i2.returnValue = false, i2.stopPropagation();
          var s2 = i2.pageX || i2.touches[0].pageX, a2 = i2.pageY || i2.touches[0].pageY;
          t2.el.fire("point", { x: s2, y: a2, i: e2, event: i2 });
        };
      })(i);
      this.pointSelection.set.add(this.nested.circle(this.options.radius).center(e[i][0], e[i][1]).addClass(this.options.classPoints).addClass(this.options.classPoints + "_point").on("touchstart", a).on("mousedown", a));
    }
  }, t.prototype.updatePointSelection = function() {
    var t2 = this.getPointArray();
    this.pointSelection.set.each(function(e) {
      this.cx() === t2[e][0] && this.cy() === t2[e][1] || this.center(t2[e][0], t2[e][1]);
    });
  }, t.prototype.updateRectSelection = function() {
    var t2 = this.el.bbox();
    this.rectSelection.set.get(0).attr({ width: t2.width, height: t2.height }), this.options.points && (this.rectSelection.set.get(2).center(t2.width, 0), this.rectSelection.set.get(3).center(t2.width, t2.height), this.rectSelection.set.get(4).center(0, t2.height), this.rectSelection.set.get(5).center(t2.width / 2, 0), this.rectSelection.set.get(6).center(t2.width, t2.height / 2), this.rectSelection.set.get(7).center(t2.width / 2, t2.height), this.rectSelection.set.get(8).center(0, t2.height / 2)), this.options.rotationPoint && (this.options.points ? this.rectSelection.set.get(9).center(t2.width / 2, 20) : this.rectSelection.set.get(1).center(t2.width / 2, 20));
  }, t.prototype.selectRect = function(t2) {
    var e = this, i = this.el.bbox();
    function s(t3) {
      return function(i2) {
        (i2 = i2 || window.event).preventDefault ? i2.preventDefault() : i2.returnValue = false, i2.stopPropagation();
        var s2 = i2.pageX || i2.touches[0].pageX, a2 = i2.pageY || i2.touches[0].pageY;
        e.el.fire(t3, { x: s2, y: a2, event: i2 });
      };
    }
    if (this.rectSelection.isSelected = t2, this.rectSelection.set = this.rectSelection.set || this.parent.set(), this.rectSelection.set.get(0) || this.rectSelection.set.add(this.nested.rect(i.width, i.height).addClass(this.options.classRect)), this.options.points && !this.rectSelection.set.get(1)) {
      var a = "touchstart", r = "mousedown";
      this.rectSelection.set.add(this.nested.circle(this.options.radius).center(0, 0).attr("class", this.options.classPoints + "_lt").on(r, s("lt")).on(a, s("lt"))), this.rectSelection.set.add(this.nested.circle(this.options.radius).center(i.width, 0).attr("class", this.options.classPoints + "_rt").on(r, s("rt")).on(a, s("rt"))), this.rectSelection.set.add(this.nested.circle(this.options.radius).center(i.width, i.height).attr("class", this.options.classPoints + "_rb").on(r, s("rb")).on(a, s("rb"))), this.rectSelection.set.add(this.nested.circle(this.options.radius).center(0, i.height).attr("class", this.options.classPoints + "_lb").on(r, s("lb")).on(a, s("lb"))), this.rectSelection.set.add(this.nested.circle(this.options.radius).center(i.width / 2, 0).attr("class", this.options.classPoints + "_t").on(r, s("t")).on(a, s("t"))), this.rectSelection.set.add(this.nested.circle(this.options.radius).center(i.width, i.height / 2).attr("class", this.options.classPoints + "_r").on(r, s("r")).on(a, s("r"))), this.rectSelection.set.add(this.nested.circle(this.options.radius).center(i.width / 2, i.height).attr("class", this.options.classPoints + "_b").on(r, s("b")).on(a, s("b"))), this.rectSelection.set.add(this.nested.circle(this.options.radius).center(0, i.height / 2).attr("class", this.options.classPoints + "_l").on(r, s("l")).on(a, s("l"))), this.rectSelection.set.each(function() {
        this.addClass(e.options.classPoints);
      });
    }
    if (this.options.rotationPoint && (this.options.points && !this.rectSelection.set.get(9) || !this.options.points && !this.rectSelection.set.get(1))) {
      var n = function(t3) {
        (t3 = t3 || window.event).preventDefault ? t3.preventDefault() : t3.returnValue = false, t3.stopPropagation();
        var i2 = t3.pageX || t3.touches[0].pageX, s2 = t3.pageY || t3.touches[0].pageY;
        e.el.fire("rot", { x: i2, y: s2, event: t3 });
      };
      this.rectSelection.set.add(this.nested.circle(this.options.radius).center(i.width / 2, 20).attr("class", this.options.classPoints + "_rot").on("touchstart", n).on("mousedown", n));
    }
  }, t.prototype.handler = function() {
    var t2 = this.el.bbox();
    this.nested.matrix(new SVG.Matrix(this.el).translate(t2.x, t2.y)), this.rectSelection.isSelected && this.updateRectSelection(), this.pointSelection.isSelected && this.updatePointSelection();
  }, t.prototype.observe = function() {
    var t2 = this;
    if (MutationObserver) if (this.rectSelection.isSelected || this.pointSelection.isSelected) this.observerInst = this.observerInst || new MutationObserver(function() {
      t2.handler();
    }), this.observerInst.observe(this.el.node, { attributes: true });
    else try {
      this.observerInst.disconnect(), delete this.observerInst;
    } catch (t3) {
    }
    else this.el.off("DOMAttrModified.select"), (this.rectSelection.isSelected || this.pointSelection.isSelected) && this.el.on("DOMAttrModified.select", function() {
      t2.handler();
    });
  }, t.prototype.cleanup = function() {
    !this.rectSelection.isSelected && this.rectSelection.set && (this.rectSelection.set.each(function() {
      this.remove();
    }), this.rectSelection.set.clear(), delete this.rectSelection.set), !this.pointSelection.isSelected && this.pointSelection.set && (this.pointSelection.set.each(function() {
      this.remove();
    }), this.pointSelection.set.clear(), delete this.pointSelection.set), this.pointSelection.isSelected || this.rectSelection.isSelected || (this.nested.remove(), delete this.nested);
  }, SVG.extend(SVG.Element, { selectize: function(e, i) {
    return "object" == typeof e && (i = e, e = true), (this.remember("_selectHandler") || new t(this)).init(void 0 === e || e, i || {}), this;
  } }), SVG.Element.prototype.selectize.defaults = { points: true, classRect: "svg_select_boundingRect", classPoints: "svg_select_points", radius: 7, rotationPoint: true, deepSelect: false };
})(), (function() {
  (function() {
    function t(t2) {
      t2.remember("_resizeHandler", this), this.el = t2, this.parameters = {}, this.lastUpdateCall = null, this.p = t2.doc().node.createSVGPoint();
    }
    t.prototype.transformPoint = function(t2, e, i) {
      return this.p.x = t2 - (this.offset.x - window.pageXOffset), this.p.y = e - (this.offset.y - window.pageYOffset), this.p.matrixTransform(i || this.m);
    }, t.prototype._extractPosition = function(t2) {
      return { x: null != t2.clientX ? t2.clientX : t2.touches[0].clientX, y: null != t2.clientY ? t2.clientY : t2.touches[0].clientY };
    }, t.prototype.init = function(t2) {
      var e = this;
      if (this.stop(), "stop" !== t2) {
        for (var i in this.options = {}, this.el.resize.defaults) this.options[i] = this.el.resize.defaults[i], void 0 !== t2[i] && (this.options[i] = t2[i]);
        this.el.on("lt.resize", function(t3) {
          e.resize(t3 || window.event);
        }), this.el.on("rt.resize", function(t3) {
          e.resize(t3 || window.event);
        }), this.el.on("rb.resize", function(t3) {
          e.resize(t3 || window.event);
        }), this.el.on("lb.resize", function(t3) {
          e.resize(t3 || window.event);
        }), this.el.on("t.resize", function(t3) {
          e.resize(t3 || window.event);
        }), this.el.on("r.resize", function(t3) {
          e.resize(t3 || window.event);
        }), this.el.on("b.resize", function(t3) {
          e.resize(t3 || window.event);
        }), this.el.on("l.resize", function(t3) {
          e.resize(t3 || window.event);
        }), this.el.on("rot.resize", function(t3) {
          e.resize(t3 || window.event);
        }), this.el.on("point.resize", function(t3) {
          e.resize(t3 || window.event);
        }), this.update();
      }
    }, t.prototype.stop = function() {
      return this.el.off("lt.resize"), this.el.off("rt.resize"), this.el.off("rb.resize"), this.el.off("lb.resize"), this.el.off("t.resize"), this.el.off("r.resize"), this.el.off("b.resize"), this.el.off("l.resize"), this.el.off("rot.resize"), this.el.off("point.resize"), this;
    }, t.prototype.resize = function(t2) {
      var e = this;
      this.m = this.el.node.getScreenCTM().inverse(), this.offset = { x: window.pageXOffset, y: window.pageYOffset };
      var i = this._extractPosition(t2.detail.event);
      if (this.parameters = { type: this.el.type, p: this.transformPoint(i.x, i.y), x: t2.detail.x, y: t2.detail.y, box: this.el.bbox(), rotation: this.el.transform().rotation }, "text" === this.el.type && (this.parameters.fontSize = this.el.attr()["font-size"]), void 0 !== t2.detail.i) {
        var s = this.el.array().valueOf();
        this.parameters.i = t2.detail.i, this.parameters.pointCoords = [s[t2.detail.i][0], s[t2.detail.i][1]];
      }
      switch (t2.type) {
        case "lt":
          this.calc = function(t3, e2) {
            var i2 = this.snapToGrid(t3, e2);
            if (this.parameters.box.width - i2[0] > 0 && this.parameters.box.height - i2[1] > 0) {
              if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x + i2[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - i2[0]);
              i2 = this.checkAspectRatio(i2), this.el.move(this.parameters.box.x + i2[0], this.parameters.box.y + i2[1]).size(this.parameters.box.width - i2[0], this.parameters.box.height - i2[1]);
            }
          };
          break;
        case "rt":
          this.calc = function(t3, e2) {
            var i2 = this.snapToGrid(t3, e2, 2);
            if (this.parameters.box.width + i2[0] > 0 && this.parameters.box.height - i2[1] > 0) {
              if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x - i2[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + i2[0]);
              i2 = this.checkAspectRatio(i2, true), this.el.move(this.parameters.box.x, this.parameters.box.y + i2[1]).size(this.parameters.box.width + i2[0], this.parameters.box.height - i2[1]);
            }
          };
          break;
        case "rb":
          this.calc = function(t3, e2) {
            var i2 = this.snapToGrid(t3, e2, 0);
            if (this.parameters.box.width + i2[0] > 0 && this.parameters.box.height + i2[1] > 0) {
              if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x - i2[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + i2[0]);
              i2 = this.checkAspectRatio(i2), this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + i2[0], this.parameters.box.height + i2[1]);
            }
          };
          break;
        case "lb":
          this.calc = function(t3, e2) {
            var i2 = this.snapToGrid(t3, e2, 1);
            if (this.parameters.box.width - i2[0] > 0 && this.parameters.box.height + i2[1] > 0) {
              if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x + i2[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - i2[0]);
              i2 = this.checkAspectRatio(i2, true), this.el.move(this.parameters.box.x + i2[0], this.parameters.box.y).size(this.parameters.box.width - i2[0], this.parameters.box.height + i2[1]);
            }
          };
          break;
        case "t":
          this.calc = function(t3, e2) {
            var i2 = this.snapToGrid(t3, e2, 2);
            if (this.parameters.box.height - i2[1] > 0) {
              if ("text" === this.parameters.type) return;
              this.el.move(this.parameters.box.x, this.parameters.box.y + i2[1]).height(this.parameters.box.height - i2[1]);
            }
          };
          break;
        case "r":
          this.calc = function(t3, e2) {
            var i2 = this.snapToGrid(t3, e2, 0);
            if (this.parameters.box.width + i2[0] > 0) {
              if ("text" === this.parameters.type) return;
              this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + i2[0]);
            }
          };
          break;
        case "b":
          this.calc = function(t3, e2) {
            var i2 = this.snapToGrid(t3, e2, 0);
            if (this.parameters.box.height + i2[1] > 0) {
              if ("text" === this.parameters.type) return;
              this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + i2[1]);
            }
          };
          break;
        case "l":
          this.calc = function(t3, e2) {
            var i2 = this.snapToGrid(t3, e2, 1);
            if (this.parameters.box.width - i2[0] > 0) {
              if ("text" === this.parameters.type) return;
              this.el.move(this.parameters.box.x + i2[0], this.parameters.box.y).width(this.parameters.box.width - i2[0]);
            }
          };
          break;
        case "rot":
          this.calc = function(t3, e2) {
            var i2 = t3 + this.parameters.p.x, s2 = e2 + this.parameters.p.y, a = Math.atan2(this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2, this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2), r = Math.atan2(s2 - this.parameters.box.y - this.parameters.box.height / 2, i2 - this.parameters.box.x - this.parameters.box.width / 2), n = this.parameters.rotation + 180 * (r - a) / Math.PI + this.options.snapToAngle / 2;
            this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(n - n % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy);
          };
          break;
        case "point":
          this.calc = function(t3, e2) {
            var i2 = this.snapToGrid(t3, e2, this.parameters.pointCoords[0], this.parameters.pointCoords[1]), s2 = this.el.array().valueOf();
            s2[this.parameters.i][0] = this.parameters.pointCoords[0] + i2[0], s2[this.parameters.i][1] = this.parameters.pointCoords[1] + i2[1], this.el.plot(s2);
          };
      }
      this.el.fire("resizestart", { dx: this.parameters.x, dy: this.parameters.y, event: t2 }), SVG.on(window, "touchmove.resize", function(t3) {
        e.update(t3 || window.event);
      }), SVG.on(window, "touchend.resize", function() {
        e.done();
      }), SVG.on(window, "mousemove.resize", function(t3) {
        e.update(t3 || window.event);
      }), SVG.on(window, "mouseup.resize", function() {
        e.done();
      });
    }, t.prototype.update = function(t2) {
      if (t2) {
        var e = this._extractPosition(t2), i = this.transformPoint(e.x, e.y), s = i.x - this.parameters.p.x, a = i.y - this.parameters.p.y;
        this.lastUpdateCall = [s, a], this.calc(s, a), this.el.fire("resizing", { dx: s, dy: a, event: t2 });
      } else this.lastUpdateCall && this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1]);
    }, t.prototype.done = function() {
      this.lastUpdateCall = null, SVG.off(window, "mousemove.resize"), SVG.off(window, "mouseup.resize"), SVG.off(window, "touchmove.resize"), SVG.off(window, "touchend.resize"), this.el.fire("resizedone");
    }, t.prototype.snapToGrid = function(t2, e, i, s) {
      var a;
      return void 0 !== s ? a = [(i + t2) % this.options.snapToGrid, (s + e) % this.options.snapToGrid] : (i = null == i ? 3 : i, a = [(this.parameters.box.x + t2 + (1 & i ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + e + (2 & i ? 0 : this.parameters.box.height)) % this.options.snapToGrid]), t2 < 0 && (a[0] -= this.options.snapToGrid), e < 0 && (a[1] -= this.options.snapToGrid), t2 -= Math.abs(a[0]) < this.options.snapToGrid / 2 ? a[0] : a[0] - (t2 < 0 ? -this.options.snapToGrid : this.options.snapToGrid), e -= Math.abs(a[1]) < this.options.snapToGrid / 2 ? a[1] : a[1] - (e < 0 ? -this.options.snapToGrid : this.options.snapToGrid), this.constraintToBox(t2, e, i, s);
    }, t.prototype.constraintToBox = function(t2, e, i, s) {
      var a, r, n = this.options.constraint || {};
      return void 0 !== s ? (a = i, r = s) : (a = this.parameters.box.x + (1 & i ? 0 : this.parameters.box.width), r = this.parameters.box.y + (2 & i ? 0 : this.parameters.box.height)), void 0 !== n.minX && a + t2 < n.minX && (t2 = n.minX - a), void 0 !== n.maxX && a + t2 > n.maxX && (t2 = n.maxX - a), void 0 !== n.minY && r + e < n.minY && (e = n.minY - r), void 0 !== n.maxY && r + e > n.maxY && (e = n.maxY - r), [t2, e];
    }, t.prototype.checkAspectRatio = function(t2, e) {
      if (!this.options.saveAspectRatio) return t2;
      var i = t2.slice(), s = this.parameters.box.width / this.parameters.box.height, a = this.parameters.box.width + t2[0], r = this.parameters.box.height - t2[1], n = a / r;
      return n < s ? (i[1] = a / s - this.parameters.box.height, e && (i[1] = -i[1])) : n > s && (i[0] = this.parameters.box.width - r * s, e && (i[0] = -i[0])), i;
    }, SVG.extend(SVG.Element, { resize: function(e) {
      return (this.remember("_resizeHandler") || new t(this)).init(e || {}), this;
    } }), SVG.Element.prototype.resize.defaults = { snapToAngle: 0.1, snapToGrid: 1, constraint: {}, saveAspectRatio: false };
  }).call(this);
})();
var css = '.apexcharts-canvas {\n  position: relative;\n  user-select: none;\n  /* cannot give overflow: hidden as it will crop tooltips which overflow outside chart area */\n}\n\n/* scrollbar is not visible by default for legend, hence forcing the visibility */\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px;\n}\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0,0,0,.5);\n  box-shadow: 0 0 1px rgba(255,255,255,.5);\n  -webkit-box-shadow: 0 0 1px rgba(255,255,255,.5);\n}\n.apexcharts-canvas.dark {\n  background: #343F57;\n}\n\n.apexcharts-inner {\n  position: relative;\n}\n\n.legend-mouseover-inactive {\n  transition: 0.15s ease all;\n  opacity: 0.20;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0;\n}\n\n.apexcharts-gridline, .apexcharts-text {\n  pointer-events: none;\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: 0.15s ease all;\n}\n.apexcharts-tooltip.light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255, 255, 255, 0.96);\n}\n.apexcharts-tooltip.dark {\n  color: #fff;\n  background: rgba(30,30,30, 0.8);\n}\n.apexcharts-tooltip * {\n  font-family: inherit;\n}\n\n.apexcharts-tooltip .apexcharts-marker,\n.apexcharts-area-series .apexcharts-area,\n.apexcharts-line {\n  pointer-events: none;\n}\n\n.apexcharts-tooltip.active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px;\n}\n.apexcharts-tooltip.light .apexcharts-tooltip-title {\n  background: #ECEFF1;\n  border-bottom: 1px solid #ddd;\n}\n.apexcharts-tooltip.dark .apexcharts-tooltip-title {\n  background: rgba(0, 0, 0, 0.7);\n  border-bottom: 1px solid #333;\n}\n\n.apexcharts-tooltip-text-value,\n.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  font-weight: 600;\n  margin-left: 5px;\n}\n\n.apexcharts-tooltip-text-z-label:empty,\n.apexcharts-tooltip-text-z-value:empty {\n  display: none;\n}\n\n.apexcharts-tooltip-text-value, \n.apexcharts-tooltip-text-z-value {\n  font-weight: 600;\n}\n\n.apexcharts-tooltip-marker {\n  width: 12px;\n  height: 12px;\n  position: relative;\n  top: 0px;\n  margin-right: 10px;\n  border-radius: 50%;\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center;\n}\n\n.apexcharts-tooltip-series-group.active .apexcharts-tooltip-marker {\n  opacity: 1;\n}\n.apexcharts-tooltip-series-group.active, .apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px;\n}\n.apexcharts-tooltip-series-group-hidden {\n  opacity: 0;\n  height: 0;\n  line-height: 0;\n  padding: 0 !important;\n}\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px;\n}\n.apexcharts-tooltip-candlestick {\n  padding: 4px 8px;\n}\n.apexcharts-tooltip-candlestick > div {\n  margin: 4px 0;\n}\n.apexcharts-tooltip-candlestick span.value {\n  font-weight: bold;\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px;\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777;\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: bold;\n  display: block;\n  margin-bottom: 5px;\n}\n\n.apexcharts-xaxistooltip {\n  opacity: 0;\n  padding: 9px 10px;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n	background: #ECEFF1;\n  border: 1px solid #90A4AE;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-xaxistooltip.dark {\n  background: rgba(0, 0, 0, 0.7);\n  border: 1px solid rgba(0, 0, 0, 0.5);\n  color: #fff;\n}\n\n.apexcharts-xaxistooltip:after, .apexcharts-xaxistooltip:before {\n	left: 50%;\n	border: solid transparent;\n	content: " ";\n	height: 0;\n	width: 0;\n	position: absolute;\n	pointer-events: none;\n}\n\n.apexcharts-xaxistooltip:after {\n	border-color: rgba(236, 239, 241, 0);\n	border-width: 6px;\n	margin-left: -6px;\n}\n.apexcharts-xaxistooltip:before {\n	border-color: rgba(144, 164, 174, 0);\n	border-width: 7px;\n	margin-left: -7px;\n}\n\n.apexcharts-xaxistooltip-bottom:after, .apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%;\n}\n\n.apexcharts-xaxistooltip-top:after, .apexcharts-xaxistooltip-top:before {\n  top: 100%;\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #ECEFF1;\n}\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90A4AE;\n}\n\n.apexcharts-xaxistooltip-bottom.dark:after {\n  border-bottom-color: rgba(0, 0, 0, 0.5);\n}\n.apexcharts-xaxistooltip-bottom.dark:before {\n  border-bottom-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color:#ECEFF1\n}\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90A4AE;\n}\n.apexcharts-xaxistooltip-top.dark:after {\n  border-top-color:rgba(0, 0, 0, 0.5);\n}\n.apexcharts-xaxistooltip-top.dark:before {\n  border-top-color: rgba(0, 0, 0, 0.5);\n}\n\n\n.apexcharts-xaxistooltip.active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-yaxistooltip {\n  opacity: 0;\n  padding: 4px 10px;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n	background: #ECEFF1;\n  border: 1px solid #90A4AE;\n}\n\n.apexcharts-yaxistooltip.dark {\n  background: rgba(0, 0, 0, 0.7);\n  border: 1px solid rgba(0, 0, 0, 0.5);\n  color: #fff;\n}\n\n.apexcharts-yaxistooltip:after, .apexcharts-yaxistooltip:before {\n	top: 50%;\n	border: solid transparent;\n	content: " ";\n	height: 0;\n	width: 0;\n	position: absolute;\n	pointer-events: none;\n}\n.apexcharts-yaxistooltip:after {\n	border-color: rgba(236, 239, 241, 0);\n	border-width: 6px;\n	margin-top: -6px;\n}\n.apexcharts-yaxistooltip:before {\n	border-color: rgba(144, 164, 174, 0);\n	border-width: 7px;\n	margin-top: -7px;\n}\n\n.apexcharts-yaxistooltip-left:after, .apexcharts-yaxistooltip-left:before {\n  left: 100%;\n}\n\n.apexcharts-yaxistooltip-right:after, .apexcharts-yaxistooltip-right:before {\n  right: 100%;\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #ECEFF1;\n}\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90A4AE;\n}\n.apexcharts-yaxistooltip-left.dark:after {\n  border-left-color: rgba(0, 0, 0, 0.5);\n}\n.apexcharts-yaxistooltip-left.dark:before {\n  border-left-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #ECEFF1;\n}\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90A4AE;\n}\n.apexcharts-yaxistooltip-right.dark:after {\n  border-right-color: rgba(0, 0, 0, 0.5);\n}\n.apexcharts-yaxistooltip-right.dark:before {\n  border-right-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip.active {\n  opacity: 1;\n}\n.apexcharts-yaxistooltip-hidden {\n  display: none;\n}\n\n.apexcharts-xcrosshairs, .apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-xcrosshairs.active, .apexcharts-ycrosshairs.active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0;\n}\n\n.apexcharts-zoom-rect {\n  pointer-events: none;\n}\n.apexcharts-selection-rect {\n  cursor: move;\n}\n\n.svg_select_points, .svg_select_points_rot {\n  opacity: 0;\n  visibility: hidden;\n}\n.svg_select_points_l, .svg_select_points_r {\n  cursor: ew-resize;\n  opacity: 1;\n  visibility: visible;\n  fill: #888;\n}\n.apexcharts-canvas.zoomable .hovering-zoom {\n  cursor: crosshair\n}\n.apexcharts-canvas.zoomable .hovering-pan {\n  cursor: move\n}\n\n.apexcharts-xaxis,\n.apexcharts-yaxis {\n  pointer-events: none;\n}\n\n.apexcharts-zoom-icon, \n.apexcharts-zoom-in-icon,\n.apexcharts-zoom-out-icon,\n.apexcharts-reset-zoom-icon, \n.apexcharts-pan-icon, \n.apexcharts-selection-icon,\n.apexcharts-menu-icon, \n.apexcharts-toolbar-custom-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6E8192;\n  text-align: center;\n}\n\n\n.apexcharts-zoom-icon svg, \n.apexcharts-zoom-in-icon svg,\n.apexcharts-zoom-out-icon svg,\n.apexcharts-reset-zoom-icon svg,\n.apexcharts-menu-icon svg {\n  fill: #6E8192;\n}\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(0.76)\n}\n\n.dark .apexcharts-zoom-icon svg, \n.dark .apexcharts-zoom-in-icon svg,\n.dark .apexcharts-zoom-out-icon svg,\n.dark .apexcharts-reset-zoom-icon svg, \n.dark .apexcharts-pan-icon svg, \n.dark .apexcharts-selection-icon svg,\n.dark .apexcharts-menu-icon svg, \n.dark .apexcharts-toolbar-custom-icon svg{\n  fill: #f3f4f5;\n}\n\n.apexcharts-canvas .apexcharts-zoom-icon.selected svg, \n.apexcharts-canvas .apexcharts-selection-icon.selected svg, \n.apexcharts-canvas .apexcharts-reset-zoom-icon.selected svg {\n  fill: #008FFB;\n}\n.light .apexcharts-selection-icon:not(.selected):hover svg,\n.light .apexcharts-zoom-icon:not(.selected):hover svg, \n.light .apexcharts-zoom-in-icon:hover svg, \n.light .apexcharts-zoom-out-icon:hover svg, \n.light .apexcharts-reset-zoom-icon:hover svg, \n.light .apexcharts-menu-icon:hover svg {\n  fill: #333;\n}\n\n.apexcharts-selection-icon, .apexcharts-menu-icon {\n  position: relative;\n}\n.apexcharts-reset-zoom-icon {\n  margin-left: 5px;\n}\n.apexcharts-zoom-icon, .apexcharts-reset-zoom-icon, .apexcharts-menu-icon {\n  transform: scale(0.85);\n}\n\n.apexcharts-zoom-in-icon, .apexcharts-zoom-out-icon {\n  transform: scale(0.7)\n}\n\n.apexcharts-zoom-out-icon {\n  margin-right: 3px;\n}\n\n.apexcharts-pan-icon {\n  transform: scale(0.62);\n  position: relative;\n  left: 1px;\n  top: 0px;\n}\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6E8192;\n  stroke-width: 2;\n}\n.apexcharts-pan-icon.selected svg {\n  stroke: #008FFB;\n}\n.apexcharts-pan-icon:not(.selected):hover svg {\n  stroke: #333;\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  top: 0px;\n  right: 3px;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0px 6px 2px 6px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center; \n}\n\n.apexcharts-toolbar svg {\n  pointer-events: none;\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: 0.15s ease all;\n  pointer-events: none;\n}\n\n.apexcharts-menu.open {\n  opacity: 1;\n  pointer-events: all;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer;\n}\n.light .apexcharts-menu-item:hover {\n  background: #eee;\n}\n.dark .apexcharts-menu {\n  background: rgba(0, 0, 0, 0.7);\n  color: #fff;\n}\n\n@media screen and (min-width: 768px) {\n  .apexcharts-toolbar {\n    /*opacity: 0;*/\n  }\n\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n    opacity: 1;\n  } \n}\n\n.apexcharts-datalabel.hidden {\n  opacity: 0;\n}\n\n.apexcharts-pie-label,\n.apexcharts-datalabel, .apexcharts-datalabel-label, .apexcharts-datalabel-value {\n  cursor: default;\n  pointer-events: none;\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: 0.3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease;\n}\n\n.apexcharts-canvas .hidden {\n  opacity: 0;\n}\n\n.apexcharts-hide .apexcharts-series-points {\n  opacity: 0;\n}\n\n.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events, .apexcharts-radar-series path, .apexcharts-radar-series polygon {\n  pointer-events: none;\n}\n\n/* markers */\n\n.apexcharts-marker {\n  transition: 0.15s ease all;\n}\n\n@keyframes opaque {\n  0% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n}';
styleInject(css), "document" in self && ("classList" in document.createElement("_") && (!document.createElementNS || "classList" in document.createElementNS("http://www.w3.org/2000/svg", "g")) || (function(t) {
  if ("Element" in t) {
    var e = t.Element.prototype, i = Object, s = String.prototype.trim || function() {
      return this.replace(/^\s+|\s+$/g, "");
    }, a = Array.prototype.indexOf || function(t2) {
      for (var e2 = 0, i2 = this.length; e2 < i2; e2++) if (e2 in this && this[e2] === t2) return e2;
      return -1;
    }, r = function(t2, e2) {
      this.name = t2, this.code = DOMException[t2], this.message = e2;
    }, n = function(t2, e2) {
      if ("" === e2) throw new r("SYNTAX_ERR", "The token must not be empty.");
      if (/\s/.test(e2)) throw new r("INVALID_CHARACTER_ERR", "The token must not contain space characters.");
      return a.call(t2, e2);
    }, o = function(t2) {
      for (var e2 = s.call(t2.getAttribute("class") || ""), i2 = e2 ? e2.split(/\s+/) : [], a2 = 0, r2 = i2.length; a2 < r2; a2++) this.push(i2[a2]);
      this._updateClassName = function() {
        t2.setAttribute("class", this.toString());
      };
    }, l = o.prototype = [], h = function() {
      return new o(this);
    };
    if (r.prototype = Error.prototype, l.item = function(t2) {
      return this[t2] || null;
    }, l.contains = function(t2) {
      return ~n(this, t2 + "");
    }, l.add = function() {
      var t2, e2 = arguments, i2 = 0, s2 = e2.length, a2 = false;
      do {
        t2 = e2[i2] + "", ~n(this, t2) || (this.push(t2), a2 = true);
      } while (++i2 < s2);
      a2 && this._updateClassName();
    }, l.remove = function() {
      var t2, e2, i2 = arguments, s2 = 0, a2 = i2.length, r2 = false;
      do {
        for (t2 = i2[s2] + "", e2 = n(this, t2); ~e2; ) this.splice(e2, 1), r2 = true, e2 = n(this, t2);
      } while (++s2 < a2);
      r2 && this._updateClassName();
    }, l.toggle = function(t2, e2) {
      var i2 = this.contains(t2), s2 = i2 ? true !== e2 && "remove" : false !== e2 && "add";
      return s2 && this[s2](t2), true === e2 || false === e2 ? e2 : !i2;
    }, l.replace = function(t2, e2) {
      var i2 = n(t2 + "");
      ~i2 && (this.splice(i2, 1, e2), this._updateClassName());
    }, l.toString = function() {
      return this.join(" ");
    }, i.defineProperty) {
      var c = { get: h, enumerable: true, configurable: true };
      try {
        i.defineProperty(e, "classList", c);
      } catch (t2) {
        void 0 !== t2.number && -2146823252 !== t2.number || (c.enumerable = false, i.defineProperty(e, "classList", c));
      }
    } else i.prototype.__defineGetter__ && e.__defineGetter__("classList", h);
  }
})(self), (function() {
  var t = document.createElement("_");
  if (t.classList.add("c1", "c2"), !t.classList.contains("c2")) {
    var e = function(t2) {
      var e2 = DOMTokenList.prototype[t2];
      DOMTokenList.prototype[t2] = function(t3) {
        var i2, s = arguments.length;
        for (i2 = 0; i2 < s; i2++) t3 = arguments[i2], e2.call(this, t3);
      };
    };
    e("add"), e("remove");
  }
  if (t.classList.toggle("c3", false), t.classList.contains("c3")) {
    var i = DOMTokenList.prototype.toggle;
    DOMTokenList.prototype.toggle = function(t2, e2) {
      return 1 in arguments && !this.contains(t2) == !e2 ? e2 : i.call(this, t2);
    };
  }
  "replace" in document.createElement("_").classList || (DOMTokenList.prototype.replace = function(t2, e2) {
    var i2 = this.toString().split(" "), s = i2.indexOf(t2 + "");
    ~s && (i2 = i2.slice(s), this.remove.apply(this, i2), this.add(e2), this.add.apply(this, i2.slice(1)));
  }), t = null;
})()), (function() {
  var t = false;
  function e(t2) {
    var e2 = t2.__resizeTriggers__, i2 = e2.firstElementChild, s2 = e2.lastElementChild, a2 = i2.firstElementChild;
    s2.scrollLeft = s2.scrollWidth, s2.scrollTop = s2.scrollHeight, a2.style.width = i2.offsetWidth + 1 + "px", a2.style.height = i2.offsetHeight + 1 + "px", i2.scrollLeft = i2.scrollWidth, i2.scrollTop = i2.scrollHeight;
  }
  function i(t2) {
    var i2 = this;
    e(this), this.__resizeRAF__ && n(this.__resizeRAF__), this.__resizeRAF__ = r(function() {
      (function(t3) {
        return t3.offsetWidth != t3.__resizeLast__.width || t3.offsetHeight != t3.__resizeLast__.height;
      })(i2) && (i2.__resizeLast__.width = i2.offsetWidth, i2.__resizeLast__.height = i2.offsetHeight, i2.__resizeListeners__.forEach(function(e2) {
        e2.call(t2);
      }));
    });
  }
  var s, a, r = (s = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function(t2) {
    return window.setTimeout(t2, 20);
  }, function(t2) {
    return s(t2);
  }), n = (a = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.clearTimeout, function(t2) {
    return a(t2);
  }), o = false, l = "", h = "animationstart", c = "Webkit Moz O ms".split(" "), d = "webkitAnimationStart animationstart oAnimationStart MSAnimationStart".split(" "), u = document.createElement("fakeelement");
  if (void 0 !== u.style.animationName && (o = true), false === o) {
    for (var g = 0; g < c.length; g++) if (void 0 !== u.style[c[g] + "AnimationName"]) {
      l = "-" + c[g].toLowerCase() + "-", h = d[g];
      break;
    }
  }
  var f = "@" + l + "keyframes resizeanim { from { opacity: 0; } to { opacity: 0; } } ", p = l + "animation: 1ms resizeanim; ";
  window.addResizeListener = function(s2, a2) {
    s2.__resizeTriggers__ || ("static" == getComputedStyle(s2).position && (s2.style.position = "relative"), (function() {
      if (!t) {
        var e2 = (f || "") + ".resize-triggers { " + (p || "") + 'visibility: hidden; opacity: 0; } .resize-triggers, .resize-triggers > div, .contract-trigger:before { content: " "; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }', i2 = document.head || document.getElementsByTagName("head")[0], s3 = document.createElement("style");
        s3.type = "text/css", s3.styleSheet ? s3.styleSheet.cssText = e2 : s3.appendChild(document.createTextNode(e2)), i2.appendChild(s3), t = true;
      }
    })(), s2.__resizeLast__ = {}, s2.__resizeListeners__ = [], (s2.__resizeTriggers__ = document.createElement("div")).className = "resize-triggers", s2.__resizeTriggers__.innerHTML = '<div class="expand-trigger"><div></div></div><div class="contract-trigger"></div>', s2.appendChild(s2.__resizeTriggers__), e(s2), s2.addEventListener("scroll", i, true), h && s2.__resizeTriggers__.addEventListener(h, function(t2) {
      "resizeanim" == t2.animationName && e(s2);
    })), s2.__resizeListeners__.push(a2);
  }, window.removeResizeListener = function(t2, e2) {
    t2 && (t2.__resizeListeners__.splice(t2.__resizeListeners__.indexOf(e2), 1), t2.__resizeListeners__.length || (t2.removeEventListener("scroll", i), t2.__resizeTriggers__ = !t2.removeChild(t2.__resizeTriggers__)));
  };
})(), window.Apex = {};
var ApexCharts$1 = (function() {
  function t(e, i) {
    _classCallCheck(this, t), this.opts = i, this.ctx = this, this.w = new Base(i).init(), this.el = e, this.w.globals.cuid = (Math.random() + 1).toString(36).substring(4), this.w.globals.chartID = this.w.config.chart.id ? this.w.config.chart.id : this.w.globals.cuid, this.eventList = ["mousedown", "mousemove", "touchstart", "touchmove", "mouseup", "touchend"], this.initModules(), this.create = Utils.bind(this.create, this), this.documentEvent = Utils.bind(this.documentEvent, this), this.windowResizeHandler = this.windowResize.bind(this);
  }
  return _createClass(t, [{ key: "render", value: function() {
    var t2 = this;
    return new Promise$1(function(e, i) {
      if (null !== t2.el) {
        void 0 === Apex._chartInstances && (Apex._chartInstances = []), t2.w.config.chart.id && Apex._chartInstances.push({ id: t2.w.globals.chartID, group: t2.w.config.chart.group, chart: t2 }), t2.setLocale(t2.w.config.chart.defaultLocale);
        var s = t2.w.config.chart.events.beforeMount;
        "function" == typeof s && s(t2, t2.w), t2.fireEvent("beforeMount", [t2, t2.w]), window.addEventListener("resize", t2.windowResizeHandler), window.addResizeListener(t2.el.parentNode, t2.parentResizeCallback.bind(t2));
        var a = t2.create(t2.w.config.series, {});
        if (!a) return e(t2);
        t2.mount(a).then(function() {
          e(a), "function" == typeof t2.w.config.chart.events.mounted && t2.w.config.chart.events.mounted(t2, t2.w), t2.fireEvent("mounted", [t2, t2.w]);
        }).catch(function(t3) {
          i(t3);
        });
      } else i(new Error("Element not found"));
    });
  } }, { key: "initModules", value: function() {
    this.animations = new Animations(this), this.core = new Core(this.el, this), this.grid = new Grid(this), this.coreUtils = new CoreUtils(this), this.config = new Config({}), this.crosshairs = new Crosshairs(this), this.options = new Options(), this.responsive = new Responsive(this), this.series = new Series(this), this.theme = new Theme(this), this.formatters = new Formatters(this), this.titleSubtitle = new TitleSubtitle(this), this.legend = new Legend(this), this.toolbar = new Toolbar(this), this.dimensions = new Dimensions(this), this.zoomPanSelection = new ZoomPanSelection(this), this.w.globals.tooltip = new Tooltip(this);
  } }, { key: "addEventListener", value: function(t2, e) {
    var i = this.w;
    i.globals.events.hasOwnProperty(t2) ? i.globals.events[t2].push(e) : i.globals.events[t2] = [e];
  } }, { key: "removeEventListener", value: function(t2, e) {
    var i = this.w;
    if (i.globals.events.hasOwnProperty(t2)) {
      var s = i.globals.events[t2].indexOf(e);
      -1 !== s && i.globals.events[t2].splice(s, 1);
    }
  } }, { key: "fireEvent", value: function(t2, e) {
    var i = this.w;
    if (i.globals.events.hasOwnProperty(t2)) {
      e && e.length || (e = []);
      for (var s = i.globals.events[t2], a = s.length, r = 0; r < a; r++) s[r].apply(null, e);
    }
  } }, { key: "create", value: function(t2, e) {
    var i = this.w;
    this.initModules();
    var s = this.w.globals;
    if (s.noData = false, s.animationEnded = false, this.responsive.checkResponsiveConfig(e), null === this.el) return s.animationEnded = true, null;
    if (this.core.setupElements(), 0 === s.svgWidth) return s.animationEnded = true, null;
    var a = CoreUtils.checkComboSeries(t2);
    s.comboCharts = a.comboCharts, s.comboChartsHasBars = a.comboChartsHasBars, (0 === t2.length || 1 === t2.length && t2[0].data && 0 === t2[0].data.length) && this.series.handleNoData(), this.setupEventHandlers(), this.core.parseData(t2), this.theme.init(), new Markers(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), i.globals.noData || this.legend.init(), this.series.hasAllSeriesEqualX(), s.axisCharts && (this.core.coreCalculations(), "category" !== i.config.xaxis.type && this.formatters.setLabelFormatters()), this.formatters.heatmapLabelFormatters(), this.dimensions.plotCoords();
    var r = this.core.xySettings();
    this.grid.createGridMask();
    var n = this.core.plotChartType(t2, r);
    this.core.shiftGraphPosition();
    var o = { plot: { left: i.globals.translateX, top: i.globals.translateY, width: i.globals.gridWidth, height: i.globals.gridHeight } };
    return { elGraph: n, xyRatios: r, elInner: i.globals.dom.elGraphical, dimensions: o };
  } }, { key: "mount", value: function() {
    var t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, e = this, i = e.w;
    return new Promise$1(function(s, a) {
      if (null === e.el) return a(new Error("Not enough data to display or target element not found"));
      if ((null === t2 || i.globals.allSeriesCollapsed) && e.series.handleNoData(), e.annotations = new Annotations(e), e.core.drawAxis(i.config.chart.type, t2.xyRatios), e.grid = new Grid(e), "back" === i.config.grid.position && e.grid.drawGrid(), "back" === i.config.annotations.position && e.annotations.drawAnnotations(), t2.elGraph instanceof Array) for (var r = 0; r < t2.elGraph.length; r++) i.globals.dom.elGraphical.add(t2.elGraph[r]);
      else i.globals.dom.elGraphical.add(t2.elGraph);
      if ("front" === i.config.grid.position && e.grid.drawGrid(), "front" === i.config.xaxis.crosshairs.position && e.crosshairs.drawXCrosshairs(), "front" === i.config.yaxis[0].crosshairs.position && e.crosshairs.drawYCrosshairs(), "front" === i.config.annotations.position && e.annotations.drawAnnotations(), !i.globals.noData) {
        if (i.config.tooltip.enabled && !i.globals.noData && e.w.globals.tooltip.drawTooltip(t2.xyRatios), i.globals.axisCharts && i.globals.isXNumeric) (i.config.chart.zoom.enabled || i.config.chart.selection && i.config.chart.selection.enabled || i.config.chart.pan && i.config.chart.pan.enabled) && e.zoomPanSelection.init({ xyRatios: t2.xyRatios });
        else {
          var n = i.config.chart.toolbar.tools;
          n.zoom = false, n.zoomin = false, n.zoomout = false, n.selection = false, n.pan = false, n.reset = false;
        }
        i.config.chart.toolbar.show && !i.globals.allSeriesCollapsed && e.toolbar.createToolbar();
      }
      i.globals.memory.methodsToExec.length > 0 && i.globals.memory.methodsToExec.forEach(function(t3) {
        t3.method(t3.params, false, t3.context);
      }), i.globals.axisCharts || i.globals.noData || e.core.resizeNonAxisCharts(), s(e);
    });
  } }, { key: "clearPreviousPaths", value: function() {
    var t2 = this.w;
    t2.globals.previousPaths = [], t2.globals.allSeriesCollapsed = false, t2.globals.collapsedSeries = [], t2.globals.collapsedSeriesIndices = [];
  } }, { key: "updateOptions", value: function(t2) {
    var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], s = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], a = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], r = this.w;
    return t2.series && (this.resetSeries(false), t2.series.length && t2.series[0].data && (t2.series = t2.series.map(function(t3, e2) {
      return _objectSpread({}, r.config.series[e2], { name: t3.name ? t3.name : r.config.series[e2] && r.config.series[e2].name, type: t3.type ? t3.type : r.config.series[e2] && r.config.series[e2].type, data: t3.data ? t3.data : r.config.series[e2] && r.config.series[e2].data });
    })), this.revertDefaultAxisMinMax()), t2.xaxis && ((t2.xaxis.min || t2.xaxis.max) && this.forceXAxisUpdate(t2), t2.xaxis.categories && t2.xaxis.categories.length && r.config.xaxis.convertedCatToNumeric && (t2 = Defaults.convertCatToNumeric(t2))), r.globals.collapsedSeriesIndices.length > 0 && this.clearPreviousPaths(), t2.theme && (t2 = this.theme.updateThemeOptions(t2)), this._updateOptions(t2, e, i, s, a);
  } }, { key: "_updateOptions", value: function(t2) {
    var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], s = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], a = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], r = [this];
    s && (r = this.getSyncedCharts()), this.w.globals.isExecCalled && (r = [this], this.w.globals.isExecCalled = false), r.forEach(function(s2) {
      var r2 = s2.w;
      return r2.globals.shouldAnimate = i, e || (r2.globals.resized = true, r2.globals.dataChanged = true, i && s2.series.getPreviousPaths()), t2 && "object" === _typeof(t2) && (s2.config = new Config(t2), t2 = CoreUtils.extendArrayProps(s2.config, t2), r2.config = Utils.extend(r2.config, t2), a && (r2.globals.lastXAxis = [], r2.globals.lastYAxis = [], r2.globals.initialConfig = Utils.extend({}, r2.config), r2.globals.initialSeries = JSON.parse(JSON.stringify(r2.config.series)))), s2.update(t2);
    });
  } }, { key: "updateSeries", value: function() {
    var t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
    return this.resetSeries(false), this.revertDefaultAxisMinMax(), this._updateSeries(t2, e, i);
  } }, { key: "appendSeries", value: function(t2) {
    var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], s = this.w.config.series.slice();
    return s.push(t2), this.resetSeries(false), this.revertDefaultAxisMinMax(), this._updateSeries(s, e, i);
  } }, { key: "_updateSeries", value: function(t2, e) {
    var i, s = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], a = this.w;
    return this.w.globals.shouldAnimate = e, a.globals.dataChanged = true, a.globals.allSeriesCollapsed && (a.globals.allSeriesCollapsed = false), e && this.series.getPreviousPaths(), a.globals.axisCharts ? (0 === (i = t2.map(function(t3, e2) {
      return _objectSpread({}, a.config.series[e2], { name: t3.name ? t3.name : a.config.series[e2] && a.config.series[e2].name, type: t3.type ? t3.type : a.config.series[e2] && a.config.series[e2].type, data: t3.data ? t3.data : a.config.series[e2] && a.config.series[e2].data });
    })).length && (i = [{ data: [] }]), a.config.series = i) : a.config.series = t2.slice(), s && (a.globals.initialConfig.series = JSON.parse(JSON.stringify(a.config.series)), a.globals.initialSeries = JSON.parse(JSON.stringify(a.config.series))), this.update();
  } }, { key: "getSyncedCharts", value: function() {
    var t2 = this.getGroupedCharts(), e = [this];
    return t2.length && (e = [], t2.forEach(function(t3) {
      e.push(t3);
    })), e;
  } }, { key: "getGroupedCharts", value: function() {
    var t2 = this;
    return Apex._chartInstances.filter(function(t3) {
      if (t3.group) return true;
    }).map(function(e) {
      return t2.w.config.chart.group === e.group ? e.chart : t2;
    });
  } }, { key: "appendData", value: function(t2) {
    var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i = this;
    i.w.globals.dataChanged = true, i.series.getPreviousPaths();
    for (var s = i.w.config.series.slice(), a = 0; a < s.length; a++) if (void 0 !== t2[a]) for (var r = 0; r < t2[a].data.length; r++) s[a].data.push(t2[a].data[r]);
    return i.w.config.series = s, e && (i.w.globals.initialSeries = JSON.parse(JSON.stringify(i.w.config.series))), this.update();
  } }, { key: "update", value: function(t2) {
    var e = this;
    return new Promise$1(function(i, s) {
      e.clear();
      var a = e.create(e.w.config.series, t2);
      if (!a) return i(e);
      e.mount(a).then(function() {
        "function" == typeof e.w.config.chart.events.updated && e.w.config.chart.events.updated(e, e.w), e.fireEvent("updated", [e, e.w]), e.w.globals.isDirty = true, i(e);
      }).catch(function(t3) {
        s(t3);
      });
    });
  } }, { key: "forceXAxisUpdate", value: function(t2) {
    var e = this.w;
    void 0 !== t2.xaxis.min && (e.config.xaxis.min = t2.xaxis.min, e.globals.lastXAxis.min = t2.xaxis.min), void 0 !== t2.xaxis.max && (e.config.xaxis.max = t2.xaxis.max, e.globals.lastXAxis.max = t2.xaxis.max);
  } }, { key: "revertDefaultAxisMinMax", value: function() {
    var t2 = this.w;
    t2.config.xaxis.min = t2.globals.lastXAxis.min, t2.config.xaxis.max = t2.globals.lastXAxis.max, t2.config.yaxis.map(function(e, i) {
      t2.globals.zoomed && void 0 !== t2.globals.lastYAxis[i] && (e.min = t2.globals.lastYAxis[i].min, e.max = t2.globals.lastYAxis[i].max);
    });
  } }, { key: "clear", value: function() {
    this.zoomPanSelection && this.zoomPanSelection.destroy(), this.toolbar && this.toolbar.destroy(), this.animations = null, this.annotations = null, this.core = null, this.grid = null, this.series = null, this.responsive = null, this.theme = null, this.formatters = null, this.titleSubtitle = null, this.legend = null, this.dimensions = null, this.options = null, this.crosshairs = null, this.zoomPanSelection = null, this.toolbar = null, this.w.globals.tooltip = null, this.clearDomElements();
  } }, { key: "killSVG", value: function(t2) {
    return new Promise$1(function(e, i) {
      t2.each(function(t3, e2) {
        this.removeClass("*"), this.off(), this.stop();
      }, true), t2.ungroup(), t2.clear(), e("done");
    });
  } }, { key: "clearDomElements", value: function() {
    var t2 = this;
    this.eventList.forEach(function(e2) {
      document.removeEventListener(e2, t2.documentEvent);
    });
    var e = this.w.globals.dom;
    if (null !== this.el) for (; this.el.firstChild; ) this.el.removeChild(this.el.firstChild);
    this.killSVG(e.Paper), e.Paper.remove(), e.elWrap = null, e.elGraphical = null, e.elLegendWrap = null, e.baseEl = null, e.elGridRect = null, e.elGridRectMask = null, e.elGridRectMarkerMask = null, e.elDefs = null;
  } }, { key: "destroy", value: function() {
    this.clear();
    var t2 = this.w.config.chart.id;
    t2 && Apex._chartInstances.forEach(function(e, i) {
      e.id === t2 && Apex._chartInstances.splice(i, 1);
    }), window.removeEventListener("resize", this.windowResizeHandler), window.removeResizeListener(this.el.parentNode, this.parentResizeCallback.bind(this));
  } }, { key: "toggleSeries", value: function(t2) {
    var e = this.series.getSeriesByName(t2), i = parseInt(e.getAttribute("data:realIndex")), s = e.classList.contains("apexcharts-series-collapsed");
    this.legend.toggleDataSeries(i, s);
  } }, { key: "resetSeries", value: function() {
    var t2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    this.series.resetSeries(t2);
  } }, { key: "setupEventHandlers", value: function() {
    var t2 = this, e = this.w, i = this, s = e.globals.dom.baseEl.querySelector(e.globals.chartClass);
    this.eventListHandlers = [], this.eventList.forEach(function(t3) {
      s.addEventListener(t3, function(t4) {
        var s2 = Object.assign({}, e, { seriesIndex: e.globals.capturedSeriesIndex, dataPointIndex: e.globals.capturedDataPointIndex });
        "mousemove" === t4.type || "touchmove" === t4.type ? "function" == typeof e.config.chart.events.mouseMove && e.config.chart.events.mouseMove(t4, i, s2) : ("mouseup" === t4.type && 1 === t4.which || "touchend" === t4.type) && ("function" == typeof e.config.chart.events.click && e.config.chart.events.click(t4, i, s2), i.fireEvent("click", [t4, i, s2]));
      }, { capture: false, passive: true });
    }), this.eventList.forEach(function(e2) {
      document.addEventListener(e2, t2.documentEvent);
    }), this.core.setupBrushHandler();
  } }, { key: "documentEvent", value: function(t2) {
    var e = this.w;
    e.globals.clientX = "touchmove" === t2.type ? t2.touches[0].clientX : t2.clientX, e.globals.clientY = "touchmove" === t2.type ? t2.touches[0].clientY : t2.clientY;
  } }, { key: "addXaxisAnnotation", value: function(t2) {
    var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, s = this;
    i && (s = i), s.annotations.addXaxisAnnotationExternal(t2, e, s);
  } }, { key: "addYaxisAnnotation", value: function(t2) {
    var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, s = this;
    i && (s = i), s.annotations.addYaxisAnnotationExternal(t2, e, s);
  } }, { key: "addPointAnnotation", value: function(t2) {
    var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, s = this;
    i && (s = i), s.annotations.addPointAnnotationExternal(t2, e, s);
  } }, { key: "clearAnnotations", value: function() {
    var t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0, e = this;
    t2 && (e = t2), e.annotations.clearAnnotations(e);
  } }, { key: "addText", value: function(t2) {
    var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, s = this;
    i && (s = i), s.annotations.addText(t2, e, s);
  } }, { key: "getChartArea", value: function() {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner");
  } }, { key: "getSeriesTotalXRange", value: function(t2, e) {
    return this.coreUtils.getSeriesTotalsXRange(t2, e);
  } }, { key: "getHighestValueInSeries", value: function() {
    var t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
    return new Range$1(this.ctx).getMinYMaxY(t2).highestY;
  } }, { key: "getLowestValueInSeries", value: function() {
    var t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
    return new Range$1(this.ctx).getMinYMaxY(t2).lowestY;
  } }, { key: "getSeriesTotal", value: function() {
    return this.w.globals.seriesTotals;
  } }, { key: "setLocale", value: function(t2) {
    this.setCurrentLocaleValues(t2);
  } }, { key: "toggleDataPointSelection", value: function(t2, e) {
    var i = this.w, s = null;
    i.globals.axisCharts ? s = i.globals.dom.Paper.select(".apexcharts-series[data\\:realIndex='".concat(t2, "'] path[j='").concat(e, "'], .apexcharts-series[data\\:realIndex='").concat(t2, "'] circle[j='").concat(e, "'], .apexcharts-series[data\\:realIndex='").concat(t2, "'] rect[j='").concat(e, "']")).members[0] : (s = i.globals.dom.Paper.select(".apexcharts-series[data\\:realIndex='".concat(t2, "']")).members[0], ("pie" === i.config.chart.type || "donut" === i.config.chart.type) && new Pie(this.ctx).pieClicked(t2));
    s ? new Graphics(this.ctx).pathMouseDown(s, null) : console.warn("toggleDataPointSelection: Element not found");
    return s.node ? s.node : null;
  } }, { key: "setCurrentLocaleValues", value: function(t2) {
    var e = this.w.config.chart.locales;
    window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (e = this.w.config.chart.locales.concat(window.Apex.chart.locales));
    var i = e.filter(function(e2) {
      return e2.name === t2;
    })[0];
    if (!i) throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
    var s = Utils.extend(en, i);
    this.w.globals.locale = s.options;
  } }, { key: "dataURI", value: function() {
    return new Exports(this.ctx).dataURI();
  } }, { key: "paper", value: function() {
    return this.w.globals.dom.Paper;
  } }, { key: "parentResizeCallback", value: function() {
    this.w.globals.animationEnded && this.windowResize();
  } }, { key: "windowResize", value: function() {
    var t2 = this;
    clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout(function() {
      t2.w.globals.resized = true, t2.w.globals.dataChanged = false, t2.update();
    }, 150);
  } }], [{ key: "initOnLoad", value: function() {
    for (var e = document.querySelectorAll("[data-apexcharts]"), i = 0; i < e.length; i++) {
      new t(e[i], JSON.parse(e[i].getAttribute("data-options"))).render();
    }
  } }, { key: "exec", value: function(t2, e) {
    var i = this.getChartByID(t2);
    if (i) {
      i.w.globals.isExecCalled = true;
      for (var s = arguments.length, a = new Array(s > 2 ? s - 2 : 0), r = 2; r < s; r++) a[r - 2] = arguments[r];
      switch (e) {
        case "updateOptions":
          return i.updateOptions.apply(i, a);
        case "updateSeries":
          return i.updateSeries.apply(i, a);
        case "appendData":
          return i.appendData.apply(i, a);
        case "appendSeries":
          return i.appendSeries.apply(i, a);
        case "toggleSeries":
          return i.toggleSeries.apply(i, a);
        case "resetSeries":
          return i.resetSeries.apply(i, a);
        case "toggleDataPointSelection":
          return i.toggleDataPointSelection.apply(i, a);
        case "dataURI":
          return i.dataURI.apply(i, a);
        case "addXaxisAnnotation":
          return i.addXaxisAnnotation.apply(i, a);
        case "addYaxisAnnotation":
          return i.addYaxisAnnotation.apply(i, a);
        case "addPointAnnotation":
          return i.addPointAnnotation.apply(i, a);
        case "addText":
          return i.addText.apply(i, a);
        case "clearAnnotations":
          return i.clearAnnotations.apply(i, a);
        case "paper":
          return i.paper.apply(i, a);
        case "destroy":
          return i.destroy();
      }
    }
  } }, { key: "merge", value: function(t2, e) {
    return Utils.extend(t2, e);
  } }, { key: "getChartByID", value: function(t2) {
    return Apex._chartInstances.filter(function(e) {
      return e.id === t2;
    })[0].chart;
  } }]), t;
})();
var apexcharts_esm_default = ApexCharts$1;
export {
  apexcharts_esm_default as default
};
//# sourceMappingURL=apexcharts.js.map
